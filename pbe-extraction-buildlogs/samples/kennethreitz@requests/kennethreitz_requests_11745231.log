Using worker: worker-linux-6-2.bb.travis-ci.org:travis-linux-19

$ export HTTPBIN_URL=http://httpbin.org/
travis_fold:start:git.1$ git clone --depth=50 --branch=master git://github.com/kennethreitz/requests.git kennethreitz/requests
Cloning into 'kennethreitz/requests'...
remote: Counting objects: 1590, done.[K
remote: Compressing objects:   0% (1/1089)   [Kremote: Compressing objects:   1% (11/1089)   [Kremote: Compressing objects:   2% (22/1089)   [Kremote: Compressing objects:   3% (33/1089)   [Kremote: Compressing objects:   4% (44/1089)   [Kremote: Compressing objects:   5% (55/1089)   [Kremote: Compressing objects:   6% (66/1089)   [Kremote: Compressing objects:   7% (77/1089)   [Kremote: Compressing objects:   8% (88/1089)   [Kremote: Compressing objects:   9% (99/1089)   [Kremote: Compressing objects:  10% (109/1089)   [Kremote: Compressing objects:  11% (120/1089)   [Kremote: Compressing objects:  12% (131/1089)   [Kremote: Compressing objects:  13% (142/1089)   [Kremote: Compressing objects:  14% (153/1089)   [Kremote: Compressing objects:  15% (164/1089)   [Kremote: Compressing objects:  16% (175/1089)   [Kremote: Compressing objects:  17% (186/1089)   [Kremote: Compressing objects:  18% (197/1089)   [Kremote: Compressing objects:  19% (207/1089)   [Kremote: Compressing objects:  20% (218/1089)   [Kremote: Compressing objects:  21% (229/1089)   [Kremote: Compressing objects:  22% (240/1089)   [Kremote: Compressing objects:  23% (251/1089)   [Kremote: Compressing objects:  24% (262/1089)   [Kremote: Compressing objects:  25% (273/1089)   [Kremote: Compressing objects:  26% (284/1089)   [Kremote: Compressing objects:  27% (295/1089)   [Kremote: Compressing objects:  28% (305/1089)   [Kremote: Compressing objects:  29% (316/1089)   [Kremote: Compressing objects:  30% (327/1089)   [Kremote: Compressing objects:  31% (338/1089)   [Kremote: Compressing objects:  32% (349/1089)   [Kremote: Compressing objects:  33% (360/1089)   [Kremote: Compressing objects:  34% (371/1089)   [Kremote: Compressing objects:  35% (382/1089)   [Kremote: Compressing objects:  36% (393/1089)   [Kremote: Compressing objects:  37% (403/1089)   [Kremote: Compressing objects:  38% (414/1089)   [Kremote: Compressing objects:  39% (425/1089)   [Kremote: Compressing objects:  40% (436/1089)   [Kremote: Compressing objects:  41% (447/1089)   [Kremote: Compressing objects:  42% (458/1089)   [Kremote: Compressing objects:  43% (469/1089)   [Kremote: Compressing objects:  44% (480/1089)   [Kremote: Compressing objects:  45% (491/1089)   [Kremote: Compressing objects:  46% (501/1089)   [Kremote: Compressing objects:  47% (512/1089)   [Kremote: Compressing objects:  48% (523/1089)   [Kremote: Compressing objects:  49% (534/1089)   [Kremote: Compressing objects:  50% (545/1089)   [Kremote: Compressing objects:  51% (556/1089)   [Kremote: Compressing objects:  52% (567/1089)   [Kremote: Compressing objects:  53% (578/1089)   [Kremote: Compressing objects:  54% (589/1089)   [Kremote: Compressing objects:  55% (599/1089)   [Kremote: Compressing objects:  56% (610/1089)   [Kremote: Compressing objects:  57% (621/1089)   [Kremote: Compressing objects:  58% (632/1089)   [Kremote: Compressing objects:  59% (643/1089)   [Kremote: Compressing objects:  60% (654/1089)   [Kremote: Compressing objects:  61% (665/1089)   [Kremote: Compressing objects:  62% (676/1089)   [Kremote: Compressing objects:  63% (687/1089)   [Kremote: Compressing objects:  64% (697/1089)   [Kremote: Compressing objects:  65% (708/1089)   [Kremote: Compressing objects:  66% (719/1089)   [Kremote: Compressing objects:  67% (730/1089)   [Kremote: Compressing objects:  68% (741/1089)   [Kremote: Compressing objects:  69% (752/1089)   [Kremote: Compressing objects:  70% (763/1089)   [Kremote: Compressing objects:  71% (774/1089)   [Kremote: Compressing objects:  72% (785/1089)   [Kremote: Compressing objects:  73% (795/1089)   [Kremote: Compressing objects:  74% (806/1089)   [Kremote: Compressing objects:  75% (817/1089)   [Kremote: Compressing objects:  76% (828/1089)   [Kremote: Compressing objects:  77% (839/1089)   [Kremote: Compressing objects:  78% (850/1089)   [Kremote: Compressing objects:  79% (861/1089)   [Kremote: Compressing objects:  80% (872/1089)   [Kremote: Compressing objects:  81% (883/1089)   [Kremote: Compressing objects:  82% (893/1089)   [Kremote: Compressing objects:  83% (904/1089)   [Kremote: Compressing objects:  84% (915/1089)   [Kremote: Compressing objects:  85% (926/1089)   [Kremote: Compressing objects:  86% (937/1089)   [Kremote: Compressing objects:  87% (948/1089)   [Kremote: Compressing objects:  88% (959/1089)   [Kremote: Compressing objects:  89% (970/1089)   [Kremote: Compressing objects:  90% (981/1089)   [Kremote: Compressing objects:  91% (991/1089)   [Kremote: Compressing objects:  92% (1002/1089)   [Kremote: Compressing objects:  93% (1013/1089)   [Kremote: Compressing objects:  94% (1024/1089)   [Kremote: Compressing objects:  95% (1035/1089)   [Kremote: Compressing objects:  96% (1046/1089)   [Kremote: Compressing objects:  97% (1057/1089)   [Kremote: Compressing objects:  98% (1068/1089)   [Kremote: Compressing objects:  99% (1079/1089)   [Kremote: Compressing objects: 100% (1089/1089)   [Kremote: Compressing objects: 100% (1089/1089), done.[K
Receiving objects:   0% (1/1590)   Receiving objects:   1% (16/1590)   Receiving objects:   2% (32/1590)   Receiving objects:   3% (48/1590)   Receiving objects:   4% (64/1590)   Receiving objects:   5% (80/1590)   Receiving objects:   6% (96/1590)   Receiving objects:   7% (112/1590)   Receiving objects:   8% (128/1590)   Receiving objects:   9% (144/1590)   Receiving objects:  10% (159/1590)   Receiving objects:  11% (175/1590)   Receiving objects:  12% (191/1590)   Receiving objects:  13% (207/1590)   Receiving objects:  14% (223/1590)   Receiving objects:  15% (239/1590)   Receiving objects:  16% (255/1590)   Receiving objects:  17% (271/1590)   Receiving objects:  18% (287/1590)   Receiving objects:  19% (303/1590)   Receiving objects:  20% (318/1590)   Receiving objects:  21% (334/1590)   Receiving objects:  22% (350/1590)   Receiving objects:  23% (366/1590)   Receiving objects:  24% (382/1590)   Receiving objects:  25% (398/1590)   Receiving objects:  26% (414/1590)   Receiving objects:  27% (430/1590)   Receiving objects:  28% (446/1590)   Receiving objects:  29% (462/1590)   Receiving objects:  30% (477/1590)   Receiving objects:  31% (493/1590)   Receiving objects:  32% (509/1590)   Receiving objects:  33% (525/1590)   Receiving objects:  34% (541/1590)   Receiving objects:  35% (557/1590)   Receiving objects:  36% (573/1590)   Receiving objects:  37% (589/1590)   Receiving objects:  38% (605/1590)   Receiving objects:  39% (621/1590)   Receiving objects:  40% (636/1590)   Receiving objects:  41% (652/1590)   Receiving objects:  42% (668/1590)   Receiving objects:  43% (684/1590)   Receiving objects:  44% (700/1590)   Receiving objects:  45% (716/1590)   Receiving objects:  46% (732/1590)   Receiving objects:  47% (748/1590)   Receiving objects:  48% (764/1590)   Receiving objects:  49% (780/1590)   Receiving objects:  50% (795/1590)   Receiving objects:  51% (811/1590)   Receiving objects:  52% (827/1590)   Receiving objects:  53% (843/1590)   Receiving objects:  54% (859/1590)   Receiving objects:  55% (875/1590)   Receiving objects:  56% (891/1590)   Receiving objects:  57% (907/1590)   Receiving objects:  58% (923/1590)   Receiving objects:  59% (939/1590)   Receiving objects:  60% (954/1590)   Receiving objects:  61% (970/1590)   Receiving objects:  62% (986/1590)   Receiving objects:  63% (1002/1590)   Receiving objects:  64% (1018/1590)   Receiving objects:  65% (1034/1590)   Receiving objects:  66% (1050/1590)   Receiving objects:  67% (1066/1590)   Receiving objects:  68% (1082/1590)   Receiving objects:  69% (1098/1590)   Receiving objects:  70% (1113/1590)   Receiving objects:  71% (1129/1590)   Receiving objects:  72% (1145/1590)   Receiving objects:  73% (1161/1590)   Receiving objects:  74% (1177/1590)   Receiving objects:  75% (1193/1590)   Receiving objects:  76% (1209/1590)   Receiving objects:  77% (1225/1590)   Receiving objects:  78% (1241/1590)   Receiving objects:  79% (1257/1590)   Receiving objects:  80% (1272/1590)   Receiving objects:  81% (1288/1590)   Receiving objects:  82% (1304/1590)   Receiving objects:  83% (1320/1590)   Receiving objects:  84% (1336/1590)   Receiving objects:  85% (1352/1590)   Receiving objects:  86% (1368/1590)   Receiving objects:  87% (1384/1590)   Receiving objects:  88% (1400/1590)   remote: Total 1590 (delta 951), reused 1082 (delta 489)[K
Receiving objects:  89% (1416/1590)   Receiving objects:  90% (1431/1590)   Receiving objects:  91% (1447/1590)   Receiving objects:  92% (1463/1590)   Receiving objects:  93% (1479/1590)   Receiving objects:  94% (1495/1590)   Receiving objects:  95% (1511/1590)   Receiving objects:  96% (1527/1590)   Receiving objects:  97% (1543/1590)   Receiving objects:  98% (1559/1590)   Receiving objects:  99% (1575/1590)   Receiving objects: 100% (1590/1590)   Receiving objects: 100% (1590/1590), 851.49 KiB | 0 bytes/s, done.
Resolving deltas:   0% (0/951)   Resolving deltas:   1% (15/951)   Resolving deltas:   7% (71/951)   Resolving deltas:  10% (99/951)   Resolving deltas:  11% (106/951)   Resolving deltas:  12% (117/951)   Resolving deltas:  13% (125/951)   Resolving deltas:  16% (154/951)   Resolving deltas:  17% (167/951)   Resolving deltas:  18% (175/951)   Resolving deltas:  19% (183/951)   Resolving deltas:  20% (193/951)   Resolving deltas:  21% (201/951)   Resolving deltas:  22% (211/951)   Resolving deltas:  25% (245/951)   Resolving deltas:  28% (270/951)   Resolving deltas:  31% (299/951)   Resolving deltas:  35% (335/951)   Resolving deltas:  36% (344/951)   Resolving deltas:  37% (355/951)   Resolving deltas:  38% (363/951)   Resolving deltas:  39% (379/951)   Resolving deltas:  41% (398/951)   Resolving deltas:  42% (400/951)   Resolving deltas:  44% (427/951)   Resolving deltas:  45% (430/951)   Resolving deltas:  49% (466/951)   Resolving deltas:  50% (478/951)   Resolving deltas:  52% (496/951)   Resolving deltas:  56% (535/951)   Resolving deltas:  58% (552/951)   Resolving deltas:  59% (565/951)   Resolving deltas:  61% (589/951)   Resolving deltas:  62% (595/951)   Resolving deltas:  63% (601/951)   Resolving deltas:  64% (612/951)   Resolving deltas:  65% (620/951)   Resolving deltas:  66% (630/951)   Resolving deltas:  69% (665/951)   Resolving deltas:  70% (669/951)   Resolving deltas:  71% (678/951)   Resolving deltas:  72% (688/951)   Resolving deltas:  73% (695/951)   Resolving deltas:  74% (705/951)   Resolving deltas:  75% (716/951)   Resolving deltas:  76% (724/951)   Resolving deltas:  77% (737/951)   Resolving deltas:  78% (749/951)   Resolving deltas:  79% (759/951)   Resolving deltas:  80% (762/951)   Resolving deltas:  84% (801/951)   Resolving deltas:  89% (854/951)   Resolving deltas:  91% (869/951)   Resolving deltas:  92% (878/951)   Resolving deltas:  93% (885/951)   Resolving deltas:  94% (896/951)   Resolving deltas:  95% (906/951)   Resolving deltas: 100% (951/951)   Resolving deltas: 100% (951/951), done.
travis_fold:end:git.1$ cd kennethreitz/requests
travis_fold:start:git.2$ git checkout -qf 2d283c9f2ddc8a7c1429317f5e521671349839b2
travis_fold:end:git.2$ source ~/virtualenv/python2.6/bin/activate
$ python --version
Python 2.6.8
$ pip --version
pip 1.3.1 from /home/travis/virtualenv/python2.6/lib/python2.6/site-packages/pip-1.3.1-py2.6.egg (python 2.6)
travis_fold:start:install$ pip install -r requirements.txt
Downloading/unpacking py==1.4.12 (from -r requirements.txt (line 1))
  Downloading py-1.4.12.zip (227kB):   Downloading py-1.4.12.zip (227kB):   1%  4.1kB  Downloading py-1.4.12.zip (227kB):   3%  8.2kB  Downloading py-1.4.12.zip (227kB):   5%  12kB   Downloading py-1.4.12.zip (227kB):   7%  16kB  Downloading py-1.4.12.zip (227kB):   9%  20kB  Downloading py-1.4.12.zip (227kB):  10%  24kB  Downloading py-1.4.12.zip (227kB):  12%  28kB  Downloading py-1.4.12.zip (227kB):  14%  32kB  Downloading py-1.4.12.zip (227kB):  16%  36kB  Downloading py-1.4.12.zip (227kB):  18%  40kB  Downloading py-1.4.12.zip (227kB):  19%  45kB  Downloading py-1.4.12.zip (227kB):  21%  49kB  Downloading py-1.4.12.zip (227kB):  23%  53kB  Downloading py-1.4.12.zip (227kB):  25%  57kB  Downloading py-1.4.12.zip (227kB):  27%  61kB  Downloading py-1.4.12.zip (227kB):  28%  65kB  Downloading py-1.4.12.zip (227kB):  30%  69kB  Downloading py-1.4.12.zip (227kB):  32%  73kB  Downloading py-1.4.12.zip (227kB):  34%  77kB  Downloading py-1.4.12.zip (227kB):  36%  81kB  Downloading py-1.4.12.zip (227kB):  37%  86kB  Downloading py-1.4.12.zip (227kB):  39%  90kB  Downloading py-1.4.12.zip (227kB):  41%  94kB  Downloading py-1.4.12.zip (227kB):  43%  98kB  Downloading py-1.4.12.zip (227kB):  45%  102kB  Downloading py-1.4.12.zip (227kB):  46%  106kB  Downloading py-1.4.12.zip (227kB):  48%  110kB  Downloading py-1.4.12.zip (227kB):  50%  114kB  Downloading py-1.4.12.zip (227kB):  52%  118kB  Downloading py-1.4.12.zip (227kB):  54%  122kB  Downloading py-1.4.12.zip (227kB):  55%  126kB  Downloading py-1.4.12.zip (227kB):  57%  131kB  Downloading py-1.4.12.zip (227kB):  59%  135kB  Downloading py-1.4.12.zip (227kB):  61%  139kB  Downloading py-1.4.12.zip (227kB):  63%  143kB  Downloading py-1.4.12.zip (227kB):  64%  147kB  Downloading py-1.4.12.zip (227kB):  66%  151kB  Downloading py-1.4.12.zip (227kB):  68%  155kB  Downloading py-1.4.12.zip (227kB):  70%  159kB  Downloading py-1.4.12.zip (227kB):  72%  163kB  Downloading py-1.4.12.zip (227kB):  73%  167kB  Downloading py-1.4.12.zip (227kB):  75%  172kB  Downloading py-1.4.12.zip (227kB):  77%  176kB  Downloading py-1.4.12.zip (227kB):  79%  180kB  Downloading py-1.4.12.zip (227kB):  81%  184kB  Downloading py-1.4.12.zip (227kB):  82%  188kB  Downloading py-1.4.12.zip (227kB):  84%  192kB  Downloading py-1.4.12.zip (227kB):  86%  196kB  Downloading py-1.4.12.zip (227kB):  88%  200kB  Downloading py-1.4.12.zip (227kB):  90%  204kB  Downloading py-1.4.12.zip (227kB):  91%  208kB  Downloading py-1.4.12.zip (227kB):  93%  212kB  Downloading py-1.4.12.zip (227kB):  95%  217kB  Downloading py-1.4.12.zip (227kB):  97%  221kB  Downloading py-1.4.12.zip (227kB):  99%  225kB  Downloading py-1.4.12.zip (227kB): 100%  227kB  Downloading py-1.4.12.zip (227kB):              Downloading py-1.4.12.zip (227kB): 227kB downloaded
  Running setup.py egg_info for package py
Downloading/unpacking pytest==2.3.4 (from -r requirements.txt (line 2))
  Downloading pytest-2.3.4.zip (527kB):   Downloading pytest-2.3.4.zip (527kB):   0%  4.1kB  Downloading pytest-2.3.4.zip (527kB):   1%  8.2kB  Downloading pytest-2.3.4.zip (527kB):   2%  12kB   Downloading pytest-2.3.4.zip (527kB):   3%  16kB  Downloading pytest-2.3.4.zip (527kB):   3%  20kB  Downloading pytest-2.3.4.zip (527kB):   4%  24kB  Downloading pytest-2.3.4.zip (527kB):   5%  28kB  Downloading pytest-2.3.4.zip (527kB):   6%  32kB  Downloading pytest-2.3.4.zip (527kB):   6%  36kB  Downloading pytest-2.3.4.zip (527kB):   7%  40kB  Downloading pytest-2.3.4.zip (527kB):   8%  45kB  Downloading pytest-2.3.4.zip (527kB):   9%  49kB  Downloading pytest-2.3.4.zip (527kB):  10%  53kB  Downloading pytest-2.3.4.zip (527kB):  10%  57kB  Downloading pytest-2.3.4.zip (527kB):  11%  61kB  Downloading pytest-2.3.4.zip (527kB):  12%  65kB  Downloading pytest-2.3.4.zip (527kB):  13%  69kB  Downloading pytest-2.3.4.zip (527kB):  13%  73kB  Downloading pytest-2.3.4.zip (527kB):  14%  77kB  Downloading pytest-2.3.4.zip (527kB):  15%  81kB  Downloading pytest-2.3.4.zip (527kB):  16%  86kB  Downloading pytest-2.3.4.zip (527kB):  17%  90kB  Downloading pytest-2.3.4.zip (527kB):  17%  94kB  Downloading pytest-2.3.4.zip (527kB):  18%  98kB  Downloading pytest-2.3.4.zip (527kB):  19%  102kB  Downloading pytest-2.3.4.zip (527kB):  20%  106kB  Downloading pytest-2.3.4.zip (527kB):  20%  110kB  Downloading pytest-2.3.4.zip (527kB):  21%  114kB  Downloading pytest-2.3.4.zip (527kB):  22%  118kB  Downloading pytest-2.3.4.zip (527kB):  23%  122kB  Downloading pytest-2.3.4.zip (527kB):  24%  126kB  Downloading pytest-2.3.4.zip (527kB):  24%  131kB  Downloading pytest-2.3.4.zip (527kB):  25%  135kB  Downloading pytest-2.3.4.zip (527kB):  26%  139kB  Downloading pytest-2.3.4.zip (527kB):  27%  143kB  Downloading pytest-2.3.4.zip (527kB):  27%  147kB  Downloading pytest-2.3.4.zip (527kB):  28%  151kB  Downloading pytest-2.3.4.zip (527kB):  29%  155kB  Downloading pytest-2.3.4.zip (527kB):  30%  159kB  Downloading pytest-2.3.4.zip (527kB):  31%  163kB  Downloading pytest-2.3.4.zip (527kB):  31%  167kB  Downloading pytest-2.3.4.zip (527kB):  32%  172kB  Downloading pytest-2.3.4.zip (527kB):  33%  176kB  Downloading pytest-2.3.4.zip (527kB):  34%  180kB  Downloading pytest-2.3.4.zip (527kB):  34%  184kB  Downloading pytest-2.3.4.zip (527kB):  35%  188kB  Downloading pytest-2.3.4.zip (527kB):  36%  192kB  Downloading pytest-2.3.4.zip (527kB):  37%  196kB  Downloading pytest-2.3.4.zip (527kB):  38%  200kB  Downloading pytest-2.3.4.zip (527kB):  38%  204kB  Downloading pytest-2.3.4.zip (527kB):  39%  208kB  Downloading pytest-2.3.4.zip (527kB):  40%  212kB  Downloading pytest-2.3.4.zip (527kB):  41%  217kB  Downloading pytest-2.3.4.zip (527kB):  41%  221kB  Downloading pytest-2.3.4.zip (527kB):  42%  225kB  Downloading pytest-2.3.4.zip (527kB):  43%  229kB  Downloading pytest-2.3.4.zip (527kB):  44%  233kB  Downloading pytest-2.3.4.zip (527kB):  45%  237kB  Downloading pytest-2.3.4.zip (527kB):  45%  241kB  Downloading pytest-2.3.4.zip (527kB):  46%  245kB  Downloading pytest-2.3.4.zip (527kB):  47%  249kB  Downloading pytest-2.3.4.zip (527kB):  48%  253kB  Downloading pytest-2.3.4.zip (527kB):  48%  258kB  Downloading pytest-2.3.4.zip (527kB):  49%  262kB  Downloading pytest-2.3.4.zip (527kB):  50%  266kB  Downloading pytest-2.3.4.zip (527kB):  51%  270kB  Downloading pytest-2.3.4.zip (527kB):  52%  274kB  Downloading pytest-2.3.4.zip (527kB):  52%  278kB  Downloading pytest-2.3.4.zip (527kB):  53%  282kB  Downloading pytest-2.3.4.zip (527kB):  54%  286kB  Downloading pytest-2.3.4.zip (527kB):  55%  290kB  Downloading pytest-2.3.4.zip (527kB):  55%  294kB  Downloading pytest-2.3.4.zip (527kB):  56%  299kB  Downloading pytest-2.3.4.zip (527kB):  57%  303kB  Downloading pytest-2.3.4.zip (527kB):  58%  307kB  Downloading pytest-2.3.4.zip (527kB):  59%  311kB  Downloading pytest-2.3.4.zip (527kB):  59%  315kB  Downloading pytest-2.3.4.zip (527kB):  60%  319kB  Downloading pytest-2.3.4.zip (527kB):  61%  323kB  Downloading pytest-2.3.4.zip (527kB):  62%  327kB  Downloading pytest-2.3.4.zip (527kB):  62%  331kB  Downloading pytest-2.3.4.zip (527kB):  63%  335kB  Downloading pytest-2.3.4.zip (527kB):  64%  339kB  Downloading pytest-2.3.4.zip (527kB):  65%  344kB  Downloading pytest-2.3.4.zip (527kB):  66%  348kB  Downloading pytest-2.3.4.zip (527kB):  66%  352kB  Downloading pytest-2.3.4.zip (527kB):  67%  356kB  Downloading pytest-2.3.4.zip (527kB):  68%  360kB  Downloading pytest-2.3.4.zip (527kB):  69%  364kB  Downloading pytest-2.3.4.zip (527kB):  69%  368kB  Downloading pytest-2.3.4.zip (527kB):  70%  372kB  Downloading pytest-2.3.4.zip (527kB):  71%  376kB  Downloading pytest-2.3.4.zip (527kB):  72%  380kB  Downloading pytest-2.3.4.zip (527kB):  73%  385kB  Downloading pytest-2.3.4.zip (527kB):  73%  389kB  Downloading pytest-2.3.4.zip (527kB):  74%  393kB  Downloading pytest-2.3.4.zip (527kB):  75%  397kB  Downloading pytest-2.3.4.zip (527kB):  76%  401kB  Downloading pytest-2.3.4.zip (527kB):  76%  405kB  Downloading pytest-2.3.4.zip (527kB):  77%  409kB  Downloading pytest-2.3.4.zip (527kB):  78%  413kB  Downloading pytest-2.3.4.zip (527kB):  79%  417kB  Downloading pytest-2.3.4.zip (527kB):  80%  421kB  Downloading pytest-2.3.4.zip (527kB):  80%  425kB  Downloading pytest-2.3.4.zip (527kB):  81%  430kB  Downloading pytest-2.3.4.zip (527kB):  82%  434kB  Downloading pytest-2.3.4.zip (527kB):  83%  438kB  Downloading pytest-2.3.4.zip (527kB):  83%  442kB  Downloading pytest-2.3.4.zip (527kB):  84%  446kB  Downloading pytest-2.3.4.zip (527kB):  85%  450kB  Downloading pytest-2.3.4.zip (527kB):  86%  454kB  Downloading pytest-2.3.4.zip (527kB):  87%  458kB  Downloading pytest-2.3.4.zip (527kB):  87%  462kB  Downloading pytest-2.3.4.zip (527kB):  88%  466kB  Downloading pytest-2.3.4.zip (527kB):  89%  471kB  Downloading pytest-2.3.4.zip (527kB):  90%  475kB  Downloading pytest-2.3.4.zip (527kB):  90%  479kB  Downloading pytest-2.3.4.zip (527kB):  91%  483kB  Downloading pytest-2.3.4.zip (527kB):  92%  487kB  Downloading pytest-2.3.4.zip (527kB):  93%  491kB  Downloading pytest-2.3.4.zip (527kB):  94%  495kB  Downloading pytest-2.3.4.zip (527kB):  94%  499kB  Downloading pytest-2.3.4.zip (527kB):  95%  503kB  Downloading pytest-2.3.4.zip (527kB):  96%  507kB  Downloading pytest-2.3.4.zip (527kB):  97%  512kB  Downloading pytest-2.3.4.zip (527kB):  97%  516kB  Downloading pytest-2.3.4.zip (527kB):  98%  520kB  Downloading pytest-2.3.4.zip (527kB):  99%  524kB  Downloading pytest-2.3.4.zip (527kB): 100%  527kB  Downloading pytest-2.3.4.zip (527kB):              Downloading pytest-2.3.4.zip (527kB): 527kB downloaded
  Running setup.py egg_info for package pytest
Downloading/unpacking invoke==0.2.0 (from -r requirements.txt (line 3))
  Downloading invoke-0.2.0.tar.gz (108kB):   Downloading invoke-0.2.0.tar.gz (108kB):   3%  4.1kB  Downloading invoke-0.2.0.tar.gz (108kB):   7%  8.2kB  Downloading invoke-0.2.0.tar.gz (108kB):  11%  12kB   Downloading invoke-0.2.0.tar.gz (108kB):  15%  16kB  Downloading invoke-0.2.0.tar.gz (108kB):  18%  20kB  Downloading invoke-0.2.0.tar.gz (108kB):  22%  24kB  Downloading invoke-0.2.0.tar.gz (108kB):  26%  28kB  Downloading invoke-0.2.0.tar.gz (108kB):  30%  32kB  Downloading invoke-0.2.0.tar.gz (108kB):  34%  36kB  Downloading invoke-0.2.0.tar.gz (108kB):  37%  40kB  Downloading invoke-0.2.0.tar.gz (108kB):  41%  45kB  Downloading invoke-0.2.0.tar.gz (108kB):  45%  49kB  Downloading invoke-0.2.0.tar.gz (108kB):  49%  53kB  Downloading invoke-0.2.0.tar.gz (108kB):  53%  57kB  Downloading invoke-0.2.0.tar.gz (108kB):  56%  61kB  Downloading invoke-0.2.0.tar.gz (108kB):  60%  65kB  Downloading invoke-0.2.0.tar.gz (108kB):  64%  69kB  Downloading invoke-0.2.0.tar.gz (108kB):  68%  73kB  Downloading invoke-0.2.0.tar.gz (108kB):  71%  77kB  Downloading invoke-0.2.0.tar.gz (108kB):  75%  81kB  Downloading invoke-0.2.0.tar.gz (108kB):  79%  86kB  Downloading invoke-0.2.0.tar.gz (108kB):  83%  90kB  Downloading invoke-0.2.0.tar.gz (108kB):  87%  94kB  Downloading invoke-0.2.0.tar.gz (108kB):  90%  98kB  Downloading invoke-0.2.0.tar.gz (108kB):  94%  102kB  Downloading invoke-0.2.0.tar.gz (108kB):  98%  106kB  Downloading invoke-0.2.0.tar.gz (108kB): 100%  108kB  Downloading invoke-0.2.0.tar.gz (108kB):              Downloading invoke-0.2.0.tar.gz (108kB): 108kB downloaded
  Running setup.py egg_info for package invoke
    warning: no previously-included files matching '*' found under directory 'docs/_build'
    warning: no previously-included files matching '*.pyc' found under directory 'tests'
    warning: no previously-included files matching '*.pyo' found under directory 'tests'
Downloading/unpacking pexpect-u==2.5.1 (from invoke==0.2.0->-r requirements.txt (line 3))
  Downloading pexpect-u-2.5.1.tar.gz (128kB):   Downloading pexpect-u-2.5.1.tar.gz (128kB):   3%  4.1kB  Downloading pexpect-u-2.5.1.tar.gz (128kB):   6%  8.2kB  Downloading pexpect-u-2.5.1.tar.gz (128kB):   9%  12kB   Downloading pexpect-u-2.5.1.tar.gz (128kB):  12%  16kB  Downloading pexpect-u-2.5.1.tar.gz (128kB):  15%  20kB  Downloading pexpect-u-2.5.1.tar.gz (128kB):  19%  24kB  Downloading pexpect-u-2.5.1.tar.gz (128kB):  22%  28kB  Downloading pexpect-u-2.5.1.tar.gz (128kB):  25%  32kB  Downloading pexpect-u-2.5.1.tar.gz (128kB):  28%  36kB  Downloading pexpect-u-2.5.1.tar.gz (128kB):  31%  40kB  Downloading pexpect-u-2.5.1.tar.gz (128kB):  34%  45kB  Downloading pexpect-u-2.5.1.tar.gz (128kB):  38%  49kB  Downloading pexpect-u-2.5.1.tar.gz (128kB):  41%  53kB  Downloading pexpect-u-2.5.1.tar.gz (128kB):  44%  57kB  Downloading pexpect-u-2.5.1.tar.gz (128kB):  47%  61kB  Downloading pexpect-u-2.5.1.tar.gz (128kB):  50%  65kB  Downloading pexpect-u-2.5.1.tar.gz (128kB):  54%  69kB  Downloading pexpect-u-2.5.1.tar.gz (128kB):  57%  73kB  Downloading pexpect-u-2.5.1.tar.gz (128kB):  60%  77kB  Downloading pexpect-u-2.5.1.tar.gz (128kB):  63%  81kB  Downloading pexpect-u-2.5.1.tar.gz (128kB):  66%  86kB  Downloading pexpect-u-2.5.1.tar.gz (128kB):  69%  90kB  Downloading pexpect-u-2.5.1.tar.gz (128kB):  73%  94kB  Downloading pexpect-u-2.5.1.tar.gz (128kB):  76%  98kB  Downloading pexpect-u-2.5.1.tar.gz (128kB):  79%  102kB  Downloading pexpect-u-2.5.1.tar.gz (128kB):  82%  106kB  Downloading pexpect-u-2.5.1.tar.gz (128kB):  85%  110kB  Downloading pexpect-u-2.5.1.tar.gz (128kB):  89%  114kB  Downloading pexpect-u-2.5.1.tar.gz (128kB):  92%  118kB  Downloading pexpect-u-2.5.1.tar.gz (128kB):  95%  122kB  Downloading pexpect-u-2.5.1.tar.gz (128kB):  98%  126kB  Downloading pexpect-u-2.5.1.tar.gz (128kB): 100%  128kB  Downloading pexpect-u-2.5.1.tar.gz (128kB):              Downloading pexpect-u-2.5.1.tar.gz (128kB): 128kB downloaded
  Running setup.py egg_info for package pexpect-u
Installing collected packages: py, pytest, invoke, pexpect-u
  Found existing installation: py 1.4.15
    Uninstalling py:
      Successfully uninstalled py
  Running setup.py install for py
  Found existing installation: pytest 2.3.5
    Uninstalling pytest:
      Successfully uninstalled pytest
  Running setup.py install for pytest
    Installing py.test script to /home/travis/virtualenv/python2.6/bin
    Installing py.test-2.6 script to /home/travis/virtualenv/python2.6/bin
  Running setup.py install for invoke
    warning: no previously-included files matching '*' found under directory 'docs/_build'
    warning: no previously-included files matching '*.pyc' found under directory 'tests'
    warning: no previously-included files matching '*.pyo' found under directory 'tests'
    Installing inv script to /home/travis/virtualenv/python2.6/bin
    Installing invoke script to /home/travis/virtualenv/python2.6/bin
  Running setup.py install for pexpect-u
Successfully installed py pytest invoke pexpect-u
Cleaning up...
travis_fold:end:install$ invoke test
[1m============================= test session starts ==============================[0m
platform linux2 -- Python 2.6.8 -- pytest-2.3.4
[1mcollecting 0 items[0m[1mcollecting 60 items[0m[1mcollecting 66 items[0m[1mcollecting 84 items[0m[1mcollecting 84 items[0m[1mcollected 84 items 
[0m
test_requests.py FFFFFFFFFFFFFF.F....FFFFFF.FF..F.....F..F.FFFFF.FFFF.FFF.FFF........................

=================================== FAILURES ===================================
____________ RequestsTestCase.test_BASICAUTH_TUPLE_HTTP_200_OK_GET _____________

self = <test_requests.RequestsTestCase testMethod=test_BASICAUTH_TUPLE_HTTP_200_OK_GET>

[1m    def test_BASICAUTH_TUPLE_HTTP_200_OK_GET(self):[0m
[1m        auth = ('user', 'pass')[0m
[1m        url = httpbin('basic-auth', 'user', 'pass')[0m
[1m    [0m
[1m>       r = requests.get(url, auth=auth)[0m

test_requests.py:220: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

url = 'http://httpbin.org/basic-auth/user/pass'
kwargs = {'allow_redirects': True, 'auth': ('user', 'pass')}

[1m    def get(url, **kwargs):[0m
[1m        """Sends a GET request. Returns :class:`Response` object.[0m
[1m    [0m
[1m        :param url: URL for the new :class:`Request` object.[0m
[1m        :param \*\*kwargs: Optional arguments that ``request`` takes.[0m
[1m        """[0m
[1m    [0m
[1m        kwargs.setdefault('allow_redirects', True)[0m
[1m>       return request('get', url, **kwargs)[0m

requests/api.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

method = 'get', url = 'http://httpbin.org/basic-auth/user/pass'
kwargs = {'allow_redirects': True, 'auth': ('user', 'pass')}
session = <requests.sessions.Session object at 0x268fbd0>

[1m    def request(method, url, **kwargs):[0m
[1m        """Constructs and sends a :class:`Request <Request>`.[0m
[1m        Returns :class:`Response <Response>` object.[0m
[1m    [0m
[1m        :param method: method for the new :class:`Request` object.[0m
[1m        :param url: URL for the new :class:`Request` object.[0m
[1m        :param params: (optional) Dictionary or bytes to be sent in the query string for the :class:`Request`.[0m
[1m        :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.[0m
[1m        :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.[0m
[1m        :param cookies: (optional) Dict or CookieJar object to send with the :class:`Request`.[0m
[1m        :param files: (optional) Dictionary of 'name': file-like-objects (or {'name': ('filename', fileobj)}) for multipart encoding upload.[0m
[1m        :param auth: (optional) Auth tuple to enable Basic/Digest/Custom HTTP Auth.[0m
[1m        :param timeout: (optional) Float describing the timeout of the request.[0m
[1m        :param allow_redirects: (optional) Boolean. Set to True if POST/PUT/DELETE redirect following is allowed.[0m
[1m        :param proxies: (optional) Dictionary mapping protocol to the URL of the proxy.[0m
[1m        :param verify: (optional) if ``True``, the SSL cert will be verified. A CA_BUNDLE path can also be provided.[0m
[1m        :param stream: (optional) if ``False``, the response content will be immediately downloaded.[0m
[1m        :param cert: (optional) if String, path to ssl client cert file (.pem). If Tuple, ('cert', 'key') pair.[0m
[1m    [0m
[1m        Usage::[0m
[1m    [0m
[1m          >>> import requests[0m
[1m          >>> req = requests.request('GET', 'http://httpbin.org/get')[0m
[1m          <Response [200]>[0m
[1m        """[0m
[1m    [0m
[1m        session = sessions.Session()[0m
[1m>       return session.request(method=method, url=url, **kwargs)[0m

requests/api.py:44: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x268fbd0>, method = 'get'
url = 'http://httpbin.org/basic-auth/user/pass', params = None, data = None
headers = None, cookies = None, files = None, auth = ('user', 'pass')
timeout = None, allow_redirects = True, proxies = OrderedDict(), hooks = None
stream = False, verify = True, cert = None

[1m    def request(self, method, url,[0m
[1m        params=None,[0m
[1m        data=None,[0m
[1m        headers=None,[0m
[1m        cookies=None,[0m
[1m        files=None,[0m
[1m        auth=None,[0m
[1m        timeout=None,[0m
[1m        allow_redirects=True,[0m
[1m        proxies=None,[0m
[1m        hooks=None,[0m
[1m        stream=None,[0m
[1m        verify=None,[0m
[1m        cert=None):[0m
[1m        """Constructs a :class:`Request <Request>`, prepares it and sends it.[0m
[1m            Returns :class:`Response <Response>` object.[0m
[1m    [0m
[1m            :param method: method for the new :class:`Request` object.[0m
[1m            :param url: URL for the new :class:`Request` object.[0m
[1m            :param params: (optional) Dictionary or bytes to be sent in the query[0m
[1m                string for the :class:`Request`.[0m
[1m            :param data: (optional) Dictionary or bytes to send in the body of the[0m
[1m                :class:`Request`.[0m
[1m            :param headers: (optional) Dictionary of HTTP Headers to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param cookies: (optional) Dict or CookieJar object to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param files: (optional) Dictionary of 'filename': file-like-objects[0m
[1m                for multipart encoding upload.[0m
[1m            :param auth: (optional) Auth tuple or callable to enable[0m
[1m                Basic/Digest/Custom HTTP Auth.[0m
[1m            :param timeout: (optional) Float describing the timeout of the[0m
[1m                request.[0m
[1m            :param allow_redirects: (optional) Boolean. Set to True by default.[0m
[1m            :param proxies: (optional) Dictionary mapping protocol to the URL of[0m
[1m                the proxy.[0m
[1m            :param stream: (optional) whether to immediately download the response[0m
[1m                content. Defaults to ``False``.[0m
[1m            :param verify: (optional) if ``True``, the SSL cert will be verified.[0m
[1m                A CA_BUNDLE path can also be provided.[0m
[1m            :param cert: (optional) if String, path to ssl client cert file (.pem).[0m
[1m                If Tuple, ('cert', 'key') pair.[0m
[1m            """[0m
[1m        # Create the Request.[0m
[1m        req = Request([0m
[1m            method = method.upper(),[0m
[1m            url = url,[0m
[1m            headers = headers,[0m
[1m            files = files,[0m
[1m            data = data or {},[0m
[1m            params = params or {},[0m
[1m            auth = auth,[0m
[1m            cookies = cookies,[0m
[1m            hooks = hooks,[0m
[1m        )[0m
[1m        prep = self.prepare_request(req)[0m
[1m    [0m
[1m        proxies = proxies or {}[0m
[1m    [0m
[1m        # Gather clues from the surrounding environment.[0m
[1m        if self.trust_env:[0m
[1m            # Set environment's proxies.[0m
[1m            env_proxies = get_environ_proxies(url) or {}[0m
[1m            for (k, v) in env_proxies.items():[0m
[1m                proxies.setdefault(k, v)[0m
[1m    [0m
[1m            # Look for configuration.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('REQUESTS_CA_BUNDLE')[0m
[1m    [0m
[1m            # Curl compatibility.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('CURL_CA_BUNDLE')[0m
[1m    [0m
[1m        # Merge all the kwargs.[0m
[1m        proxies = merge_setting(proxies, self.proxies)[0m
[1m        stream = merge_setting(stream, self.stream)[0m
[1m        verify = merge_setting(verify, self.verify)[0m
[1m        cert = merge_setting(cert, self.cert)[0m
[1m    [0m
[1m        # Send the request.[0m
[1m        send_kwargs = {[0m
[1m            'stream': stream,[0m
[1m            'timeout': timeout,[0m
[1m            'verify': verify,[0m
[1m            'cert': cert,[0m
[1m            'proxies': proxies,[0m
[1m            'allow_redirects': allow_redirects,[0m
[1m        }[0m
[1m>       resp = self.send(prep, **send_kwargs)[0m

requests/sessions.py:357: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x268fbd0>
request = <PreparedRequest [GET]>
kwargs = {'cert': None, 'proxies': OrderedDict(), 'stream': False, 'timeout': None, ...}
allow_redirects = True, stream = False, timeout = None, verify = True
cert = None, proxies = OrderedDict(), hooks = {'response': []}

[1m    def send(self, request, **kwargs):[0m
[1m        """Send a given PreparedRequest."""[0m
[1m        # Set defaults that the hooks can utilize to ensure they always have[0m
[1m        # the correct parameters to reproduce the previous request.[0m
[1m        kwargs.setdefault('stream', self.stream)[0m
[1m        kwargs.setdefault('verify', self.verify)[0m
[1m        kwargs.setdefault('cert', self.cert)[0m
[1m        kwargs.setdefault('proxies', self.proxies)[0m
[1m    [0m
[1m        # It's possible that users might accidentally send a Request object.[0m
[1m        # Guard against that specific failure case.[0m
[1m        if not isinstance(request, PreparedRequest):[0m
[1m            raise ValueError('You can only send PreparedRequests.')[0m
[1m    [0m
[1m        # Set up variables needed for resolve_redirects and dispatching of[0m
[1m        # hooks[0m
[1m        allow_redirects = kwargs.pop('allow_redirects', True)[0m
[1m        stream = kwargs.get('stream')[0m
[1m        timeout = kwargs.get('timeout')[0m
[1m        verify = kwargs.get('verify')[0m
[1m        cert = kwargs.get('cert')[0m
[1m        proxies = kwargs.get('proxies')[0m
[1m        hooks = request.hooks[0m
[1m    [0m
[1m        # Get the appropriate adapter to use[0m
[1m        adapter = self.get_adapter(url=request.url)[0m
[1m    [0m
[1m        # Start time (approximately) of the request[0m
[1m        start = datetime.utcnow()[0m
[1m        # Send the request[0m
[1m>       r = adapter.send(request, **kwargs)[0m

requests/sessions.py:460: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.adapters.HTTPAdapter object at 0x268fd50>
request = <PreparedRequest [GET]>, stream = False, timeout = None, verify = True
cert = None, proxies = OrderedDict()

[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):[0m
[1m        """Sends PreparedRequest object. Returns Response object.[0m
[1m    [0m
[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.[0m
[1m            :param stream: (optional) Whether to stream the request content.[0m
[1m            :param timeout: (optional) The timeout on the request.[0m
[1m            :param verify: (optional) Whether to verify SSL certificates.[0m
[1m            :param vert: (optional) Any user-provided SSL certificate to be trusted.[0m
[1m            :param proxies: (optional) The proxies dictionary to apply to the request.[0m
[1m            """[0m
[1m    [0m
[1m        conn = self.get_connection(request.url, proxies)[0m
[1m    [0m
[1m        self.cert_verify(conn, request.url, verify, cert)[0m
[1m        url = self.request_url(request, proxies)[0m
[1m        self.add_headers(request)[0m
[1m    [0m
[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)[0m
[1m    [0m
[1m        if stream:[0m
[1m            timeout = Timeout(connect=timeout)[0m
[1m        else:[0m
[1m>           timeout = Timeout(connect=timeout, read=timeout)[0m
[1m[31mE           TypeError: Timeout does not take keyword arguments[0m

requests/adapters.py:305: TypeError
_____________ RequestsTestCase.test_DIGESTAUTH_WRONG_HTTP_401_GET ______________

self = <test_requests.RequestsTestCase testMethod=test_DIGESTAUTH_WRONG_HTTP_401_GET>

[1m    def test_DIGESTAUTH_WRONG_HTTP_401_GET(self):[0m
[1m    [0m
[1m        auth = HTTPDigestAuth('user', 'wrongpass')[0m
[1m        url = httpbin('digest-auth', 'auth', 'user', 'pass')[0m
[1m    [0m
[1m>       r = requests.get(url, auth=auth)[0m

test_requests.py:308: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

url = 'http://httpbin.org/digest-auth/auth/user/pass'
kwargs = {'allow_redirects': True, 'auth': <requests.auth.HTTPDigestAuth object at 0x26a21d0>}

[1m    def get(url, **kwargs):[0m
[1m        """Sends a GET request. Returns :class:`Response` object.[0m
[1m    [0m
[1m        :param url: URL for the new :class:`Request` object.[0m
[1m        :param \*\*kwargs: Optional arguments that ``request`` takes.[0m
[1m        """[0m
[1m    [0m
[1m        kwargs.setdefault('allow_redirects', True)[0m
[1m>       return request('get', url, **kwargs)[0m

requests/api.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

method = 'get', url = 'http://httpbin.org/digest-auth/auth/user/pass'
kwargs = {'allow_redirects': True, 'auth': <requests.auth.HTTPDigestAuth object at 0x26a21d0>}
session = <requests.sessions.Session object at 0x26a2250>

[1m    def request(method, url, **kwargs):[0m
[1m        """Constructs and sends a :class:`Request <Request>`.[0m
[1m        Returns :class:`Response <Response>` object.[0m
[1m    [0m
[1m        :param method: method for the new :class:`Request` object.[0m
[1m        :param url: URL for the new :class:`Request` object.[0m
[1m        :param params: (optional) Dictionary or bytes to be sent in the query string for the :class:`Request`.[0m
[1m        :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.[0m
[1m        :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.[0m
[1m        :param cookies: (optional) Dict or CookieJar object to send with the :class:`Request`.[0m
[1m        :param files: (optional) Dictionary of 'name': file-like-objects (or {'name': ('filename', fileobj)}) for multipart encoding upload.[0m
[1m        :param auth: (optional) Auth tuple to enable Basic/Digest/Custom HTTP Auth.[0m
[1m        :param timeout: (optional) Float describing the timeout of the request.[0m
[1m        :param allow_redirects: (optional) Boolean. Set to True if POST/PUT/DELETE redirect following is allowed.[0m
[1m        :param proxies: (optional) Dictionary mapping protocol to the URL of the proxy.[0m
[1m        :param verify: (optional) if ``True``, the SSL cert will be verified. A CA_BUNDLE path can also be provided.[0m
[1m        :param stream: (optional) if ``False``, the response content will be immediately downloaded.[0m
[1m        :param cert: (optional) if String, path to ssl client cert file (.pem). If Tuple, ('cert', 'key') pair.[0m
[1m    [0m
[1m        Usage::[0m
[1m    [0m
[1m          >>> import requests[0m
[1m          >>> req = requests.request('GET', 'http://httpbin.org/get')[0m
[1m          <Response [200]>[0m
[1m        """[0m
[1m    [0m
[1m        session = sessions.Session()[0m
[1m>       return session.request(method=method, url=url, **kwargs)[0m

requests/api.py:44: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x26a2250>, method = 'get'
url = 'http://httpbin.org/digest-auth/auth/user/pass', params = None
data = None, headers = None, cookies = None, files = None
auth = <requests.auth.HTTPDigestAuth object at 0x26a21d0>, timeout = None
allow_redirects = True, proxies = OrderedDict(), hooks = None, stream = False
verify = True, cert = None

[1m    def request(self, method, url,[0m
[1m        params=None,[0m
[1m        data=None,[0m
[1m        headers=None,[0m
[1m        cookies=None,[0m
[1m        files=None,[0m
[1m        auth=None,[0m
[1m        timeout=None,[0m
[1m        allow_redirects=True,[0m
[1m        proxies=None,[0m
[1m        hooks=None,[0m
[1m        stream=None,[0m
[1m        verify=None,[0m
[1m        cert=None):[0m
[1m        """Constructs a :class:`Request <Request>`, prepares it and sends it.[0m
[1m            Returns :class:`Response <Response>` object.[0m
[1m    [0m
[1m            :param method: method for the new :class:`Request` object.[0m
[1m            :param url: URL for the new :class:`Request` object.[0m
[1m            :param params: (optional) Dictionary or bytes to be sent in the query[0m
[1m                string for the :class:`Request`.[0m
[1m            :param data: (optional) Dictionary or bytes to send in the body of the[0m
[1m                :class:`Request`.[0m
[1m            :param headers: (optional) Dictionary of HTTP Headers to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param cookies: (optional) Dict or CookieJar object to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param files: (optional) Dictionary of 'filename': file-like-objects[0m
[1m                for multipart encoding upload.[0m
[1m            :param auth: (optional) Auth tuple or callable to enable[0m
[1m                Basic/Digest/Custom HTTP Auth.[0m
[1m            :param timeout: (optional) Float describing the timeout of the[0m
[1m                request.[0m
[1m            :param allow_redirects: (optional) Boolean. Set to True by default.[0m
[1m            :param proxies: (optional) Dictionary mapping protocol to the URL of[0m
[1m                the proxy.[0m
[1m            :param stream: (optional) whether to immediately download the response[0m
[1m                content. Defaults to ``False``.[0m
[1m            :param verify: (optional) if ``True``, the SSL cert will be verified.[0m
[1m                A CA_BUNDLE path can also be provided.[0m
[1m            :param cert: (optional) if String, path to ssl client cert file (.pem).[0m
[1m                If Tuple, ('cert', 'key') pair.[0m
[1m            """[0m
[1m        # Create the Request.[0m
[1m        req = Request([0m
[1m            method = method.upper(),[0m
[1m            url = url,[0m
[1m            headers = headers,[0m
[1m            files = files,[0m
[1m            data = data or {},[0m
[1m            params = params or {},[0m
[1m            auth = auth,[0m
[1m            cookies = cookies,[0m
[1m            hooks = hooks,[0m
[1m        )[0m
[1m        prep = self.prepare_request(req)[0m
[1m    [0m
[1m        proxies = proxies or {}[0m
[1m    [0m
[1m        # Gather clues from the surrounding environment.[0m
[1m        if self.trust_env:[0m
[1m            # Set environment's proxies.[0m
[1m            env_proxies = get_environ_proxies(url) or {}[0m
[1m            for (k, v) in env_proxies.items():[0m
[1m                proxies.setdefault(k, v)[0m
[1m    [0m
[1m            # Look for configuration.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('REQUESTS_CA_BUNDLE')[0m
[1m    [0m
[1m            # Curl compatibility.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('CURL_CA_BUNDLE')[0m
[1m    [0m
[1m        # Merge all the kwargs.[0m
[1m        proxies = merge_setting(proxies, self.proxies)[0m
[1m        stream = merge_setting(stream, self.stream)[0m
[1m        verify = merge_setting(verify, self.verify)[0m
[1m        cert = merge_setting(cert, self.cert)[0m
[1m    [0m
[1m        # Send the request.[0m
[1m        send_kwargs = {[0m
[1m            'stream': stream,[0m
[1m            'timeout': timeout,[0m
[1m            'verify': verify,[0m
[1m            'cert': cert,[0m
[1m            'proxies': proxies,[0m
[1m            'allow_redirects': allow_redirects,[0m
[1m        }[0m
[1m>       resp = self.send(prep, **send_kwargs)[0m

requests/sessions.py:357: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x26a2250>
request = <PreparedRequest [GET]>
kwargs = {'cert': None, 'proxies': OrderedDict(), 'stream': False, 'timeout': None, ...}
allow_redirects = True, stream = False, timeout = None, verify = True
cert = None, proxies = OrderedDict()
hooks = {'response': [<bound method HTTPDigestAuth.handle_401 of <requests.auth.HTTPDigestAuth object at 0x26a21d0>>]}

[1m    def send(self, request, **kwargs):[0m
[1m        """Send a given PreparedRequest."""[0m
[1m        # Set defaults that the hooks can utilize to ensure they always have[0m
[1m        # the correct parameters to reproduce the previous request.[0m
[1m        kwargs.setdefault('stream', self.stream)[0m
[1m        kwargs.setdefault('verify', self.verify)[0m
[1m        kwargs.setdefault('cert', self.cert)[0m
[1m        kwargs.setdefault('proxies', self.proxies)[0m
[1m    [0m
[1m        # It's possible that users might accidentally send a Request object.[0m
[1m        # Guard against that specific failure case.[0m
[1m        if not isinstance(request, PreparedRequest):[0m
[1m            raise ValueError('You can only send PreparedRequests.')[0m
[1m    [0m
[1m        # Set up variables needed for resolve_redirects and dispatching of[0m
[1m        # hooks[0m
[1m        allow_redirects = kwargs.pop('allow_redirects', True)[0m
[1m        stream = kwargs.get('stream')[0m
[1m        timeout = kwargs.get('timeout')[0m
[1m        verify = kwargs.get('verify')[0m
[1m        cert = kwargs.get('cert')[0m
[1m        proxies = kwargs.get('proxies')[0m
[1m        hooks = request.hooks[0m
[1m    [0m
[1m        # Get the appropriate adapter to use[0m
[1m        adapter = self.get_adapter(url=request.url)[0m
[1m    [0m
[1m        # Start time (approximately) of the request[0m
[1m        start = datetime.utcnow()[0m
[1m        # Send the request[0m
[1m>       r = adapter.send(request, **kwargs)[0m

requests/sessions.py:460: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.adapters.HTTPAdapter object at 0x26a2950>
request = <PreparedRequest [GET]>, stream = False, timeout = None, verify = True
cert = None, proxies = OrderedDict()

[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):[0m
[1m        """Sends PreparedRequest object. Returns Response object.[0m
[1m    [0m
[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.[0m
[1m            :param stream: (optional) Whether to stream the request content.[0m
[1m            :param timeout: (optional) The timeout on the request.[0m
[1m            :param verify: (optional) Whether to verify SSL certificates.[0m
[1m            :param vert: (optional) Any user-provided SSL certificate to be trusted.[0m
[1m            :param proxies: (optional) The proxies dictionary to apply to the request.[0m
[1m            """[0m
[1m    [0m
[1m        conn = self.get_connection(request.url, proxies)[0m
[1m    [0m
[1m        self.cert_verify(conn, request.url, verify, cert)[0m
[1m        url = self.request_url(request, proxies)[0m
[1m        self.add_headers(request)[0m
[1m    [0m
[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)[0m
[1m    [0m
[1m        if stream:[0m
[1m            timeout = Timeout(connect=timeout)[0m
[1m        else:[0m
[1m>           timeout = Timeout(connect=timeout, read=timeout)[0m
[1m[31mE           TypeError: Timeout does not take keyword arguments[0m

requests/adapters.py:305: TypeError
_______________ RequestsTestCase.test_DIGEST_AUTH_RETURNS_COOKIE _______________

self = <test_requests.RequestsTestCase testMethod=test_DIGEST_AUTH_RETURNS_COOKIE>

[1m    def test_DIGEST_AUTH_RETURNS_COOKIE(self):[0m
[1m        url = httpbin('digest-auth', 'auth', 'user', 'pass')[0m
[1m        auth = HTTPDigestAuth('user', 'pass')[0m
[1m>       r = requests.get(url)[0m

test_requests.py:278: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

url = 'http://httpbin.org/digest-auth/auth/user/pass'
kwargs = {'allow_redirects': True}

[1m    def get(url, **kwargs):[0m
[1m        """Sends a GET request. Returns :class:`Response` object.[0m
[1m    [0m
[1m        :param url: URL for the new :class:`Request` object.[0m
[1m        :param \*\*kwargs: Optional arguments that ``request`` takes.[0m
[1m        """[0m
[1m    [0m
[1m        kwargs.setdefault('allow_redirects', True)[0m
[1m>       return request('get', url, **kwargs)[0m

requests/api.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

method = 'get', url = 'http://httpbin.org/digest-auth/auth/user/pass'
kwargs = {'allow_redirects': True}
session = <requests.sessions.Session object at 0x275c050>

[1m    def request(method, url, **kwargs):[0m
[1m        """Constructs and sends a :class:`Request <Request>`.[0m
[1m        Returns :class:`Response <Response>` object.[0m
[1m    [0m
[1m        :param method: method for the new :class:`Request` object.[0m
[1m        :param url: URL for the new :class:`Request` object.[0m
[1m        :param params: (optional) Dictionary or bytes to be sent in the query string for the :class:`Request`.[0m
[1m        :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.[0m
[1m        :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.[0m
[1m        :param cookies: (optional) Dict or CookieJar object to send with the :class:`Request`.[0m
[1m        :param files: (optional) Dictionary of 'name': file-like-objects (or {'name': ('filename', fileobj)}) for multipart encoding upload.[0m
[1m        :param auth: (optional) Auth tuple to enable Basic/Digest/Custom HTTP Auth.[0m
[1m        :param timeout: (optional) Float describing the timeout of the request.[0m
[1m        :param allow_redirects: (optional) Boolean. Set to True if POST/PUT/DELETE redirect following is allowed.[0m
[1m        :param proxies: (optional) Dictionary mapping protocol to the URL of the proxy.[0m
[1m        :param verify: (optional) if ``True``, the SSL cert will be verified. A CA_BUNDLE path can also be provided.[0m
[1m        :param stream: (optional) if ``False``, the response content will be immediately downloaded.[0m
[1m        :param cert: (optional) if String, path to ssl client cert file (.pem). If Tuple, ('cert', 'key') pair.[0m
[1m    [0m
[1m        Usage::[0m
[1m    [0m
[1m          >>> import requests[0m
[1m          >>> req = requests.request('GET', 'http://httpbin.org/get')[0m
[1m          <Response [200]>[0m
[1m        """[0m
[1m    [0m
[1m        session = sessions.Session()[0m
[1m>       return session.request(method=method, url=url, **kwargs)[0m

requests/api.py:44: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x275c050>, method = 'get'
url = 'http://httpbin.org/digest-auth/auth/user/pass', params = None
data = None, headers = None, cookies = None, files = None, auth = None
timeout = None, allow_redirects = True, proxies = OrderedDict(), hooks = None
stream = False, verify = True, cert = None

[1m    def request(self, method, url,[0m
[1m        params=None,[0m
[1m        data=None,[0m
[1m        headers=None,[0m
[1m        cookies=None,[0m
[1m        files=None,[0m
[1m        auth=None,[0m
[1m        timeout=None,[0m
[1m        allow_redirects=True,[0m
[1m        proxies=None,[0m
[1m        hooks=None,[0m
[1m        stream=None,[0m
[1m        verify=None,[0m
[1m        cert=None):[0m
[1m        """Constructs a :class:`Request <Request>`, prepares it and sends it.[0m
[1m            Returns :class:`Response <Response>` object.[0m
[1m    [0m
[1m            :param method: method for the new :class:`Request` object.[0m
[1m            :param url: URL for the new :class:`Request` object.[0m
[1m            :param params: (optional) Dictionary or bytes to be sent in the query[0m
[1m                string for the :class:`Request`.[0m
[1m            :param data: (optional) Dictionary or bytes to send in the body of the[0m
[1m                :class:`Request`.[0m
[1m            :param headers: (optional) Dictionary of HTTP Headers to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param cookies: (optional) Dict or CookieJar object to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param files: (optional) Dictionary of 'filename': file-like-objects[0m
[1m                for multipart encoding upload.[0m
[1m            :param auth: (optional) Auth tuple or callable to enable[0m
[1m                Basic/Digest/Custom HTTP Auth.[0m
[1m            :param timeout: (optional) Float describing the timeout of the[0m
[1m                request.[0m
[1m            :param allow_redirects: (optional) Boolean. Set to True by default.[0m
[1m            :param proxies: (optional) Dictionary mapping protocol to the URL of[0m
[1m                the proxy.[0m
[1m            :param stream: (optional) whether to immediately download the response[0m
[1m                content. Defaults to ``False``.[0m
[1m            :param verify: (optional) if ``True``, the SSL cert will be verified.[0m
[1m                A CA_BUNDLE path can also be provided.[0m
[1m            :param cert: (optional) if String, path to ssl client cert file (.pem).[0m
[1m                If Tuple, ('cert', 'key') pair.[0m
[1m            """[0m
[1m        # Create the Request.[0m
[1m        req = Request([0m
[1m            method = method.upper(),[0m
[1m            url = url,[0m
[1m            headers = headers,[0m
[1m            files = files,[0m
[1m            data = data or {},[0m
[1m            params = params or {},[0m
[1m            auth = auth,[0m
[1m            cookies = cookies,[0m
[1m            hooks = hooks,[0m
[1m        )[0m
[1m        prep = self.prepare_request(req)[0m
[1m    [0m
[1m        proxies = proxies or {}[0m
[1m    [0m
[1m        # Gather clues from the surrounding environment.[0m
[1m        if self.trust_env:[0m
[1m            # Set environment's proxies.[0m
[1m            env_proxies = get_environ_proxies(url) or {}[0m
[1m            for (k, v) in env_proxies.items():[0m
[1m                proxies.setdefault(k, v)[0m
[1m    [0m
[1m            # Look for configuration.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('REQUESTS_CA_BUNDLE')[0m
[1m    [0m
[1m            # Curl compatibility.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('CURL_CA_BUNDLE')[0m
[1m    [0m
[1m        # Merge all the kwargs.[0m
[1m        proxies = merge_setting(proxies, self.proxies)[0m
[1m        stream = merge_setting(stream, self.stream)[0m
[1m        verify = merge_setting(verify, self.verify)[0m
[1m        cert = merge_setting(cert, self.cert)[0m
[1m    [0m
[1m        # Send the request.[0m
[1m        send_kwargs = {[0m
[1m            'stream': stream,[0m
[1m            'timeout': timeout,[0m
[1m            'verify': verify,[0m
[1m            'cert': cert,[0m
[1m            'proxies': proxies,[0m
[1m            'allow_redirects': allow_redirects,[0m
[1m        }[0m
[1m>       resp = self.send(prep, **send_kwargs)[0m

requests/sessions.py:357: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x275c050>
request = <PreparedRequest [GET]>
kwargs = {'cert': None, 'proxies': OrderedDict(), 'stream': False, 'timeout': None, ...}
allow_redirects = True, stream = False, timeout = None, verify = True
cert = None, proxies = OrderedDict(), hooks = {'response': []}

[1m    def send(self, request, **kwargs):[0m
[1m        """Send a given PreparedRequest."""[0m
[1m        # Set defaults that the hooks can utilize to ensure they always have[0m
[1m        # the correct parameters to reproduce the previous request.[0m
[1m        kwargs.setdefault('stream', self.stream)[0m
[1m        kwargs.setdefault('verify', self.verify)[0m
[1m        kwargs.setdefault('cert', self.cert)[0m
[1m        kwargs.setdefault('proxies', self.proxies)[0m
[1m    [0m
[1m        # It's possible that users might accidentally send a Request object.[0m
[1m        # Guard against that specific failure case.[0m
[1m        if not isinstance(request, PreparedRequest):[0m
[1m            raise ValueError('You can only send PreparedRequests.')[0m
[1m    [0m
[1m        # Set up variables needed for resolve_redirects and dispatching of[0m
[1m        # hooks[0m
[1m        allow_redirects = kwargs.pop('allow_redirects', True)[0m
[1m        stream = kwargs.get('stream')[0m
[1m        timeout = kwargs.get('timeout')[0m
[1m        verify = kwargs.get('verify')[0m
[1m        cert = kwargs.get('cert')[0m
[1m        proxies = kwargs.get('proxies')[0m
[1m        hooks = request.hooks[0m
[1m    [0m
[1m        # Get the appropriate adapter to use[0m
[1m        adapter = self.get_adapter(url=request.url)[0m
[1m    [0m
[1m        # Start time (approximately) of the request[0m
[1m        start = datetime.utcnow()[0m
[1m        # Send the request[0m
[1m>       r = adapter.send(request, **kwargs)[0m

requests/sessions.py:460: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.adapters.HTTPAdapter object at 0x275c8d0>
request = <PreparedRequest [GET]>, stream = False, timeout = None, verify = True
cert = None, proxies = OrderedDict()

[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):[0m
[1m        """Sends PreparedRequest object. Returns Response object.[0m
[1m    [0m
[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.[0m
[1m            :param stream: (optional) Whether to stream the request content.[0m
[1m            :param timeout: (optional) The timeout on the request.[0m
[1m            :param verify: (optional) Whether to verify SSL certificates.[0m
[1m            :param vert: (optional) Any user-provided SSL certificate to be trusted.[0m
[1m            :param proxies: (optional) The proxies dictionary to apply to the request.[0m
[1m            """[0m
[1m    [0m
[1m        conn = self.get_connection(request.url, proxies)[0m
[1m    [0m
[1m        self.cert_verify(conn, request.url, verify, cert)[0m
[1m        url = self.request_url(request, proxies)[0m
[1m        self.add_headers(request)[0m
[1m    [0m
[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)[0m
[1m    [0m
[1m        if stream:[0m
[1m            timeout = Timeout(connect=timeout)[0m
[1m        else:[0m
[1m>           timeout = Timeout(connect=timeout, read=timeout)[0m
[1m[31mE           TypeError: Timeout does not take keyword arguments[0m

requests/adapters.py:305: TypeError
____________ RequestsTestCase.test_DIGEST_AUTH_SETS_SESSION_COOKIES ____________

self = <test_requests.RequestsTestCase testMethod=test_DIGEST_AUTH_SETS_SESSION_COOKIES>

[1m    def test_DIGEST_AUTH_SETS_SESSION_COOKIES(self):[0m
[1m        url = httpbin('digest-auth', 'auth', 'user', 'pass')[0m
[1m        auth = HTTPDigestAuth('user', 'pass')[0m
[1m        s = requests.Session()[0m
[1m>       s.get(url, auth=auth)[0m

test_requests.py:288: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x275c490>
url = 'http://httpbin.org/digest-auth/auth/user/pass'
kwargs = {'allow_redirects': True, 'auth': <requests.auth.HTTPDigestAuth object at 0x275c3d0>}

[1m    def get(self, url, **kwargs):[0m
[1m        """Sends a GET request. Returns :class:`Response` object.[0m
[1m    [0m
[1m            :param url: URL for the new :class:`Request` object.[0m
[1m            :param \*\*kwargs: Optional arguments that ``request`` takes.[0m
[1m            """[0m
[1m    [0m
[1m        kwargs.setdefault('allow_redirects', True)[0m
[1m>       return self.request('GET', url, **kwargs)[0m

requests/sessions.py:369: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x275c490>, method = 'GET'
url = 'http://httpbin.org/digest-auth/auth/user/pass', params = None
data = None, headers = None, cookies = None, files = None
auth = <requests.auth.HTTPDigestAuth object at 0x275c3d0>, timeout = None
allow_redirects = True, proxies = OrderedDict(), hooks = None, stream = False
verify = True, cert = None

[1m    def request(self, method, url,[0m
[1m        params=None,[0m
[1m        data=None,[0m
[1m        headers=None,[0m
[1m        cookies=None,[0m
[1m        files=None,[0m
[1m        auth=None,[0m
[1m        timeout=None,[0m
[1m        allow_redirects=True,[0m
[1m        proxies=None,[0m
[1m        hooks=None,[0m
[1m        stream=None,[0m
[1m        verify=None,[0m
[1m        cert=None):[0m
[1m        """Constructs a :class:`Request <Request>`, prepares it and sends it.[0m
[1m            Returns :class:`Response <Response>` object.[0m
[1m    [0m
[1m            :param method: method for the new :class:`Request` object.[0m
[1m            :param url: URL for the new :class:`Request` object.[0m
[1m            :param params: (optional) Dictionary or bytes to be sent in the query[0m
[1m                string for the :class:`Request`.[0m
[1m            :param data: (optional) Dictionary or bytes to send in the body of the[0m
[1m                :class:`Request`.[0m
[1m            :param headers: (optional) Dictionary of HTTP Headers to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param cookies: (optional) Dict or CookieJar object to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param files: (optional) Dictionary of 'filename': file-like-objects[0m
[1m                for multipart encoding upload.[0m
[1m            :param auth: (optional) Auth tuple or callable to enable[0m
[1m                Basic/Digest/Custom HTTP Auth.[0m
[1m            :param timeout: (optional) Float describing the timeout of the[0m
[1m                request.[0m
[1m            :param allow_redirects: (optional) Boolean. Set to True by default.[0m
[1m            :param proxies: (optional) Dictionary mapping protocol to the URL of[0m
[1m                the proxy.[0m
[1m            :param stream: (optional) whether to immediately download the response[0m
[1m                content. Defaults to ``False``.[0m
[1m            :param verify: (optional) if ``True``, the SSL cert will be verified.[0m
[1m                A CA_BUNDLE path can also be provided.[0m
[1m            :param cert: (optional) if String, path to ssl client cert file (.pem).[0m
[1m                If Tuple, ('cert', 'key') pair.[0m
[1m            """[0m
[1m        # Create the Request.[0m
[1m        req = Request([0m
[1m            method = method.upper(),[0m
[1m            url = url,[0m
[1m            headers = headers,[0m
[1m            files = files,[0m
[1m            data = data or {},[0m
[1m            params = params or {},[0m
[1m            auth = auth,[0m
[1m            cookies = cookies,[0m
[1m            hooks = hooks,[0m
[1m        )[0m
[1m        prep = self.prepare_request(req)[0m
[1m    [0m
[1m        proxies = proxies or {}[0m
[1m    [0m
[1m        # Gather clues from the surrounding environment.[0m
[1m        if self.trust_env:[0m
[1m            # Set environment's proxies.[0m
[1m            env_proxies = get_environ_proxies(url) or {}[0m
[1m            for (k, v) in env_proxies.items():[0m
[1m                proxies.setdefault(k, v)[0m
[1m    [0m
[1m            # Look for configuration.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('REQUESTS_CA_BUNDLE')[0m
[1m    [0m
[1m            # Curl compatibility.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('CURL_CA_BUNDLE')[0m
[1m    [0m
[1m        # Merge all the kwargs.[0m
[1m        proxies = merge_setting(proxies, self.proxies)[0m
[1m        stream = merge_setting(stream, self.stream)[0m
[1m        verify = merge_setting(verify, self.verify)[0m
[1m        cert = merge_setting(cert, self.cert)[0m
[1m    [0m
[1m        # Send the request.[0m
[1m        send_kwargs = {[0m
[1m            'stream': stream,[0m
[1m            'timeout': timeout,[0m
[1m            'verify': verify,[0m
[1m            'cert': cert,[0m
[1m            'proxies': proxies,[0m
[1m            'allow_redirects': allow_redirects,[0m
[1m        }[0m
[1m>       resp = self.send(prep, **send_kwargs)[0m

requests/sessions.py:357: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x275c490>
request = <PreparedRequest [GET]>
kwargs = {'cert': None, 'proxies': OrderedDict(), 'stream': False, 'timeout': None, ...}
allow_redirects = True, stream = False, timeout = None, verify = True
cert = None, proxies = OrderedDict()
hooks = {'response': [<bound method HTTPDigestAuth.handle_401 of <requests.auth.HTTPDigestAuth object at 0x275c3d0>>]}

[1m    def send(self, request, **kwargs):[0m
[1m        """Send a given PreparedRequest."""[0m
[1m        # Set defaults that the hooks can utilize to ensure they always have[0m
[1m        # the correct parameters to reproduce the previous request.[0m
[1m        kwargs.setdefault('stream', self.stream)[0m
[1m        kwargs.setdefault('verify', self.verify)[0m
[1m        kwargs.setdefault('cert', self.cert)[0m
[1m        kwargs.setdefault('proxies', self.proxies)[0m
[1m    [0m
[1m        # It's possible that users might accidentally send a Request object.[0m
[1m        # Guard against that specific failure case.[0m
[1m        if not isinstance(request, PreparedRequest):[0m
[1m            raise ValueError('You can only send PreparedRequests.')[0m
[1m    [0m
[1m        # Set up variables needed for resolve_redirects and dispatching of[0m
[1m        # hooks[0m
[1m        allow_redirects = kwargs.pop('allow_redirects', True)[0m
[1m        stream = kwargs.get('stream')[0m
[1m        timeout = kwargs.get('timeout')[0m
[1m        verify = kwargs.get('verify')[0m
[1m        cert = kwargs.get('cert')[0m
[1m        proxies = kwargs.get('proxies')[0m
[1m        hooks = request.hooks[0m
[1m    [0m
[1m        # Get the appropriate adapter to use[0m
[1m        adapter = self.get_adapter(url=request.url)[0m
[1m    [0m
[1m        # Start time (approximately) of the request[0m
[1m        start = datetime.utcnow()[0m
[1m        # Send the request[0m
[1m>       r = adapter.send(request, **kwargs)[0m

requests/sessions.py:460: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.adapters.HTTPAdapter object at 0x2670d10>
request = <PreparedRequest [GET]>, stream = False, timeout = None, verify = True
cert = None, proxies = OrderedDict()

[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):[0m
[1m        """Sends PreparedRequest object. Returns Response object.[0m
[1m    [0m
[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.[0m
[1m            :param stream: (optional) Whether to stream the request content.[0m
[1m            :param timeout: (optional) The timeout on the request.[0m
[1m            :param verify: (optional) Whether to verify SSL certificates.[0m
[1m            :param vert: (optional) Any user-provided SSL certificate to be trusted.[0m
[1m            :param proxies: (optional) The proxies dictionary to apply to the request.[0m
[1m            """[0m
[1m    [0m
[1m        conn = self.get_connection(request.url, proxies)[0m
[1m    [0m
[1m        self.cert_verify(conn, request.url, verify, cert)[0m
[1m        url = self.request_url(request, proxies)[0m
[1m        self.add_headers(request)[0m
[1m    [0m
[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)[0m
[1m    [0m
[1m        if stream:[0m
[1m            timeout = Timeout(connect=timeout)[0m
[1m        else:[0m
[1m>           timeout = Timeout(connect=timeout, read=timeout)[0m
[1m[31mE           TypeError: Timeout does not take keyword arguments[0m

requests/adapters.py:305: TypeError
_________________ RequestsTestCase.test_DIGEST_HTTP_200_OK_GET _________________

self = <test_requests.RequestsTestCase testMethod=test_DIGEST_HTTP_200_OK_GET>

[1m    def test_DIGEST_HTTP_200_OK_GET(self):[0m
[1m    [0m
[1m        auth = HTTPDigestAuth('user', 'pass')[0m
[1m        url = httpbin('digest-auth', 'auth', 'user', 'pass')[0m
[1m    [0m
[1m>       r = requests.get(url, auth=auth)[0m

test_requests.py:264: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

url = 'http://httpbin.org/digest-auth/auth/user/pass'
kwargs = {'allow_redirects': True, 'auth': <requests.auth.HTTPDigestAuth object at 0x276ba10>}

[1m    def get(url, **kwargs):[0m
[1m        """Sends a GET request. Returns :class:`Response` object.[0m
[1m    [0m
[1m        :param url: URL for the new :class:`Request` object.[0m
[1m        :param \*\*kwargs: Optional arguments that ``request`` takes.[0m
[1m        """[0m
[1m    [0m
[1m        kwargs.setdefault('allow_redirects', True)[0m
[1m>       return request('get', url, **kwargs)[0m

requests/api.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

method = 'get', url = 'http://httpbin.org/digest-auth/auth/user/pass'
kwargs = {'allow_redirects': True, 'auth': <requests.auth.HTTPDigestAuth object at 0x276ba10>}
session = <requests.sessions.Session object at 0x276ba90>

[1m    def request(method, url, **kwargs):[0m
[1m        """Constructs and sends a :class:`Request <Request>`.[0m
[1m        Returns :class:`Response <Response>` object.[0m
[1m    [0m
[1m        :param method: method for the new :class:`Request` object.[0m
[1m        :param url: URL for the new :class:`Request` object.[0m
[1m        :param params: (optional) Dictionary or bytes to be sent in the query string for the :class:`Request`.[0m
[1m        :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.[0m
[1m        :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.[0m
[1m        :param cookies: (optional) Dict or CookieJar object to send with the :class:`Request`.[0m
[1m        :param files: (optional) Dictionary of 'name': file-like-objects (or {'name': ('filename', fileobj)}) for multipart encoding upload.[0m
[1m        :param auth: (optional) Auth tuple to enable Basic/Digest/Custom HTTP Auth.[0m
[1m        :param timeout: (optional) Float describing the timeout of the request.[0m
[1m        :param allow_redirects: (optional) Boolean. Set to True if POST/PUT/DELETE redirect following is allowed.[0m
[1m        :param proxies: (optional) Dictionary mapping protocol to the URL of the proxy.[0m
[1m        :param verify: (optional) if ``True``, the SSL cert will be verified. A CA_BUNDLE path can also be provided.[0m
[1m        :param stream: (optional) if ``False``, the response content will be immediately downloaded.[0m
[1m        :param cert: (optional) if String, path to ssl client cert file (.pem). If Tuple, ('cert', 'key') pair.[0m
[1m    [0m
[1m        Usage::[0m
[1m    [0m
[1m          >>> import requests[0m
[1m          >>> req = requests.request('GET', 'http://httpbin.org/get')[0m
[1m          <Response [200]>[0m
[1m        """[0m
[1m    [0m
[1m        session = sessions.Session()[0m
[1m>       return session.request(method=method, url=url, **kwargs)[0m

requests/api.py:44: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x276ba90>, method = 'get'
url = 'http://httpbin.org/digest-auth/auth/user/pass', params = None
data = None, headers = None, cookies = None, files = None
auth = <requests.auth.HTTPDigestAuth object at 0x276ba10>, timeout = None
allow_redirects = True, proxies = OrderedDict(), hooks = None, stream = False
verify = True, cert = None

[1m    def request(self, method, url,[0m
[1m        params=None,[0m
[1m        data=None,[0m
[1m        headers=None,[0m
[1m        cookies=None,[0m
[1m        files=None,[0m
[1m        auth=None,[0m
[1m        timeout=None,[0m
[1m        allow_redirects=True,[0m
[1m        proxies=None,[0m
[1m        hooks=None,[0m
[1m        stream=None,[0m
[1m        verify=None,[0m
[1m        cert=None):[0m
[1m        """Constructs a :class:`Request <Request>`, prepares it and sends it.[0m
[1m            Returns :class:`Response <Response>` object.[0m
[1m    [0m
[1m            :param method: method for the new :class:`Request` object.[0m
[1m            :param url: URL for the new :class:`Request` object.[0m
[1m            :param params: (optional) Dictionary or bytes to be sent in the query[0m
[1m                string for the :class:`Request`.[0m
[1m            :param data: (optional) Dictionary or bytes to send in the body of the[0m
[1m                :class:`Request`.[0m
[1m            :param headers: (optional) Dictionary of HTTP Headers to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param cookies: (optional) Dict or CookieJar object to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param files: (optional) Dictionary of 'filename': file-like-objects[0m
[1m                for multipart encoding upload.[0m
[1m            :param auth: (optional) Auth tuple or callable to enable[0m
[1m                Basic/Digest/Custom HTTP Auth.[0m
[1m            :param timeout: (optional) Float describing the timeout of the[0m
[1m                request.[0m
[1m            :param allow_redirects: (optional) Boolean. Set to True by default.[0m
[1m            :param proxies: (optional) Dictionary mapping protocol to the URL of[0m
[1m                the proxy.[0m
[1m            :param stream: (optional) whether to immediately download the response[0m
[1m                content. Defaults to ``False``.[0m
[1m            :param verify: (optional) if ``True``, the SSL cert will be verified.[0m
[1m                A CA_BUNDLE path can also be provided.[0m
[1m            :param cert: (optional) if String, path to ssl client cert file (.pem).[0m
[1m                If Tuple, ('cert', 'key') pair.[0m
[1m            """[0m
[1m        # Create the Request.[0m
[1m        req = Request([0m
[1m            method = method.upper(),[0m
[1m            url = url,[0m
[1m            headers = headers,[0m
[1m            files = files,[0m
[1m            data = data or {},[0m
[1m            params = params or {},[0m
[1m            auth = auth,[0m
[1m            cookies = cookies,[0m
[1m            hooks = hooks,[0m
[1m        )[0m
[1m        prep = self.prepare_request(req)[0m
[1m    [0m
[1m        proxies = proxies or {}[0m
[1m    [0m
[1m        # Gather clues from the surrounding environment.[0m
[1m        if self.trust_env:[0m
[1m            # Set environment's proxies.[0m
[1m            env_proxies = get_environ_proxies(url) or {}[0m
[1m            for (k, v) in env_proxies.items():[0m
[1m                proxies.setdefault(k, v)[0m
[1m    [0m
[1m            # Look for configuration.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('REQUESTS_CA_BUNDLE')[0m
[1m    [0m
[1m            # Curl compatibility.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('CURL_CA_BUNDLE')[0m
[1m    [0m
[1m        # Merge all the kwargs.[0m
[1m        proxies = merge_setting(proxies, self.proxies)[0m
[1m        stream = merge_setting(stream, self.stream)[0m
[1m        verify = merge_setting(verify, self.verify)[0m
[1m        cert = merge_setting(cert, self.cert)[0m
[1m    [0m
[1m        # Send the request.[0m
[1m        send_kwargs = {[0m
[1m            'stream': stream,[0m
[1m            'timeout': timeout,[0m
[1m            'verify': verify,[0m
[1m            'cert': cert,[0m
[1m            'proxies': proxies,[0m
[1m            'allow_redirects': allow_redirects,[0m
[1m        }[0m
[1m>       resp = self.send(prep, **send_kwargs)[0m

requests/sessions.py:357: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x276ba90>
request = <PreparedRequest [GET]>
kwargs = {'cert': None, 'proxies': OrderedDict(), 'stream': False, 'timeout': None, ...}
allow_redirects = True, stream = False, timeout = None, verify = True
cert = None, proxies = OrderedDict()
hooks = {'response': [<bound method HTTPDigestAuth.handle_401 of <requests.auth.HTTPDigestAuth object at 0x276ba10>>]}

[1m    def send(self, request, **kwargs):[0m
[1m        """Send a given PreparedRequest."""[0m
[1m        # Set defaults that the hooks can utilize to ensure they always have[0m
[1m        # the correct parameters to reproduce the previous request.[0m
[1m        kwargs.setdefault('stream', self.stream)[0m
[1m        kwargs.setdefault('verify', self.verify)[0m
[1m        kwargs.setdefault('cert', self.cert)[0m
[1m        kwargs.setdefault('proxies', self.proxies)[0m
[1m    [0m
[1m        # It's possible that users might accidentally send a Request object.[0m
[1m        # Guard against that specific failure case.[0m
[1m        if not isinstance(request, PreparedRequest):[0m
[1m            raise ValueError('You can only send PreparedRequests.')[0m
[1m    [0m
[1m        # Set up variables needed for resolve_redirects and dispatching of[0m
[1m        # hooks[0m
[1m        allow_redirects = kwargs.pop('allow_redirects', True)[0m
[1m        stream = kwargs.get('stream')[0m
[1m        timeout = kwargs.get('timeout')[0m
[1m        verify = kwargs.get('verify')[0m
[1m        cert = kwargs.get('cert')[0m
[1m        proxies = kwargs.get('proxies')[0m
[1m        hooks = request.hooks[0m
[1m    [0m
[1m        # Get the appropriate adapter to use[0m
[1m        adapter = self.get_adapter(url=request.url)[0m
[1m    [0m
[1m        # Start time (approximately) of the request[0m
[1m        start = datetime.utcnow()[0m
[1m        # Send the request[0m
[1m>       r = adapter.send(request, **kwargs)[0m

requests/sessions.py:460: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.adapters.HTTPAdapter object at 0x276bd50>
request = <PreparedRequest [GET]>, stream = False, timeout = None, verify = True
cert = None, proxies = OrderedDict()

[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):[0m
[1m        """Sends PreparedRequest object. Returns Response object.[0m
[1m    [0m
[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.[0m
[1m            :param stream: (optional) Whether to stream the request content.[0m
[1m            :param timeout: (optional) The timeout on the request.[0m
[1m            :param verify: (optional) Whether to verify SSL certificates.[0m
[1m            :param vert: (optional) Any user-provided SSL certificate to be trusted.[0m
[1m            :param proxies: (optional) The proxies dictionary to apply to the request.[0m
[1m            """[0m
[1m    [0m
[1m        conn = self.get_connection(request.url, proxies)[0m
[1m    [0m
[1m        self.cert_verify(conn, request.url, verify, cert)[0m
[1m        url = self.request_url(request, proxies)[0m
[1m        self.add_headers(request)[0m
[1m    [0m
[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)[0m
[1m    [0m
[1m        if stream:[0m
[1m            timeout = Timeout(connect=timeout)[0m
[1m        else:[0m
[1m>           timeout = Timeout(connect=timeout, read=timeout)[0m
[1m[31mE           TypeError: Timeout does not take keyword arguments[0m

requests/adapters.py:305: TypeError
_____________________ RequestsTestCase.test_DIGEST_STREAM ______________________

self = <test_requests.RequestsTestCase testMethod=test_DIGEST_STREAM>

[1m    def test_DIGEST_STREAM(self):[0m
[1m    [0m
[1m        auth = HTTPDigestAuth('user', 'pass')[0m
[1m        url = httpbin('digest-auth', 'auth', 'user', 'pass')[0m
[1m    [0m
[1m>       r = requests.get(url, auth=auth, stream=True)[0m

test_requests.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

url = 'http://httpbin.org/digest-auth/auth/user/pass'
kwargs = {'allow_redirects': True, 'auth': <requests.auth.HTTPDigestAuth object at 0x2a44190>, 'stream': True}

[1m    def get(url, **kwargs):[0m
[1m        """Sends a GET request. Returns :class:`Response` object.[0m
[1m    [0m
[1m        :param url: URL for the new :class:`Request` object.[0m
[1m        :param \*\*kwargs: Optional arguments that ``request`` takes.[0m
[1m        """[0m
[1m    [0m
[1m        kwargs.setdefault('allow_redirects', True)[0m
[1m>       return request('get', url, **kwargs)[0m

requests/api.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

method = 'get', url = 'http://httpbin.org/digest-auth/auth/user/pass'
kwargs = {'allow_redirects': True, 'auth': <requests.auth.HTTPDigestAuth object at 0x2a44190>, 'stream': True}
session = <requests.sessions.Session object at 0x2a441d0>

[1m    def request(method, url, **kwargs):[0m
[1m        """Constructs and sends a :class:`Request <Request>`.[0m
[1m        Returns :class:`Response <Response>` object.[0m
[1m    [0m
[1m        :param method: method for the new :class:`Request` object.[0m
[1m        :param url: URL for the new :class:`Request` object.[0m
[1m        :param params: (optional) Dictionary or bytes to be sent in the query string for the :class:`Request`.[0m
[1m        :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.[0m
[1m        :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.[0m
[1m        :param cookies: (optional) Dict or CookieJar object to send with the :class:`Request`.[0m
[1m        :param files: (optional) Dictionary of 'name': file-like-objects (or {'name': ('filename', fileobj)}) for multipart encoding upload.[0m
[1m        :param auth: (optional) Auth tuple to enable Basic/Digest/Custom HTTP Auth.[0m
[1m        :param timeout: (optional) Float describing the timeout of the request.[0m
[1m        :param allow_redirects: (optional) Boolean. Set to True if POST/PUT/DELETE redirect following is allowed.[0m
[1m        :param proxies: (optional) Dictionary mapping protocol to the URL of the proxy.[0m
[1m        :param verify: (optional) if ``True``, the SSL cert will be verified. A CA_BUNDLE path can also be provided.[0m
[1m        :param stream: (optional) if ``False``, the response content will be immediately downloaded.[0m
[1m        :param cert: (optional) if String, path to ssl client cert file (.pem). If Tuple, ('cert', 'key') pair.[0m
[1m    [0m
[1m        Usage::[0m
[1m    [0m
[1m          >>> import requests[0m
[1m          >>> req = requests.request('GET', 'http://httpbin.org/get')[0m
[1m          <Response [200]>[0m
[1m        """[0m
[1m    [0m
[1m        session = sessions.Session()[0m
[1m>       return session.request(method=method, url=url, **kwargs)[0m

requests/api.py:44: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x2a441d0>, method = 'get'
url = 'http://httpbin.org/digest-auth/auth/user/pass', params = None
data = None, headers = None, cookies = None, files = None
auth = <requests.auth.HTTPDigestAuth object at 0x2a44190>, timeout = None
allow_redirects = True, proxies = OrderedDict(), hooks = None, stream = True
verify = True, cert = None

[1m    def request(self, method, url,[0m
[1m        params=None,[0m
[1m        data=None,[0m
[1m        headers=None,[0m
[1m        cookies=None,[0m
[1m        files=None,[0m
[1m        auth=None,[0m
[1m        timeout=None,[0m
[1m        allow_redirects=True,[0m
[1m        proxies=None,[0m
[1m        hooks=None,[0m
[1m        stream=None,[0m
[1m        verify=None,[0m
[1m        cert=None):[0m
[1m        """Constructs a :class:`Request <Request>`, prepares it and sends it.[0m
[1m            Returns :class:`Response <Response>` object.[0m
[1m    [0m
[1m            :param method: method for the new :class:`Request` object.[0m
[1m            :param url: URL for the new :class:`Request` object.[0m
[1m            :param params: (optional) Dictionary or bytes to be sent in the query[0m
[1m                string for the :class:`Request`.[0m
[1m            :param data: (optional) Dictionary or bytes to send in the body of the[0m
[1m                :class:`Request`.[0m
[1m            :param headers: (optional) Dictionary of HTTP Headers to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param cookies: (optional) Dict or CookieJar object to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param files: (optional) Dictionary of 'filename': file-like-objects[0m
[1m                for multipart encoding upload.[0m
[1m            :param auth: (optional) Auth tuple or callable to enable[0m
[1m                Basic/Digest/Custom HTTP Auth.[0m
[1m            :param timeout: (optional) Float describing the timeout of the[0m
[1m                request.[0m
[1m            :param allow_redirects: (optional) Boolean. Set to True by default.[0m
[1m            :param proxies: (optional) Dictionary mapping protocol to the URL of[0m
[1m                the proxy.[0m
[1m            :param stream: (optional) whether to immediately download the response[0m
[1m                content. Defaults to ``False``.[0m
[1m            :param verify: (optional) if ``True``, the SSL cert will be verified.[0m
[1m                A CA_BUNDLE path can also be provided.[0m
[1m            :param cert: (optional) if String, path to ssl client cert file (.pem).[0m
[1m                If Tuple, ('cert', 'key') pair.[0m
[1m            """[0m
[1m        # Create the Request.[0m
[1m        req = Request([0m
[1m            method = method.upper(),[0m
[1m            url = url,[0m
[1m            headers = headers,[0m
[1m            files = files,[0m
[1m            data = data or {},[0m
[1m            params = params or {},[0m
[1m            auth = auth,[0m
[1m            cookies = cookies,[0m
[1m            hooks = hooks,[0m
[1m        )[0m
[1m        prep = self.prepare_request(req)[0m
[1m    [0m
[1m        proxies = proxies or {}[0m
[1m    [0m
[1m        # Gather clues from the surrounding environment.[0m
[1m        if self.trust_env:[0m
[1m            # Set environment's proxies.[0m
[1m            env_proxies = get_environ_proxies(url) or {}[0m
[1m            for (k, v) in env_proxies.items():[0m
[1m                proxies.setdefault(k, v)[0m
[1m    [0m
[1m            # Look for configuration.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('REQUESTS_CA_BUNDLE')[0m
[1m    [0m
[1m            # Curl compatibility.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('CURL_CA_BUNDLE')[0m
[1m    [0m
[1m        # Merge all the kwargs.[0m
[1m        proxies = merge_setting(proxies, self.proxies)[0m
[1m        stream = merge_setting(stream, self.stream)[0m
[1m        verify = merge_setting(verify, self.verify)[0m
[1m        cert = merge_setting(cert, self.cert)[0m
[1m    [0m
[1m        # Send the request.[0m
[1m        send_kwargs = {[0m
[1m            'stream': stream,[0m
[1m            'timeout': timeout,[0m
[1m            'verify': verify,[0m
[1m            'cert': cert,[0m
[1m            'proxies': proxies,[0m
[1m            'allow_redirects': allow_redirects,[0m
[1m        }[0m
[1m>       resp = self.send(prep, **send_kwargs)[0m

requests/sessions.py:357: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x2a441d0>
request = <PreparedRequest [GET]>
kwargs = {'cert': None, 'proxies': OrderedDict(), 'stream': True, 'timeout': None, ...}
allow_redirects = True, stream = True, timeout = None, verify = True
cert = None, proxies = OrderedDict()
hooks = {'response': [<bound method HTTPDigestAuth.handle_401 of <requests.auth.HTTPDigestAuth object at 0x2a44190>>]}

[1m    def send(self, request, **kwargs):[0m
[1m        """Send a given PreparedRequest."""[0m
[1m        # Set defaults that the hooks can utilize to ensure they always have[0m
[1m        # the correct parameters to reproduce the previous request.[0m
[1m        kwargs.setdefault('stream', self.stream)[0m
[1m        kwargs.setdefault('verify', self.verify)[0m
[1m        kwargs.setdefault('cert', self.cert)[0m
[1m        kwargs.setdefault('proxies', self.proxies)[0m
[1m    [0m
[1m        # It's possible that users might accidentally send a Request object.[0m
[1m        # Guard against that specific failure case.[0m
[1m        if not isinstance(request, PreparedRequest):[0m
[1m            raise ValueError('You can only send PreparedRequests.')[0m
[1m    [0m
[1m        # Set up variables needed for resolve_redirects and dispatching of[0m
[1m        # hooks[0m
[1m        allow_redirects = kwargs.pop('allow_redirects', True)[0m
[1m        stream = kwargs.get('stream')[0m
[1m        timeout = kwargs.get('timeout')[0m
[1m        verify = kwargs.get('verify')[0m
[1m        cert = kwargs.get('cert')[0m
[1m        proxies = kwargs.get('proxies')[0m
[1m        hooks = request.hooks[0m
[1m    [0m
[1m        # Get the appropriate adapter to use[0m
[1m        adapter = self.get_adapter(url=request.url)[0m
[1m    [0m
[1m        # Start time (approximately) of the request[0m
[1m        start = datetime.utcnow()[0m
[1m        # Send the request[0m
[1m>       r = adapter.send(request, **kwargs)[0m

requests/sessions.py:460: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.adapters.HTTPAdapter object at 0x2a44590>
request = <PreparedRequest [GET]>, stream = True, timeout = None, verify = True
cert = None, proxies = OrderedDict()

[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):[0m
[1m        """Sends PreparedRequest object. Returns Response object.[0m
[1m    [0m
[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.[0m
[1m            :param stream: (optional) Whether to stream the request content.[0m
[1m            :param timeout: (optional) The timeout on the request.[0m
[1m            :param verify: (optional) Whether to verify SSL certificates.[0m
[1m            :param vert: (optional) Any user-provided SSL certificate to be trusted.[0m
[1m            :param proxies: (optional) The proxies dictionary to apply to the request.[0m
[1m            """[0m
[1m    [0m
[1m        conn = self.get_connection(request.url, proxies)[0m
[1m    [0m
[1m        self.cert_verify(conn, request.url, verify, cert)[0m
[1m        url = self.request_url(request, proxies)[0m
[1m        self.add_headers(request)[0m
[1m    [0m
[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)[0m
[1m    [0m
[1m        if stream:[0m
[1m>           timeout = Timeout(connect=timeout)[0m
[1m[31mE           TypeError: Timeout does not take keyword arguments[0m

requests/adapters.py:303: TypeError
______________ RequestsTestCase.test_HTTP_200_OK_GET_ALTERNATIVE _______________

self = <test_requests.RequestsTestCase testMethod=test_HTTP_200_OK_GET_ALTERNATIVE>

[1m    def test_HTTP_200_OK_GET_ALTERNATIVE(self):[0m
[1m        r = requests.Request('GET', httpbin('get'))[0m
[1m        s = requests.Session()[0m
[1m        s.proxies = getproxies()[0m
[1m    [0m
[1m>       r = s.send(r.prepare())[0m

test_requests.py:111: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x2771c90>
request = <PreparedRequest [GET]>
kwargs = {'cert': None, 'proxies': {}, 'stream': False, 'verify': True}
allow_redirects = True, stream = False, timeout = None, verify = True
cert = None, proxies = {}, hooks = {'response': []}

[1m    def send(self, request, **kwargs):[0m
[1m        """Send a given PreparedRequest."""[0m
[1m        # Set defaults that the hooks can utilize to ensure they always have[0m
[1m        # the correct parameters to reproduce the previous request.[0m
[1m        kwargs.setdefault('stream', self.stream)[0m
[1m        kwargs.setdefault('verify', self.verify)[0m
[1m        kwargs.setdefault('cert', self.cert)[0m
[1m        kwargs.setdefault('proxies', self.proxies)[0m
[1m    [0m
[1m        # It's possible that users might accidentally send a Request object.[0m
[1m        # Guard against that specific failure case.[0m
[1m        if not isinstance(request, PreparedRequest):[0m
[1m            raise ValueError('You can only send PreparedRequests.')[0m
[1m    [0m
[1m        # Set up variables needed for resolve_redirects and dispatching of[0m
[1m        # hooks[0m
[1m        allow_redirects = kwargs.pop('allow_redirects', True)[0m
[1m        stream = kwargs.get('stream')[0m
[1m        timeout = kwargs.get('timeout')[0m
[1m        verify = kwargs.get('verify')[0m
[1m        cert = kwargs.get('cert')[0m
[1m        proxies = kwargs.get('proxies')[0m
[1m        hooks = request.hooks[0m
[1m    [0m
[1m        # Get the appropriate adapter to use[0m
[1m        adapter = self.get_adapter(url=request.url)[0m
[1m    [0m
[1m        # Start time (approximately) of the request[0m
[1m        start = datetime.utcnow()[0m
[1m        # Send the request[0m
[1m>       r = adapter.send(request, **kwargs)[0m

requests/sessions.py:460: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.adapters.HTTPAdapter object at 0x2771350>
request = <PreparedRequest [GET]>, stream = False, timeout = None, verify = True
cert = None, proxies = {}

[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):[0m
[1m        """Sends PreparedRequest object. Returns Response object.[0m
[1m    [0m
[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.[0m
[1m            :param stream: (optional) Whether to stream the request content.[0m
[1m            :param timeout: (optional) The timeout on the request.[0m
[1m            :param verify: (optional) Whether to verify SSL certificates.[0m
[1m            :param vert: (optional) Any user-provided SSL certificate to be trusted.[0m
[1m            :param proxies: (optional) The proxies dictionary to apply to the request.[0m
[1m            """[0m
[1m    [0m
[1m        conn = self.get_connection(request.url, proxies)[0m
[1m    [0m
[1m        self.cert_verify(conn, request.url, verify, cert)[0m
[1m        url = self.request_url(request, proxies)[0m
[1m        self.add_headers(request)[0m
[1m    [0m
[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)[0m
[1m    [0m
[1m        if stream:[0m
[1m            timeout = Timeout(connect=timeout)[0m
[1m        else:[0m
[1m>           timeout = Timeout(connect=timeout, read=timeout)[0m
[1m[31mE           TypeError: Timeout does not take keyword arguments[0m

requests/adapters.py:305: TypeError
___________ RequestsTestCase.test_HTTP_200_OK_GET_WITH_MIXED_PARAMS ____________

self = <test_requests.RequestsTestCase testMethod=test_HTTP_200_OK_GET_WITH_MIXED_PARAMS>

[1m    def test_HTTP_200_OK_GET_WITH_MIXED_PARAMS(self):[0m
[1m        heads = {'User-agent': 'Mozilla/5.0'}[0m
[1m    [0m
[1m>       r = requests.get(httpbin('get') + '?test=true', params={'q': 'test'}, headers=heads)[0m

test_requests.py:134: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

url = 'http://httpbin.org/get?test=true'
kwargs = {'allow_redirects': True, 'headers': {'User-agent': 'Mozilla/5.0'}, 'params': {'q': 'test'}}

[1m    def get(url, **kwargs):[0m
[1m        """Sends a GET request. Returns :class:`Response` object.[0m
[1m    [0m
[1m        :param url: URL for the new :class:`Request` object.[0m
[1m        :param \*\*kwargs: Optional arguments that ``request`` takes.[0m
[1m        """[0m
[1m    [0m
[1m        kwargs.setdefault('allow_redirects', True)[0m
[1m>       return request('get', url, **kwargs)[0m

requests/api.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

method = 'get', url = 'http://httpbin.org/get?test=true'
kwargs = {'allow_redirects': True, 'headers': {'User-agent': 'Mozilla/5.0'}, 'params': {'q': 'test'}}
session = <requests.sessions.Session object at 0x268f950>

[1m    def request(method, url, **kwargs):[0m
[1m        """Constructs and sends a :class:`Request <Request>`.[0m
[1m        Returns :class:`Response <Response>` object.[0m
[1m    [0m
[1m        :param method: method for the new :class:`Request` object.[0m
[1m        :param url: URL for the new :class:`Request` object.[0m
[1m        :param params: (optional) Dictionary or bytes to be sent in the query string for the :class:`Request`.[0m
[1m        :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.[0m
[1m        :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.[0m
[1m        :param cookies: (optional) Dict or CookieJar object to send with the :class:`Request`.[0m
[1m        :param files: (optional) Dictionary of 'name': file-like-objects (or {'name': ('filename', fileobj)}) for multipart encoding upload.[0m
[1m        :param auth: (optional) Auth tuple to enable Basic/Digest/Custom HTTP Auth.[0m
[1m        :param timeout: (optional) Float describing the timeout of the request.[0m
[1m        :param allow_redirects: (optional) Boolean. Set to True if POST/PUT/DELETE redirect following is allowed.[0m
[1m        :param proxies: (optional) Dictionary mapping protocol to the URL of the proxy.[0m
[1m        :param verify: (optional) if ``True``, the SSL cert will be verified. A CA_BUNDLE path can also be provided.[0m
[1m        :param stream: (optional) if ``False``, the response content will be immediately downloaded.[0m
[1m        :param cert: (optional) if String, path to ssl client cert file (.pem). If Tuple, ('cert', 'key') pair.[0m
[1m    [0m
[1m        Usage::[0m
[1m    [0m
[1m          >>> import requests[0m
[1m          >>> req = requests.request('GET', 'http://httpbin.org/get')[0m
[1m          <Response [200]>[0m
[1m        """[0m
[1m    [0m
[1m        session = sessions.Session()[0m
[1m>       return session.request(method=method, url=url, **kwargs)[0m

requests/api.py:44: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x268f950>, method = 'get'
url = 'http://httpbin.org/get?test=true', params = {'q': 'test'}, data = None
headers = {'User-agent': 'Mozilla/5.0'}, cookies = None, files = None
auth = None, timeout = None, allow_redirects = True, proxies = OrderedDict()
hooks = None, stream = False, verify = True, cert = None

[1m    def request(self, method, url,[0m
[1m        params=None,[0m
[1m        data=None,[0m
[1m        headers=None,[0m
[1m        cookies=None,[0m
[1m        files=None,[0m
[1m        auth=None,[0m
[1m        timeout=None,[0m
[1m        allow_redirects=True,[0m
[1m        proxies=None,[0m
[1m        hooks=None,[0m
[1m        stream=None,[0m
[1m        verify=None,[0m
[1m        cert=None):[0m
[1m        """Constructs a :class:`Request <Request>`, prepares it and sends it.[0m
[1m            Returns :class:`Response <Response>` object.[0m
[1m    [0m
[1m            :param method: method for the new :class:`Request` object.[0m
[1m            :param url: URL for the new :class:`Request` object.[0m
[1m            :param params: (optional) Dictionary or bytes to be sent in the query[0m
[1m                string for the :class:`Request`.[0m
[1m            :param data: (optional) Dictionary or bytes to send in the body of the[0m
[1m                :class:`Request`.[0m
[1m            :param headers: (optional) Dictionary of HTTP Headers to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param cookies: (optional) Dict or CookieJar object to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param files: (optional) Dictionary of 'filename': file-like-objects[0m
[1m                for multipart encoding upload.[0m
[1m            :param auth: (optional) Auth tuple or callable to enable[0m
[1m                Basic/Digest/Custom HTTP Auth.[0m
[1m            :param timeout: (optional) Float describing the timeout of the[0m
[1m                request.[0m
[1m            :param allow_redirects: (optional) Boolean. Set to True by default.[0m
[1m            :param proxies: (optional) Dictionary mapping protocol to the URL of[0m
[1m                the proxy.[0m
[1m            :param stream: (optional) whether to immediately download the response[0m
[1m                content. Defaults to ``False``.[0m
[1m            :param verify: (optional) if ``True``, the SSL cert will be verified.[0m
[1m                A CA_BUNDLE path can also be provided.[0m
[1m            :param cert: (optional) if String, path to ssl client cert file (.pem).[0m
[1m                If Tuple, ('cert', 'key') pair.[0m
[1m            """[0m
[1m        # Create the Request.[0m
[1m        req = Request([0m
[1m            method = method.upper(),[0m
[1m            url = url,[0m
[1m            headers = headers,[0m
[1m            files = files,[0m
[1m            data = data or {},[0m
[1m            params = params or {},[0m
[1m            auth = auth,[0m
[1m            cookies = cookies,[0m
[1m            hooks = hooks,[0m
[1m        )[0m
[1m        prep = self.prepare_request(req)[0m
[1m    [0m
[1m        proxies = proxies or {}[0m
[1m    [0m
[1m        # Gather clues from the surrounding environment.[0m
[1m        if self.trust_env:[0m
[1m            # Set environment's proxies.[0m
[1m            env_proxies = get_environ_proxies(url) or {}[0m
[1m            for (k, v) in env_proxies.items():[0m
[1m                proxies.setdefault(k, v)[0m
[1m    [0m
[1m            # Look for configuration.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('REQUESTS_CA_BUNDLE')[0m
[1m    [0m
[1m            # Curl compatibility.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('CURL_CA_BUNDLE')[0m
[1m    [0m
[1m        # Merge all the kwargs.[0m
[1m        proxies = merge_setting(proxies, self.proxies)[0m
[1m        stream = merge_setting(stream, self.stream)[0m
[1m        verify = merge_setting(verify, self.verify)[0m
[1m        cert = merge_setting(cert, self.cert)[0m
[1m    [0m
[1m        # Send the request.[0m
[1m        send_kwargs = {[0m
[1m            'stream': stream,[0m
[1m            'timeout': timeout,[0m
[1m            'verify': verify,[0m
[1m            'cert': cert,[0m
[1m            'proxies': proxies,[0m
[1m            'allow_redirects': allow_redirects,[0m
[1m        }[0m
[1m>       resp = self.send(prep, **send_kwargs)[0m

requests/sessions.py:357: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x268f950>
request = <PreparedRequest [GET]>
kwargs = {'cert': None, 'proxies': OrderedDict(), 'stream': False, 'timeout': None, ...}
allow_redirects = True, stream = False, timeout = None, verify = True
cert = None, proxies = OrderedDict(), hooks = {'response': []}

[1m    def send(self, request, **kwargs):[0m
[1m        """Send a given PreparedRequest."""[0m
[1m        # Set defaults that the hooks can utilize to ensure they always have[0m
[1m        # the correct parameters to reproduce the previous request.[0m
[1m        kwargs.setdefault('stream', self.stream)[0m
[1m        kwargs.setdefault('verify', self.verify)[0m
[1m        kwargs.setdefault('cert', self.cert)[0m
[1m        kwargs.setdefault('proxies', self.proxies)[0m
[1m    [0m
[1m        # It's possible that users might accidentally send a Request object.[0m
[1m        # Guard against that specific failure case.[0m
[1m        if not isinstance(request, PreparedRequest):[0m
[1m            raise ValueError('You can only send PreparedRequests.')[0m
[1m    [0m
[1m        # Set up variables needed for resolve_redirects and dispatching of[0m
[1m        # hooks[0m
[1m        allow_redirects = kwargs.pop('allow_redirects', True)[0m
[1m        stream = kwargs.get('stream')[0m
[1m        timeout = kwargs.get('timeout')[0m
[1m        verify = kwargs.get('verify')[0m
[1m        cert = kwargs.get('cert')[0m
[1m        proxies = kwargs.get('proxies')[0m
[1m        hooks = request.hooks[0m
[1m    [0m
[1m        # Get the appropriate adapter to use[0m
[1m        adapter = self.get_adapter(url=request.url)[0m
[1m    [0m
[1m        # Start time (approximately) of the request[0m
[1m        start = datetime.utcnow()[0m
[1m        # Send the request[0m
[1m>       r = adapter.send(request, **kwargs)[0m

requests/sessions.py:460: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.adapters.HTTPAdapter object at 0x276b7d0>
request = <PreparedRequest [GET]>, stream = False, timeout = None, verify = True
cert = None, proxies = OrderedDict()

[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):[0m
[1m        """Sends PreparedRequest object. Returns Response object.[0m
[1m    [0m
[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.[0m
[1m            :param stream: (optional) Whether to stream the request content.[0m
[1m            :param timeout: (optional) The timeout on the request.[0m
[1m            :param verify: (optional) Whether to verify SSL certificates.[0m
[1m            :param vert: (optional) Any user-provided SSL certificate to be trusted.[0m
[1m            :param proxies: (optional) The proxies dictionary to apply to the request.[0m
[1m            """[0m
[1m    [0m
[1m        conn = self.get_connection(request.url, proxies)[0m
[1m    [0m
[1m        self.cert_verify(conn, request.url, verify, cert)[0m
[1m        url = self.request_url(request, proxies)[0m
[1m        self.add_headers(request)[0m
[1m    [0m
[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)[0m
[1m    [0m
[1m        if stream:[0m
[1m            timeout = Timeout(connect=timeout)[0m
[1m        else:[0m
[1m>           timeout = Timeout(connect=timeout, read=timeout)[0m
[1m[31mE           TypeError: Timeout does not take keyword arguments[0m

requests/adapters.py:305: TypeError
______________ RequestsTestCase.test_HTTP_200_OK_GET_WITH_PARAMS _______________

self = <test_requests.RequestsTestCase testMethod=test_HTTP_200_OK_GET_WITH_PARAMS>

[1m    def test_HTTP_200_OK_GET_WITH_PARAMS(self):[0m
[1m        heads = {'User-agent': 'Mozilla/5.0'}[0m
[1m    [0m
[1m>       r = requests.get(httpbin('user-agent'), headers=heads)[0m

test_requests.py:126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

url = 'http://httpbin.org/user-agent'
kwargs = {'allow_redirects': True, 'headers': {'User-agent': 'Mozilla/5.0'}}

[1m    def get(url, **kwargs):[0m
[1m        """Sends a GET request. Returns :class:`Response` object.[0m
[1m    [0m
[1m        :param url: URL for the new :class:`Request` object.[0m
[1m        :param \*\*kwargs: Optional arguments that ``request`` takes.[0m
[1m        """[0m
[1m    [0m
[1m        kwargs.setdefault('allow_redirects', True)[0m
[1m>       return request('get', url, **kwargs)[0m

requests/api.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

method = 'get', url = 'http://httpbin.org/user-agent'
kwargs = {'allow_redirects': True, 'headers': {'User-agent': 'Mozilla/5.0'}}
session = <requests.sessions.Session object at 0x26a8210>

[1m    def request(method, url, **kwargs):[0m
[1m        """Constructs and sends a :class:`Request <Request>`.[0m
[1m        Returns :class:`Response <Response>` object.[0m
[1m    [0m
[1m        :param method: method for the new :class:`Request` object.[0m
[1m        :param url: URL for the new :class:`Request` object.[0m
[1m        :param params: (optional) Dictionary or bytes to be sent in the query string for the :class:`Request`.[0m
[1m        :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.[0m
[1m        :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.[0m
[1m        :param cookies: (optional) Dict or CookieJar object to send with the :class:`Request`.[0m
[1m        :param files: (optional) Dictionary of 'name': file-like-objects (or {'name': ('filename', fileobj)}) for multipart encoding upload.[0m
[1m        :param auth: (optional) Auth tuple to enable Basic/Digest/Custom HTTP Auth.[0m
[1m        :param timeout: (optional) Float describing the timeout of the request.[0m
[1m        :param allow_redirects: (optional) Boolean. Set to True if POST/PUT/DELETE redirect following is allowed.[0m
[1m        :param proxies: (optional) Dictionary mapping protocol to the URL of the proxy.[0m
[1m        :param verify: (optional) if ``True``, the SSL cert will be verified. A CA_BUNDLE path can also be provided.[0m
[1m        :param stream: (optional) if ``False``, the response content will be immediately downloaded.[0m
[1m        :param cert: (optional) if String, path to ssl client cert file (.pem). If Tuple, ('cert', 'key') pair.[0m
[1m    [0m
[1m        Usage::[0m
[1m    [0m
[1m          >>> import requests[0m
[1m          >>> req = requests.request('GET', 'http://httpbin.org/get')[0m
[1m          <Response [200]>[0m
[1m        """[0m
[1m    [0m
[1m        session = sessions.Session()[0m
[1m>       return session.request(method=method, url=url, **kwargs)[0m

requests/api.py:44: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x26a8210>, method = 'get'
url = 'http://httpbin.org/user-agent', params = None, data = None
headers = {'User-agent': 'Mozilla/5.0'}, cookies = None, files = None
auth = None, timeout = None, allow_redirects = True, proxies = OrderedDict()
hooks = None, stream = False, verify = True, cert = None

[1m    def request(self, method, url,[0m
[1m        params=None,[0m
[1m        data=None,[0m
[1m        headers=None,[0m
[1m        cookies=None,[0m
[1m        files=None,[0m
[1m        auth=None,[0m
[1m        timeout=None,[0m
[1m        allow_redirects=True,[0m
[1m        proxies=None,[0m
[1m        hooks=None,[0m
[1m        stream=None,[0m
[1m        verify=None,[0m
[1m        cert=None):[0m
[1m        """Constructs a :class:`Request <Request>`, prepares it and sends it.[0m
[1m            Returns :class:`Response <Response>` object.[0m
[1m    [0m
[1m            :param method: method for the new :class:`Request` object.[0m
[1m            :param url: URL for the new :class:`Request` object.[0m
[1m            :param params: (optional) Dictionary or bytes to be sent in the query[0m
[1m                string for the :class:`Request`.[0m
[1m            :param data: (optional) Dictionary or bytes to send in the body of the[0m
[1m                :class:`Request`.[0m
[1m            :param headers: (optional) Dictionary of HTTP Headers to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param cookies: (optional) Dict or CookieJar object to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param files: (optional) Dictionary of 'filename': file-like-objects[0m
[1m                for multipart encoding upload.[0m
[1m            :param auth: (optional) Auth tuple or callable to enable[0m
[1m                Basic/Digest/Custom HTTP Auth.[0m
[1m            :param timeout: (optional) Float describing the timeout of the[0m
[1m                request.[0m
[1m            :param allow_redirects: (optional) Boolean. Set to True by default.[0m
[1m            :param proxies: (optional) Dictionary mapping protocol to the URL of[0m
[1m                the proxy.[0m
[1m            :param stream: (optional) whether to immediately download the response[0m
[1m                content. Defaults to ``False``.[0m
[1m            :param verify: (optional) if ``True``, the SSL cert will be verified.[0m
[1m                A CA_BUNDLE path can also be provided.[0m
[1m            :param cert: (optional) if String, path to ssl client cert file (.pem).[0m
[1m                If Tuple, ('cert', 'key') pair.[0m
[1m            """[0m
[1m        # Create the Request.[0m
[1m        req = Request([0m
[1m            method = method.upper(),[0m
[1m            url = url,[0m
[1m            headers = headers,[0m
[1m            files = files,[0m
[1m            data = data or {},[0m
[1m            params = params or {},[0m
[1m            auth = auth,[0m
[1m            cookies = cookies,[0m
[1m            hooks = hooks,[0m
[1m        )[0m
[1m        prep = self.prepare_request(req)[0m
[1m    [0m
[1m        proxies = proxies or {}[0m
[1m    [0m
[1m        # Gather clues from the surrounding environment.[0m
[1m        if self.trust_env:[0m
[1m            # Set environment's proxies.[0m
[1m            env_proxies = get_environ_proxies(url) or {}[0m
[1m            for (k, v) in env_proxies.items():[0m
[1m                proxies.setdefault(k, v)[0m
[1m    [0m
[1m            # Look for configuration.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('REQUESTS_CA_BUNDLE')[0m
[1m    [0m
[1m            # Curl compatibility.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('CURL_CA_BUNDLE')[0m
[1m    [0m
[1m        # Merge all the kwargs.[0m
[1m        proxies = merge_setting(proxies, self.proxies)[0m
[1m        stream = merge_setting(stream, self.stream)[0m
[1m        verify = merge_setting(verify, self.verify)[0m
[1m        cert = merge_setting(cert, self.cert)[0m
[1m    [0m
[1m        # Send the request.[0m
[1m        send_kwargs = {[0m
[1m            'stream': stream,[0m
[1m            'timeout': timeout,[0m
[1m            'verify': verify,[0m
[1m            'cert': cert,[0m
[1m            'proxies': proxies,[0m
[1m            'allow_redirects': allow_redirects,[0m
[1m        }[0m
[1m>       resp = self.send(prep, **send_kwargs)[0m

requests/sessions.py:357: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x26a8210>
request = <PreparedRequest [GET]>
kwargs = {'cert': None, 'proxies': OrderedDict(), 'stream': False, 'timeout': None, ...}
allow_redirects = True, stream = False, timeout = None, verify = True
cert = None, proxies = OrderedDict(), hooks = {'response': []}

[1m    def send(self, request, **kwargs):[0m
[1m        """Send a given PreparedRequest."""[0m
[1m        # Set defaults that the hooks can utilize to ensure they always have[0m
[1m        # the correct parameters to reproduce the previous request.[0m
[1m        kwargs.setdefault('stream', self.stream)[0m
[1m        kwargs.setdefault('verify', self.verify)[0m
[1m        kwargs.setdefault('cert', self.cert)[0m
[1m        kwargs.setdefault('proxies', self.proxies)[0m
[1m    [0m
[1m        # It's possible that users might accidentally send a Request object.[0m
[1m        # Guard against that specific failure case.[0m
[1m        if not isinstance(request, PreparedRequest):[0m
[1m            raise ValueError('You can only send PreparedRequests.')[0m
[1m    [0m
[1m        # Set up variables needed for resolve_redirects and dispatching of[0m
[1m        # hooks[0m
[1m        allow_redirects = kwargs.pop('allow_redirects', True)[0m
[1m        stream = kwargs.get('stream')[0m
[1m        timeout = kwargs.get('timeout')[0m
[1m        verify = kwargs.get('verify')[0m
[1m        cert = kwargs.get('cert')[0m
[1m        proxies = kwargs.get('proxies')[0m
[1m        hooks = request.hooks[0m
[1m    [0m
[1m        # Get the appropriate adapter to use[0m
[1m        adapter = self.get_adapter(url=request.url)[0m
[1m    [0m
[1m        # Start time (approximately) of the request[0m
[1m        start = datetime.utcnow()[0m
[1m        # Send the request[0m
[1m>       r = adapter.send(request, **kwargs)[0m

requests/sessions.py:460: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.adapters.HTTPAdapter object at 0x26a8490>
request = <PreparedRequest [GET]>, stream = False, timeout = None, verify = True
cert = None, proxies = OrderedDict()

[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):[0m
[1m        """Sends PreparedRequest object. Returns Response object.[0m
[1m    [0m
[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.[0m
[1m            :param stream: (optional) Whether to stream the request content.[0m
[1m            :param timeout: (optional) The timeout on the request.[0m
[1m            :param verify: (optional) Whether to verify SSL certificates.[0m
[1m            :param vert: (optional) Any user-provided SSL certificate to be trusted.[0m
[1m            :param proxies: (optional) The proxies dictionary to apply to the request.[0m
[1m            """[0m
[1m    [0m
[1m        conn = self.get_connection(request.url, proxies)[0m
[1m    [0m
[1m        self.cert_verify(conn, request.url, verify, cert)[0m
[1m        url = self.request_url(request, proxies)[0m
[1m        self.add_headers(request)[0m
[1m    [0m
[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)[0m
[1m    [0m
[1m        if stream:[0m
[1m            timeout = Timeout(connect=timeout)[0m
[1m        else:[0m
[1m>           timeout = Timeout(connect=timeout, read=timeout)[0m
[1m[31mE           TypeError: Timeout does not take keyword arguments[0m

requests/adapters.py:305: TypeError
____________________ RequestsTestCase.test_HTTP_200_OK_HEAD ____________________

self = <test_requests.RequestsTestCase testMethod=test_HTTP_200_OK_HEAD>

[1m    def test_HTTP_200_OK_HEAD(self):[0m
[1m>       r = requests.head(httpbin('get'))[0m

test_requests.py:209: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

url = 'http://httpbin.org/get', kwargs = {'allow_redirects': False}

[1m    def head(url, **kwargs):[0m
[1m        """Sends a HEAD request. Returns :class:`Response` object.[0m
[1m    [0m
[1m        :param url: URL for the new :class:`Request` object.[0m
[1m        :param \*\*kwargs: Optional arguments that ``request`` takes.[0m
[1m        """[0m
[1m    [0m
[1m        kwargs.setdefault('allow_redirects', False)[0m
[1m>       return request('head', url, **kwargs)[0m

requests/api.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

method = 'head', url = 'http://httpbin.org/get'
kwargs = {'allow_redirects': False}
session = <requests.sessions.Session object at 0x276a750>

[1m    def request(method, url, **kwargs):[0m
[1m        """Constructs and sends a :class:`Request <Request>`.[0m
[1m        Returns :class:`Response <Response>` object.[0m
[1m    [0m
[1m        :param method: method for the new :class:`Request` object.[0m
[1m        :param url: URL for the new :class:`Request` object.[0m
[1m        :param params: (optional) Dictionary or bytes to be sent in the query string for the :class:`Request`.[0m
[1m        :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.[0m
[1m        :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.[0m
[1m        :param cookies: (optional) Dict or CookieJar object to send with the :class:`Request`.[0m
[1m        :param files: (optional) Dictionary of 'name': file-like-objects (or {'name': ('filename', fileobj)}) for multipart encoding upload.[0m
[1m        :param auth: (optional) Auth tuple to enable Basic/Digest/Custom HTTP Auth.[0m
[1m        :param timeout: (optional) Float describing the timeout of the request.[0m
[1m        :param allow_redirects: (optional) Boolean. Set to True if POST/PUT/DELETE redirect following is allowed.[0m
[1m        :param proxies: (optional) Dictionary mapping protocol to the URL of the proxy.[0m
[1m        :param verify: (optional) if ``True``, the SSL cert will be verified. A CA_BUNDLE path can also be provided.[0m
[1m        :param stream: (optional) if ``False``, the response content will be immediately downloaded.[0m
[1m        :param cert: (optional) if String, path to ssl client cert file (.pem). If Tuple, ('cert', 'key') pair.[0m
[1m    [0m
[1m        Usage::[0m
[1m    [0m
[1m          >>> import requests[0m
[1m          >>> req = requests.request('GET', 'http://httpbin.org/get')[0m
[1m          <Response [200]>[0m
[1m        """[0m
[1m    [0m
[1m        session = sessions.Session()[0m
[1m>       return session.request(method=method, url=url, **kwargs)[0m

requests/api.py:44: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x276a750>, method = 'head'
url = 'http://httpbin.org/get', params = None, data = None, headers = None
cookies = None, files = None, auth = None, timeout = None
allow_redirects = False, proxies = OrderedDict(), hooks = None, stream = False
verify = True, cert = None

[1m    def request(self, method, url,[0m
[1m        params=None,[0m
[1m        data=None,[0m
[1m        headers=None,[0m
[1m        cookies=None,[0m
[1m        files=None,[0m
[1m        auth=None,[0m
[1m        timeout=None,[0m
[1m        allow_redirects=True,[0m
[1m        proxies=None,[0m
[1m        hooks=None,[0m
[1m        stream=None,[0m
[1m        verify=None,[0m
[1m        cert=None):[0m
[1m        """Constructs a :class:`Request <Request>`, prepares it and sends it.[0m
[1m            Returns :class:`Response <Response>` object.[0m
[1m    [0m
[1m            :param method: method for the new :class:`Request` object.[0m
[1m            :param url: URL for the new :class:`Request` object.[0m
[1m            :param params: (optional) Dictionary or bytes to be sent in the query[0m
[1m                string for the :class:`Request`.[0m
[1m            :param data: (optional) Dictionary or bytes to send in the body of the[0m
[1m                :class:`Request`.[0m
[1m            :param headers: (optional) Dictionary of HTTP Headers to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param cookies: (optional) Dict or CookieJar object to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param files: (optional) Dictionary of 'filename': file-like-objects[0m
[1m                for multipart encoding upload.[0m
[1m            :param auth: (optional) Auth tuple or callable to enable[0m
[1m                Basic/Digest/Custom HTTP Auth.[0m
[1m            :param timeout: (optional) Float describing the timeout of the[0m
[1m                request.[0m
[1m            :param allow_redirects: (optional) Boolean. Set to True by default.[0m
[1m            :param proxies: (optional) Dictionary mapping protocol to the URL of[0m
[1m                the proxy.[0m
[1m            :param stream: (optional) whether to immediately download the response[0m
[1m                content. Defaults to ``False``.[0m
[1m            :param verify: (optional) if ``True``, the SSL cert will be verified.[0m
[1m                A CA_BUNDLE path can also be provided.[0m
[1m            :param cert: (optional) if String, path to ssl client cert file (.pem).[0m
[1m                If Tuple, ('cert', 'key') pair.[0m
[1m            """[0m
[1m        # Create the Request.[0m
[1m        req = Request([0m
[1m            method = method.upper(),[0m
[1m            url = url,[0m
[1m            headers = headers,[0m
[1m            files = files,[0m
[1m            data = data or {},[0m
[1m            params = params or {},[0m
[1m            auth = auth,[0m
[1m            cookies = cookies,[0m
[1m            hooks = hooks,[0m
[1m        )[0m
[1m        prep = self.prepare_request(req)[0m
[1m    [0m
[1m        proxies = proxies or {}[0m
[1m    [0m
[1m        # Gather clues from the surrounding environment.[0m
[1m        if self.trust_env:[0m
[1m            # Set environment's proxies.[0m
[1m            env_proxies = get_environ_proxies(url) or {}[0m
[1m            for (k, v) in env_proxies.items():[0m
[1m                proxies.setdefault(k, v)[0m
[1m    [0m
[1m            # Look for configuration.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('REQUESTS_CA_BUNDLE')[0m
[1m    [0m
[1m            # Curl compatibility.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('CURL_CA_BUNDLE')[0m
[1m    [0m
[1m        # Merge all the kwargs.[0m
[1m        proxies = merge_setting(proxies, self.proxies)[0m
[1m        stream = merge_setting(stream, self.stream)[0m
[1m        verify = merge_setting(verify, self.verify)[0m
[1m        cert = merge_setting(cert, self.cert)[0m
[1m    [0m
[1m        # Send the request.[0m
[1m        send_kwargs = {[0m
[1m            'stream': stream,[0m
[1m            'timeout': timeout,[0m
[1m            'verify': verify,[0m
[1m            'cert': cert,[0m
[1m            'proxies': proxies,[0m
[1m            'allow_redirects': allow_redirects,[0m
[1m        }[0m
[1m>       resp = self.send(prep, **send_kwargs)[0m

requests/sessions.py:357: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x276a750>
request = <PreparedRequest [HEAD]>
kwargs = {'cert': None, 'proxies': OrderedDict(), 'stream': False, 'timeout': None, ...}
allow_redirects = False, stream = False, timeout = None, verify = True
cert = None, proxies = OrderedDict(), hooks = {'response': []}

[1m    def send(self, request, **kwargs):[0m
[1m        """Send a given PreparedRequest."""[0m
[1m        # Set defaults that the hooks can utilize to ensure they always have[0m
[1m        # the correct parameters to reproduce the previous request.[0m
[1m        kwargs.setdefault('stream', self.stream)[0m
[1m        kwargs.setdefault('verify', self.verify)[0m
[1m        kwargs.setdefault('cert', self.cert)[0m
[1m        kwargs.setdefault('proxies', self.proxies)[0m
[1m    [0m
[1m        # It's possible that users might accidentally send a Request object.[0m
[1m        # Guard against that specific failure case.[0m
[1m        if not isinstance(request, PreparedRequest):[0m
[1m            raise ValueError('You can only send PreparedRequests.')[0m
[1m    [0m
[1m        # Set up variables needed for resolve_redirects and dispatching of[0m
[1m        # hooks[0m
[1m        allow_redirects = kwargs.pop('allow_redirects', True)[0m
[1m        stream = kwargs.get('stream')[0m
[1m        timeout = kwargs.get('timeout')[0m
[1m        verify = kwargs.get('verify')[0m
[1m        cert = kwargs.get('cert')[0m
[1m        proxies = kwargs.get('proxies')[0m
[1m        hooks = request.hooks[0m
[1m    [0m
[1m        # Get the appropriate adapter to use[0m
[1m        adapter = self.get_adapter(url=request.url)[0m
[1m    [0m
[1m        # Start time (approximately) of the request[0m
[1m        start = datetime.utcnow()[0m
[1m        # Send the request[0m
[1m>       r = adapter.send(request, **kwargs)[0m

requests/sessions.py:460: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.adapters.HTTPAdapter object at 0x276a410>
request = <PreparedRequest [HEAD]>, stream = False, timeout = None
verify = True, cert = None, proxies = OrderedDict()

[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):[0m
[1m        """Sends PreparedRequest object. Returns Response object.[0m
[1m    [0m
[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.[0m
[1m            :param stream: (optional) Whether to stream the request content.[0m
[1m            :param timeout: (optional) The timeout on the request.[0m
[1m            :param verify: (optional) Whether to verify SSL certificates.[0m
[1m            :param vert: (optional) Any user-provided SSL certificate to be trusted.[0m
[1m            :param proxies: (optional) The proxies dictionary to apply to the request.[0m
[1m            """[0m
[1m    [0m
[1m        conn = self.get_connection(request.url, proxies)[0m
[1m    [0m
[1m        self.cert_verify(conn, request.url, verify, cert)[0m
[1m        url = self.request_url(request, proxies)[0m
[1m        self.add_headers(request)[0m
[1m    [0m
[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)[0m
[1m    [0m
[1m        if stream:[0m
[1m            timeout = Timeout(connect=timeout)[0m
[1m        else:[0m
[1m>           timeout = Timeout(connect=timeout, read=timeout)[0m
[1m[31mE           TypeError: Timeout does not take keyword arguments[0m

requests/adapters.py:305: TypeError
____________________ RequestsTestCase.test_HTTP_200_OK_PUT _____________________

self = <test_requests.RequestsTestCase testMethod=test_HTTP_200_OK_PUT>

[1m    def test_HTTP_200_OK_PUT(self):[0m
[1m>       r = requests.put(httpbin('put'))[0m

test_requests.py:213: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

url = 'http://httpbin.org/put', data = None, kwargs = {}

[1m    def put(url, data=None, **kwargs):[0m
[1m        """Sends a PUT request. Returns :class:`Response` object.[0m
[1m    [0m
[1m        :param url: URL for the new :class:`Request` object.[0m
[1m        :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.[0m
[1m        :param \*\*kwargs: Optional arguments that ``request`` takes.[0m
[1m        """[0m
[1m    [0m
[1m>       return request('put', url, data=data, **kwargs)[0m

requests/api.py:99: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

method = 'put', url = 'http://httpbin.org/put', kwargs = {'data': None}
session = <requests.sessions.Session object at 0x26a7990>

[1m    def request(method, url, **kwargs):[0m
[1m        """Constructs and sends a :class:`Request <Request>`.[0m
[1m        Returns :class:`Response <Response>` object.[0m
[1m    [0m
[1m        :param method: method for the new :class:`Request` object.[0m
[1m        :param url: URL for the new :class:`Request` object.[0m
[1m        :param params: (optional) Dictionary or bytes to be sent in the query string for the :class:`Request`.[0m
[1m        :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.[0m
[1m        :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.[0m
[1m        :param cookies: (optional) Dict or CookieJar object to send with the :class:`Request`.[0m
[1m        :param files: (optional) Dictionary of 'name': file-like-objects (or {'name': ('filename', fileobj)}) for multipart encoding upload.[0m
[1m        :param auth: (optional) Auth tuple to enable Basic/Digest/Custom HTTP Auth.[0m
[1m        :param timeout: (optional) Float describing the timeout of the request.[0m
[1m        :param allow_redirects: (optional) Boolean. Set to True if POST/PUT/DELETE redirect following is allowed.[0m
[1m        :param proxies: (optional) Dictionary mapping protocol to the URL of the proxy.[0m
[1m        :param verify: (optional) if ``True``, the SSL cert will be verified. A CA_BUNDLE path can also be provided.[0m
[1m        :param stream: (optional) if ``False``, the response content will be immediately downloaded.[0m
[1m        :param cert: (optional) if String, path to ssl client cert file (.pem). If Tuple, ('cert', 'key') pair.[0m
[1m    [0m
[1m        Usage::[0m
[1m    [0m
[1m          >>> import requests[0m
[1m          >>> req = requests.request('GET', 'http://httpbin.org/get')[0m
[1m          <Response [200]>[0m
[1m        """[0m
[1m    [0m
[1m        session = sessions.Session()[0m
[1m>       return session.request(method=method, url=url, **kwargs)[0m

requests/api.py:44: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x26a7990>, method = 'put'
url = 'http://httpbin.org/put', params = None, data = None, headers = None
cookies = None, files = None, auth = None, timeout = None
allow_redirects = True, proxies = OrderedDict(), hooks = None, stream = False
verify = True, cert = None

[1m    def request(self, method, url,[0m
[1m        params=None,[0m
[1m        data=None,[0m
[1m        headers=None,[0m
[1m        cookies=None,[0m
[1m        files=None,[0m
[1m        auth=None,[0m
[1m        timeout=None,[0m
[1m        allow_redirects=True,[0m
[1m        proxies=None,[0m
[1m        hooks=None,[0m
[1m        stream=None,[0m
[1m        verify=None,[0m
[1m        cert=None):[0m
[1m        """Constructs a :class:`Request <Request>`, prepares it and sends it.[0m
[1m            Returns :class:`Response <Response>` object.[0m
[1m    [0m
[1m            :param method: method for the new :class:`Request` object.[0m
[1m            :param url: URL for the new :class:`Request` object.[0m
[1m            :param params: (optional) Dictionary or bytes to be sent in the query[0m
[1m                string for the :class:`Request`.[0m
[1m            :param data: (optional) Dictionary or bytes to send in the body of the[0m
[1m                :class:`Request`.[0m
[1m            :param headers: (optional) Dictionary of HTTP Headers to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param cookies: (optional) Dict or CookieJar object to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param files: (optional) Dictionary of 'filename': file-like-objects[0m
[1m                for multipart encoding upload.[0m
[1m            :param auth: (optional) Auth tuple or callable to enable[0m
[1m                Basic/Digest/Custom HTTP Auth.[0m
[1m            :param timeout: (optional) Float describing the timeout of the[0m
[1m                request.[0m
[1m            :param allow_redirects: (optional) Boolean. Set to True by default.[0m
[1m            :param proxies: (optional) Dictionary mapping protocol to the URL of[0m
[1m                the proxy.[0m
[1m            :param stream: (optional) whether to immediately download the response[0m
[1m                content. Defaults to ``False``.[0m
[1m            :param verify: (optional) if ``True``, the SSL cert will be verified.[0m
[1m                A CA_BUNDLE path can also be provided.[0m
[1m            :param cert: (optional) if String, path to ssl client cert file (.pem).[0m
[1m                If Tuple, ('cert', 'key') pair.[0m
[1m            """[0m
[1m        # Create the Request.[0m
[1m        req = Request([0m
[1m            method = method.upper(),[0m
[1m            url = url,[0m
[1m            headers = headers,[0m
[1m            files = files,[0m
[1m            data = data or {},[0m
[1m            params = params or {},[0m
[1m            auth = auth,[0m
[1m            cookies = cookies,[0m
[1m            hooks = hooks,[0m
[1m        )[0m
[1m        prep = self.prepare_request(req)[0m
[1m    [0m
[1m        proxies = proxies or {}[0m
[1m    [0m
[1m        # Gather clues from the surrounding environment.[0m
[1m        if self.trust_env:[0m
[1m            # Set environment's proxies.[0m
[1m            env_proxies = get_environ_proxies(url) or {}[0m
[1m            for (k, v) in env_proxies.items():[0m
[1m                proxies.setdefault(k, v)[0m
[1m    [0m
[1m            # Look for configuration.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('REQUESTS_CA_BUNDLE')[0m
[1m    [0m
[1m            # Curl compatibility.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('CURL_CA_BUNDLE')[0m
[1m    [0m
[1m        # Merge all the kwargs.[0m
[1m        proxies = merge_setting(proxies, self.proxies)[0m
[1m        stream = merge_setting(stream, self.stream)[0m
[1m        verify = merge_setting(verify, self.verify)[0m
[1m        cert = merge_setting(cert, self.cert)[0m
[1m    [0m
[1m        # Send the request.[0m
[1m        send_kwargs = {[0m
[1m            'stream': stream,[0m
[1m            'timeout': timeout,[0m
[1m            'verify': verify,[0m
[1m            'cert': cert,[0m
[1m            'proxies': proxies,[0m
[1m            'allow_redirects': allow_redirects,[0m
[1m        }[0m
[1m>       resp = self.send(prep, **send_kwargs)[0m

requests/sessions.py:357: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x26a7990>
request = <PreparedRequest [PUT]>
kwargs = {'cert': None, 'proxies': OrderedDict(), 'stream': False, 'timeout': None, ...}
allow_redirects = True, stream = False, timeout = None, verify = True
cert = None, proxies = OrderedDict(), hooks = {'response': []}

[1m    def send(self, request, **kwargs):[0m
[1m        """Send a given PreparedRequest."""[0m
[1m        # Set defaults that the hooks can utilize to ensure they always have[0m
[1m        # the correct parameters to reproduce the previous request.[0m
[1m        kwargs.setdefault('stream', self.stream)[0m
[1m        kwargs.setdefault('verify', self.verify)[0m
[1m        kwargs.setdefault('cert', self.cert)[0m
[1m        kwargs.setdefault('proxies', self.proxies)[0m
[1m    [0m
[1m        # It's possible that users might accidentally send a Request object.[0m
[1m        # Guard against that specific failure case.[0m
[1m        if not isinstance(request, PreparedRequest):[0m
[1m            raise ValueError('You can only send PreparedRequests.')[0m
[1m    [0m
[1m        # Set up variables needed for resolve_redirects and dispatching of[0m
[1m        # hooks[0m
[1m        allow_redirects = kwargs.pop('allow_redirects', True)[0m
[1m        stream = kwargs.get('stream')[0m
[1m        timeout = kwargs.get('timeout')[0m
[1m        verify = kwargs.get('verify')[0m
[1m        cert = kwargs.get('cert')[0m
[1m        proxies = kwargs.get('proxies')[0m
[1m        hooks = request.hooks[0m
[1m    [0m
[1m        # Get the appropriate adapter to use[0m
[1m        adapter = self.get_adapter(url=request.url)[0m
[1m    [0m
[1m        # Start time (approximately) of the request[0m
[1m        start = datetime.utcnow()[0m
[1m        # Send the request[0m
[1m>       r = adapter.send(request, **kwargs)[0m

requests/sessions.py:460: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.adapters.HTTPAdapter object at 0x26a77d0>
request = <PreparedRequest [PUT]>, stream = False, timeout = None, verify = True
cert = None, proxies = OrderedDict()

[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):[0m
[1m        """Sends PreparedRequest object. Returns Response object.[0m
[1m    [0m
[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.[0m
[1m            :param stream: (optional) Whether to stream the request content.[0m
[1m            :param timeout: (optional) The timeout on the request.[0m
[1m            :param verify: (optional) Whether to verify SSL certificates.[0m
[1m            :param vert: (optional) Any user-provided SSL certificate to be trusted.[0m
[1m            :param proxies: (optional) The proxies dictionary to apply to the request.[0m
[1m            """[0m
[1m    [0m
[1m        conn = self.get_connection(request.url, proxies)[0m
[1m    [0m
[1m        self.cert_verify(conn, request.url, verify, cert)[0m
[1m        url = self.request_url(request, proxies)[0m
[1m        self.add_headers(request)[0m
[1m    [0m
[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)[0m
[1m    [0m
[1m        if stream:[0m
[1m            timeout = Timeout(connect=timeout)[0m
[1m        else:[0m
[1m>           timeout = Timeout(connect=timeout, read=timeout)[0m
[1m[31mE           TypeError: Timeout does not take keyword arguments[0m

requests/adapters.py:305: TypeError
______________ RequestsTestCase.test_HTTP_302_ALLOW_REDIRECT_GET _______________

self = <test_requests.RequestsTestCase testMethod=test_HTTP_302_ALLOW_REDIRECT_GET>

[1m    def test_HTTP_302_ALLOW_REDIRECT_GET(self):[0m
[1m>       r = requests.get(httpbin('redirect', '1'))[0m

test_requests.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

url = 'http://httpbin.org/redirect/1', kwargs = {'allow_redirects': True}

[1m    def get(url, **kwargs):[0m
[1m        """Sends a GET request. Returns :class:`Response` object.[0m
[1m    [0m
[1m        :param url: URL for the new :class:`Request` object.[0m
[1m        :param \*\*kwargs: Optional arguments that ``request`` takes.[0m
[1m        """[0m
[1m    [0m
[1m        kwargs.setdefault('allow_redirects', True)[0m
[1m>       return request('get', url, **kwargs)[0m

requests/api.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

method = 'get', url = 'http://httpbin.org/redirect/1'
kwargs = {'allow_redirects': True}
session = <requests.sessions.Session object at 0x277d590>

[1m    def request(method, url, **kwargs):[0m
[1m        """Constructs and sends a :class:`Request <Request>`.[0m
[1m        Returns :class:`Response <Response>` object.[0m
[1m    [0m
[1m        :param method: method for the new :class:`Request` object.[0m
[1m        :param url: URL for the new :class:`Request` object.[0m
[1m        :param params: (optional) Dictionary or bytes to be sent in the query string for the :class:`Request`.[0m
[1m        :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.[0m
[1m        :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.[0m
[1m        :param cookies: (optional) Dict or CookieJar object to send with the :class:`Request`.[0m
[1m        :param files: (optional) Dictionary of 'name': file-like-objects (or {'name': ('filename', fileobj)}) for multipart encoding upload.[0m
[1m        :param auth: (optional) Auth tuple to enable Basic/Digest/Custom HTTP Auth.[0m
[1m        :param timeout: (optional) Float describing the timeout of the request.[0m
[1m        :param allow_redirects: (optional) Boolean. Set to True if POST/PUT/DELETE redirect following is allowed.[0m
[1m        :param proxies: (optional) Dictionary mapping protocol to the URL of the proxy.[0m
[1m        :param verify: (optional) if ``True``, the SSL cert will be verified. A CA_BUNDLE path can also be provided.[0m
[1m        :param stream: (optional) if ``False``, the response content will be immediately downloaded.[0m
[1m        :param cert: (optional) if String, path to ssl client cert file (.pem). If Tuple, ('cert', 'key') pair.[0m
[1m    [0m
[1m        Usage::[0m
[1m    [0m
[1m          >>> import requests[0m
[1m          >>> req = requests.request('GET', 'http://httpbin.org/get')[0m
[1m          <Response [200]>[0m
[1m        """[0m
[1m    [0m
[1m        session = sessions.Session()[0m
[1m>       return session.request(method=method, url=url, **kwargs)[0m

requests/api.py:44: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x277d590>, method = 'get'
url = 'http://httpbin.org/redirect/1', params = None, data = None
headers = None, cookies = None, files = None, auth = None, timeout = None
allow_redirects = True, proxies = OrderedDict(), hooks = None, stream = False
verify = True, cert = None

[1m    def request(self, method, url,[0m
[1m        params=None,[0m
[1m        data=None,[0m
[1m        headers=None,[0m
[1m        cookies=None,[0m
[1m        files=None,[0m
[1m        auth=None,[0m
[1m        timeout=None,[0m
[1m        allow_redirects=True,[0m
[1m        proxies=None,[0m
[1m        hooks=None,[0m
[1m        stream=None,[0m
[1m        verify=None,[0m
[1m        cert=None):[0m
[1m        """Constructs a :class:`Request <Request>`, prepares it and sends it.[0m
[1m            Returns :class:`Response <Response>` object.[0m
[1m    [0m
[1m            :param method: method for the new :class:`Request` object.[0m
[1m            :param url: URL for the new :class:`Request` object.[0m
[1m            :param params: (optional) Dictionary or bytes to be sent in the query[0m
[1m                string for the :class:`Request`.[0m
[1m            :param data: (optional) Dictionary or bytes to send in the body of the[0m
[1m                :class:`Request`.[0m
[1m            :param headers: (optional) Dictionary of HTTP Headers to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param cookies: (optional) Dict or CookieJar object to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param files: (optional) Dictionary of 'filename': file-like-objects[0m
[1m                for multipart encoding upload.[0m
[1m            :param auth: (optional) Auth tuple or callable to enable[0m
[1m                Basic/Digest/Custom HTTP Auth.[0m
[1m            :param timeout: (optional) Float describing the timeout of the[0m
[1m                request.[0m
[1m            :param allow_redirects: (optional) Boolean. Set to True by default.[0m
[1m            :param proxies: (optional) Dictionary mapping protocol to the URL of[0m
[1m                the proxy.[0m
[1m            :param stream: (optional) whether to immediately download the response[0m
[1m                content. Defaults to ``False``.[0m
[1m            :param verify: (optional) if ``True``, the SSL cert will be verified.[0m
[1m                A CA_BUNDLE path can also be provided.[0m
[1m            :param cert: (optional) if String, path to ssl client cert file (.pem).[0m
[1m                If Tuple, ('cert', 'key') pair.[0m
[1m            """[0m
[1m        # Create the Request.[0m
[1m        req = Request([0m
[1m            method = method.upper(),[0m
[1m            url = url,[0m
[1m            headers = headers,[0m
[1m            files = files,[0m
[1m            data = data or {},[0m
[1m            params = params or {},[0m
[1m            auth = auth,[0m
[1m            cookies = cookies,[0m
[1m            hooks = hooks,[0m
[1m        )[0m
[1m        prep = self.prepare_request(req)[0m
[1m    [0m
[1m        proxies = proxies or {}[0m
[1m    [0m
[1m        # Gather clues from the surrounding environment.[0m
[1m        if self.trust_env:[0m
[1m            # Set environment's proxies.[0m
[1m            env_proxies = get_environ_proxies(url) or {}[0m
[1m            for (k, v) in env_proxies.items():[0m
[1m                proxies.setdefault(k, v)[0m
[1m    [0m
[1m            # Look for configuration.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('REQUESTS_CA_BUNDLE')[0m
[1m    [0m
[1m            # Curl compatibility.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('CURL_CA_BUNDLE')[0m
[1m    [0m
[1m        # Merge all the kwargs.[0m
[1m        proxies = merge_setting(proxies, self.proxies)[0m
[1m        stream = merge_setting(stream, self.stream)[0m
[1m        verify = merge_setting(verify, self.verify)[0m
[1m        cert = merge_setting(cert, self.cert)[0m
[1m    [0m
[1m        # Send the request.[0m
[1m        send_kwargs = {[0m
[1m            'stream': stream,[0m
[1m            'timeout': timeout,[0m
[1m            'verify': verify,[0m
[1m            'cert': cert,[0m
[1m            'proxies': proxies,[0m
[1m            'allow_redirects': allow_redirects,[0m
[1m        }[0m
[1m>       resp = self.send(prep, **send_kwargs)[0m

requests/sessions.py:357: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x277d590>
request = <PreparedRequest [GET]>
kwargs = {'cert': None, 'proxies': OrderedDict(), 'stream': False, 'timeout': None, ...}
allow_redirects = True, stream = False, timeout = None, verify = True
cert = None, proxies = OrderedDict(), hooks = {'response': []}

[1m    def send(self, request, **kwargs):[0m
[1m        """Send a given PreparedRequest."""[0m
[1m        # Set defaults that the hooks can utilize to ensure they always have[0m
[1m        # the correct parameters to reproduce the previous request.[0m
[1m        kwargs.setdefault('stream', self.stream)[0m
[1m        kwargs.setdefault('verify', self.verify)[0m
[1m        kwargs.setdefault('cert', self.cert)[0m
[1m        kwargs.setdefault('proxies', self.proxies)[0m
[1m    [0m
[1m        # It's possible that users might accidentally send a Request object.[0m
[1m        # Guard against that specific failure case.[0m
[1m        if not isinstance(request, PreparedRequest):[0m
[1m            raise ValueError('You can only send PreparedRequests.')[0m
[1m    [0m
[1m        # Set up variables needed for resolve_redirects and dispatching of[0m
[1m        # hooks[0m
[1m        allow_redirects = kwargs.pop('allow_redirects', True)[0m
[1m        stream = kwargs.get('stream')[0m
[1m        timeout = kwargs.get('timeout')[0m
[1m        verify = kwargs.get('verify')[0m
[1m        cert = kwargs.get('cert')[0m
[1m        proxies = kwargs.get('proxies')[0m
[1m        hooks = request.hooks[0m
[1m    [0m
[1m        # Get the appropriate adapter to use[0m
[1m        adapter = self.get_adapter(url=request.url)[0m
[1m    [0m
[1m        # Start time (approximately) of the request[0m
[1m        start = datetime.utcnow()[0m
[1m        # Send the request[0m
[1m>       r = adapter.send(request, **kwargs)[0m

requests/sessions.py:460: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.adapters.HTTPAdapter object at 0x277d650>
request = <PreparedRequest [GET]>, stream = False, timeout = None, verify = True
cert = None, proxies = OrderedDict()

[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):[0m
[1m        """Sends PreparedRequest object. Returns Response object.[0m
[1m    [0m
[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.[0m
[1m            :param stream: (optional) Whether to stream the request content.[0m
[1m            :param timeout: (optional) The timeout on the request.[0m
[1m            :param verify: (optional) Whether to verify SSL certificates.[0m
[1m            :param vert: (optional) Any user-provided SSL certificate to be trusted.[0m
[1m            :param proxies: (optional) The proxies dictionary to apply to the request.[0m
[1m            """[0m
[1m    [0m
[1m        conn = self.get_connection(request.url, proxies)[0m
[1m    [0m
[1m        self.cert_verify(conn, request.url, verify, cert)[0m
[1m        url = self.request_url(request, proxies)[0m
[1m        self.add_headers(request)[0m
[1m    [0m
[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)[0m
[1m    [0m
[1m        if stream:[0m
[1m            timeout = Timeout(connect=timeout)[0m
[1m        else:[0m
[1m>           timeout = Timeout(connect=timeout, read=timeout)[0m
[1m[31mE           TypeError: Timeout does not take keyword arguments[0m

requests/adapters.py:305: TypeError
_________________ RequestsTestCase.test_POSTBIN_GET_POST_FILES _________________

self = <test_requests.RequestsTestCase testMethod=test_POSTBIN_GET_POST_FILES>

[1m    def test_POSTBIN_GET_POST_FILES(self):[0m
[1m    [0m
[1m        url = httpbin('post')[0m
[1m>       post1 = requests.post(url).raise_for_status()[0m

test_requests.py:322: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

url = 'http://httpbin.org/post', data = None, kwargs = {}

[1m    def post(url, data=None, **kwargs):[0m
[1m        """Sends a POST request. Returns :class:`Response` object.[0m
[1m    [0m
[1m        :param url: URL for the new :class:`Request` object.[0m
[1m        :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.[0m
[1m        :param \*\*kwargs: Optional arguments that ``request`` takes.[0m
[1m        """[0m
[1m    [0m
[1m>       return request('post', url, data=data, **kwargs)[0m

requests/api.py:88: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

method = 'post', url = 'http://httpbin.org/post', kwargs = {'data': None}
session = <requests.sessions.Session object at 0x2771f10>

[1m    def request(method, url, **kwargs):[0m
[1m        """Constructs and sends a :class:`Request <Request>`.[0m
[1m        Returns :class:`Response <Response>` object.[0m
[1m    [0m
[1m        :param method: method for the new :class:`Request` object.[0m
[1m        :param url: URL for the new :class:`Request` object.[0m
[1m        :param params: (optional) Dictionary or bytes to be sent in the query string for the :class:`Request`.[0m
[1m        :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.[0m
[1m        :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.[0m
[1m        :param cookies: (optional) Dict or CookieJar object to send with the :class:`Request`.[0m
[1m        :param files: (optional) Dictionary of 'name': file-like-objects (or {'name': ('filename', fileobj)}) for multipart encoding upload.[0m
[1m        :param auth: (optional) Auth tuple to enable Basic/Digest/Custom HTTP Auth.[0m
[1m        :param timeout: (optional) Float describing the timeout of the request.[0m
[1m        :param allow_redirects: (optional) Boolean. Set to True if POST/PUT/DELETE redirect following is allowed.[0m
[1m        :param proxies: (optional) Dictionary mapping protocol to the URL of the proxy.[0m
[1m        :param verify: (optional) if ``True``, the SSL cert will be verified. A CA_BUNDLE path can also be provided.[0m
[1m        :param stream: (optional) if ``False``, the response content will be immediately downloaded.[0m
[1m        :param cert: (optional) if String, path to ssl client cert file (.pem). If Tuple, ('cert', 'key') pair.[0m
[1m    [0m
[1m        Usage::[0m
[1m    [0m
[1m          >>> import requests[0m
[1m          >>> req = requests.request('GET', 'http://httpbin.org/get')[0m
[1m          <Response [200]>[0m
[1m        """[0m
[1m    [0m
[1m        session = sessions.Session()[0m
[1m>       return session.request(method=method, url=url, **kwargs)[0m

requests/api.py:44: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x2771f10>, method = 'post'
url = 'http://httpbin.org/post', params = None, data = None, headers = None
cookies = None, files = None, auth = None, timeout = None
allow_redirects = True, proxies = OrderedDict(), hooks = None, stream = False
verify = True, cert = None

[1m    def request(self, method, url,[0m
[1m        params=None,[0m
[1m        data=None,[0m
[1m        headers=None,[0m
[1m        cookies=None,[0m
[1m        files=None,[0m
[1m        auth=None,[0m
[1m        timeout=None,[0m
[1m        allow_redirects=True,[0m
[1m        proxies=None,[0m
[1m        hooks=None,[0m
[1m        stream=None,[0m
[1m        verify=None,[0m
[1m        cert=None):[0m
[1m        """Constructs a :class:`Request <Request>`, prepares it and sends it.[0m
[1m            Returns :class:`Response <Response>` object.[0m
[1m    [0m
[1m            :param method: method for the new :class:`Request` object.[0m
[1m            :param url: URL for the new :class:`Request` object.[0m
[1m            :param params: (optional) Dictionary or bytes to be sent in the query[0m
[1m                string for the :class:`Request`.[0m
[1m            :param data: (optional) Dictionary or bytes to send in the body of the[0m
[1m                :class:`Request`.[0m
[1m            :param headers: (optional) Dictionary of HTTP Headers to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param cookies: (optional) Dict or CookieJar object to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param files: (optional) Dictionary of 'filename': file-like-objects[0m
[1m                for multipart encoding upload.[0m
[1m            :param auth: (optional) Auth tuple or callable to enable[0m
[1m                Basic/Digest/Custom HTTP Auth.[0m
[1m            :param timeout: (optional) Float describing the timeout of the[0m
[1m                request.[0m
[1m            :param allow_redirects: (optional) Boolean. Set to True by default.[0m
[1m            :param proxies: (optional) Dictionary mapping protocol to the URL of[0m
[1m                the proxy.[0m
[1m            :param stream: (optional) whether to immediately download the response[0m
[1m                content. Defaults to ``False``.[0m
[1m            :param verify: (optional) if ``True``, the SSL cert will be verified.[0m
[1m                A CA_BUNDLE path can also be provided.[0m
[1m            :param cert: (optional) if String, path to ssl client cert file (.pem).[0m
[1m                If Tuple, ('cert', 'key') pair.[0m
[1m            """[0m
[1m        # Create the Request.[0m
[1m        req = Request([0m
[1m            method = method.upper(),[0m
[1m            url = url,[0m
[1m            headers = headers,[0m
[1m            files = files,[0m
[1m            data = data or {},[0m
[1m            params = params or {},[0m
[1m            auth = auth,[0m
[1m            cookies = cookies,[0m
[1m            hooks = hooks,[0m
[1m        )[0m
[1m        prep = self.prepare_request(req)[0m
[1m    [0m
[1m        proxies = proxies or {}[0m
[1m    [0m
[1m        # Gather clues from the surrounding environment.[0m
[1m        if self.trust_env:[0m
[1m            # Set environment's proxies.[0m
[1m            env_proxies = get_environ_proxies(url) or {}[0m
[1m            for (k, v) in env_proxies.items():[0m
[1m                proxies.setdefault(k, v)[0m
[1m    [0m
[1m            # Look for configuration.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('REQUESTS_CA_BUNDLE')[0m
[1m    [0m
[1m            # Curl compatibility.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('CURL_CA_BUNDLE')[0m
[1m    [0m
[1m        # Merge all the kwargs.[0m
[1m        proxies = merge_setting(proxies, self.proxies)[0m
[1m        stream = merge_setting(stream, self.stream)[0m
[1m        verify = merge_setting(verify, self.verify)[0m
[1m        cert = merge_setting(cert, self.cert)[0m
[1m    [0m
[1m        # Send the request.[0m
[1m        send_kwargs = {[0m
[1m            'stream': stream,[0m
[1m            'timeout': timeout,[0m
[1m            'verify': verify,[0m
[1m            'cert': cert,[0m
[1m            'proxies': proxies,[0m
[1m            'allow_redirects': allow_redirects,[0m
[1m        }[0m
[1m>       resp = self.send(prep, **send_kwargs)[0m

requests/sessions.py:357: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x2771f10>
request = <PreparedRequest [POST]>
kwargs = {'cert': None, 'proxies': OrderedDict(), 'stream': False, 'timeout': None, ...}
allow_redirects = True, stream = False, timeout = None, verify = True
cert = None, proxies = OrderedDict(), hooks = {'response': []}

[1m    def send(self, request, **kwargs):[0m
[1m        """Send a given PreparedRequest."""[0m
[1m        # Set defaults that the hooks can utilize to ensure they always have[0m
[1m        # the correct parameters to reproduce the previous request.[0m
[1m        kwargs.setdefault('stream', self.stream)[0m
[1m        kwargs.setdefault('verify', self.verify)[0m
[1m        kwargs.setdefault('cert', self.cert)[0m
[1m        kwargs.setdefault('proxies', self.proxies)[0m
[1m    [0m
[1m        # It's possible that users might accidentally send a Request object.[0m
[1m        # Guard against that specific failure case.[0m
[1m        if not isinstance(request, PreparedRequest):[0m
[1m            raise ValueError('You can only send PreparedRequests.')[0m
[1m    [0m
[1m        # Set up variables needed for resolve_redirects and dispatching of[0m
[1m        # hooks[0m
[1m        allow_redirects = kwargs.pop('allow_redirects', True)[0m
[1m        stream = kwargs.get('stream')[0m
[1m        timeout = kwargs.get('timeout')[0m
[1m        verify = kwargs.get('verify')[0m
[1m        cert = kwargs.get('cert')[0m
[1m        proxies = kwargs.get('proxies')[0m
[1m        hooks = request.hooks[0m
[1m    [0m
[1m        # Get the appropriate adapter to use[0m
[1m        adapter = self.get_adapter(url=request.url)[0m
[1m    [0m
[1m        # Start time (approximately) of the request[0m
[1m        start = datetime.utcnow()[0m
[1m        # Send the request[0m
[1m>       r = adapter.send(request, **kwargs)[0m

requests/sessions.py:460: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.adapters.HTTPAdapter object at 0x2771310>
request = <PreparedRequest [POST]>, stream = False, timeout = None
verify = True, cert = None, proxies = OrderedDict()

[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):[0m
[1m        """Sends PreparedRequest object. Returns Response object.[0m
[1m    [0m
[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.[0m
[1m            :param stream: (optional) Whether to stream the request content.[0m
[1m            :param timeout: (optional) The timeout on the request.[0m
[1m            :param verify: (optional) Whether to verify SSL certificates.[0m
[1m            :param vert: (optional) Any user-provided SSL certificate to be trusted.[0m
[1m            :param proxies: (optional) The proxies dictionary to apply to the request.[0m
[1m            """[0m
[1m    [0m
[1m        conn = self.get_connection(request.url, proxies)[0m
[1m    [0m
[1m        self.cert_verify(conn, request.url, verify, cert)[0m
[1m        url = self.request_url(request, proxies)[0m
[1m        self.add_headers(request)[0m
[1m    [0m
[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)[0m
[1m    [0m
[1m        if stream:[0m
[1m            timeout = Timeout(connect=timeout)[0m
[1m        else:[0m
[1m>           timeout = Timeout(connect=timeout, read=timeout)[0m
[1m[31mE           TypeError: Timeout does not take keyword arguments[0m

requests/adapters.py:305: TypeError
____________ RequestsTestCase.test_POSTBIN_GET_POST_FILES_WITH_DATA ____________

self = <test_requests.RequestsTestCase testMethod=test_POSTBIN_GET_POST_FILES_WITH_DATA>

[1m    def test_POSTBIN_GET_POST_FILES_WITH_DATA(self):[0m
[1m    [0m
[1m        url = httpbin('post')[0m
[1m>       post1 = requests.post(url).raise_for_status()[0m

test_requests.py:342: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

url = 'http://httpbin.org/post', data = None, kwargs = {}

[1m    def post(url, data=None, **kwargs):[0m
[1m        """Sends a POST request. Returns :class:`Response` object.[0m
[1m    [0m
[1m        :param url: URL for the new :class:`Request` object.[0m
[1m        :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.[0m
[1m        :param \*\*kwargs: Optional arguments that ``request`` takes.[0m
[1m        """[0m
[1m    [0m
[1m>       return request('post', url, data=data, **kwargs)[0m

requests/api.py:88: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

method = 'post', url = 'http://httpbin.org/post', kwargs = {'data': None}
session = <requests.sessions.Session object at 0x275c3d0>

[1m    def request(method, url, **kwargs):[0m
[1m        """Constructs and sends a :class:`Request <Request>`.[0m
[1m        Returns :class:`Response <Response>` object.[0m
[1m    [0m
[1m        :param method: method for the new :class:`Request` object.[0m
[1m        :param url: URL for the new :class:`Request` object.[0m
[1m        :param params: (optional) Dictionary or bytes to be sent in the query string for the :class:`Request`.[0m
[1m        :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.[0m
[1m        :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.[0m
[1m        :param cookies: (optional) Dict or CookieJar object to send with the :class:`Request`.[0m
[1m        :param files: (optional) Dictionary of 'name': file-like-objects (or {'name': ('filename', fileobj)}) for multipart encoding upload.[0m
[1m        :param auth: (optional) Auth tuple to enable Basic/Digest/Custom HTTP Auth.[0m
[1m        :param timeout: (optional) Float describing the timeout of the request.[0m
[1m        :param allow_redirects: (optional) Boolean. Set to True if POST/PUT/DELETE redirect following is allowed.[0m
[1m        :param proxies: (optional) Dictionary mapping protocol to the URL of the proxy.[0m
[1m        :param verify: (optional) if ``True``, the SSL cert will be verified. A CA_BUNDLE path can also be provided.[0m
[1m        :param stream: (optional) if ``False``, the response content will be immediately downloaded.[0m
[1m        :param cert: (optional) if String, path to ssl client cert file (.pem). If Tuple, ('cert', 'key') pair.[0m
[1m    [0m
[1m        Usage::[0m
[1m    [0m
[1m          >>> import requests[0m
[1m          >>> req = requests.request('GET', 'http://httpbin.org/get')[0m
[1m          <Response [200]>[0m
[1m        """[0m
[1m    [0m
[1m        session = sessions.Session()[0m
[1m>       return session.request(method=method, url=url, **kwargs)[0m

requests/api.py:44: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x275c3d0>, method = 'post'
url = 'http://httpbin.org/post', params = None, data = None, headers = None
cookies = None, files = None, auth = None, timeout = None
allow_redirects = True, proxies = OrderedDict(), hooks = None, stream = False
verify = True, cert = None

[1m    def request(self, method, url,[0m
[1m        params=None,[0m
[1m        data=None,[0m
[1m        headers=None,[0m
[1m        cookies=None,[0m
[1m        files=None,[0m
[1m        auth=None,[0m
[1m        timeout=None,[0m
[1m        allow_redirects=True,[0m
[1m        proxies=None,[0m
[1m        hooks=None,[0m
[1m        stream=None,[0m
[1m        verify=None,[0m
[1m        cert=None):[0m
[1m        """Constructs a :class:`Request <Request>`, prepares it and sends it.[0m
[1m            Returns :class:`Response <Response>` object.[0m
[1m    [0m
[1m            :param method: method for the new :class:`Request` object.[0m
[1m            :param url: URL for the new :class:`Request` object.[0m
[1m            :param params: (optional) Dictionary or bytes to be sent in the query[0m
[1m                string for the :class:`Request`.[0m
[1m            :param data: (optional) Dictionary or bytes to send in the body of the[0m
[1m                :class:`Request`.[0m
[1m            :param headers: (optional) Dictionary of HTTP Headers to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param cookies: (optional) Dict or CookieJar object to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param files: (optional) Dictionary of 'filename': file-like-objects[0m
[1m                for multipart encoding upload.[0m
[1m            :param auth: (optional) Auth tuple or callable to enable[0m
[1m                Basic/Digest/Custom HTTP Auth.[0m
[1m            :param timeout: (optional) Float describing the timeout of the[0m
[1m                request.[0m
[1m            :param allow_redirects: (optional) Boolean. Set to True by default.[0m
[1m            :param proxies: (optional) Dictionary mapping protocol to the URL of[0m
[1m                the proxy.[0m
[1m            :param stream: (optional) whether to immediately download the response[0m
[1m                content. Defaults to ``False``.[0m
[1m            :param verify: (optional) if ``True``, the SSL cert will be verified.[0m
[1m                A CA_BUNDLE path can also be provided.[0m
[1m            :param cert: (optional) if String, path to ssl client cert file (.pem).[0m
[1m                If Tuple, ('cert', 'key') pair.[0m
[1m            """[0m
[1m        # Create the Request.[0m
[1m        req = Request([0m
[1m            method = method.upper(),[0m
[1m            url = url,[0m
[1m            headers = headers,[0m
[1m            files = files,[0m
[1m            data = data or {},[0m
[1m            params = params or {},[0m
[1m            auth = auth,[0m
[1m            cookies = cookies,[0m
[1m            hooks = hooks,[0m
[1m        )[0m
[1m        prep = self.prepare_request(req)[0m
[1m    [0m
[1m        proxies = proxies or {}[0m
[1m    [0m
[1m        # Gather clues from the surrounding environment.[0m
[1m        if self.trust_env:[0m
[1m            # Set environment's proxies.[0m
[1m            env_proxies = get_environ_proxies(url) or {}[0m
[1m            for (k, v) in env_proxies.items():[0m
[1m                proxies.setdefault(k, v)[0m
[1m    [0m
[1m            # Look for configuration.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('REQUESTS_CA_BUNDLE')[0m
[1m    [0m
[1m            # Curl compatibility.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('CURL_CA_BUNDLE')[0m
[1m    [0m
[1m        # Merge all the kwargs.[0m
[1m        proxies = merge_setting(proxies, self.proxies)[0m
[1m        stream = merge_setting(stream, self.stream)[0m
[1m        verify = merge_setting(verify, self.verify)[0m
[1m        cert = merge_setting(cert, self.cert)[0m
[1m    [0m
[1m        # Send the request.[0m
[1m        send_kwargs = {[0m
[1m            'stream': stream,[0m
[1m            'timeout': timeout,[0m
[1m            'verify': verify,[0m
[1m            'cert': cert,[0m
[1m            'proxies': proxies,[0m
[1m            'allow_redirects': allow_redirects,[0m
[1m        }[0m
[1m>       resp = self.send(prep, **send_kwargs)[0m

requests/sessions.py:357: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x275c3d0>
request = <PreparedRequest [POST]>
kwargs = {'cert': None, 'proxies': OrderedDict(), 'stream': False, 'timeout': None, ...}
allow_redirects = True, stream = False, timeout = None, verify = True
cert = None, proxies = OrderedDict(), hooks = {'response': []}

[1m    def send(self, request, **kwargs):[0m
[1m        """Send a given PreparedRequest."""[0m
[1m        # Set defaults that the hooks can utilize to ensure they always have[0m
[1m        # the correct parameters to reproduce the previous request.[0m
[1m        kwargs.setdefault('stream', self.stream)[0m
[1m        kwargs.setdefault('verify', self.verify)[0m
[1m        kwargs.setdefault('cert', self.cert)[0m
[1m        kwargs.setdefault('proxies', self.proxies)[0m
[1m    [0m
[1m        # It's possible that users might accidentally send a Request object.[0m
[1m        # Guard against that specific failure case.[0m
[1m        if not isinstance(request, PreparedRequest):[0m
[1m            raise ValueError('You can only send PreparedRequests.')[0m
[1m    [0m
[1m        # Set up variables needed for resolve_redirects and dispatching of[0m
[1m        # hooks[0m
[1m        allow_redirects = kwargs.pop('allow_redirects', True)[0m
[1m        stream = kwargs.get('stream')[0m
[1m        timeout = kwargs.get('timeout')[0m
[1m        verify = kwargs.get('verify')[0m
[1m        cert = kwargs.get('cert')[0m
[1m        proxies = kwargs.get('proxies')[0m
[1m        hooks = request.hooks[0m
[1m    [0m
[1m        # Get the appropriate adapter to use[0m
[1m        adapter = self.get_adapter(url=request.url)[0m
[1m    [0m
[1m        # Start time (approximately) of the request[0m
[1m        start = datetime.utcnow()[0m
[1m        # Send the request[0m
[1m>       r = adapter.send(request, **kwargs)[0m

requests/sessions.py:460: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.adapters.HTTPAdapter object at 0x275c350>
request = <PreparedRequest [POST]>, stream = False, timeout = None
verify = True, cert = None, proxies = OrderedDict()

[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):[0m
[1m        """Sends PreparedRequest object. Returns Response object.[0m
[1m    [0m
[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.[0m
[1m            :param stream: (optional) Whether to stream the request content.[0m
[1m            :param timeout: (optional) The timeout on the request.[0m
[1m            :param verify: (optional) Whether to verify SSL certificates.[0m
[1m            :param vert: (optional) Any user-provided SSL certificate to be trusted.[0m
[1m            :param proxies: (optional) The proxies dictionary to apply to the request.[0m
[1m            """[0m
[1m    [0m
[1m        conn = self.get_connection(request.url, proxies)[0m
[1m    [0m
[1m        self.cert_verify(conn, request.url, verify, cert)[0m
[1m        url = self.request_url(request, proxies)[0m
[1m        self.add_headers(request)[0m
[1m    [0m
[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)[0m
[1m    [0m
[1m        if stream:[0m
[1m            timeout = Timeout(connect=timeout)[0m
[1m        else:[0m
[1m>           timeout = Timeout(connect=timeout, read=timeout)[0m
[1m[31mE           TypeError: Timeout does not take keyword arguments[0m

requests/adapters.py:305: TypeError
__________________ RequestsTestCase.test_basicauth_with_netrc __________________

self = <test_requests.RequestsTestCase testMethod=test_basicauth_with_netrc>

[1m    def test_basicauth_with_netrc(self):[0m
[1m        auth = ('user', 'pass')[0m
[1m        wrong_auth = ('wronguser', 'wrongpass')[0m
[1m        url = httpbin('basic-auth', 'user', 'pass')[0m
[1m    [0m
[1m        def get_netrc_auth_mock(url):[0m
[1m            return auth[0m
[1m        requests.sessions.get_netrc_auth = get_netrc_auth_mock[0m
[1m    [0m
[1m        # Should use netrc and work.[0m
[1m>       r = requests.get(url)[0m

test_requests.py:241: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

url = 'http://httpbin.org/basic-auth/user/pass'
kwargs = {'allow_redirects': True}

[1m    def get(url, **kwargs):[0m
[1m        """Sends a GET request. Returns :class:`Response` object.[0m
[1m    [0m
[1m        :param url: URL for the new :class:`Request` object.[0m
[1m        :param \*\*kwargs: Optional arguments that ``request`` takes.[0m
[1m        """[0m
[1m    [0m
[1m        kwargs.setdefault('allow_redirects', True)[0m
[1m>       return request('get', url, **kwargs)[0m

requests/api.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

method = 'get', url = 'http://httpbin.org/basic-auth/user/pass'
kwargs = {'allow_redirects': True}
session = <requests.sessions.Session object at 0x26a8f90>

[1m    def request(method, url, **kwargs):[0m
[1m        """Constructs and sends a :class:`Request <Request>`.[0m
[1m        Returns :class:`Response <Response>` object.[0m
[1m    [0m
[1m        :param method: method for the new :class:`Request` object.[0m
[1m        :param url: URL for the new :class:`Request` object.[0m
[1m        :param params: (optional) Dictionary or bytes to be sent in the query string for the :class:`Request`.[0m
[1m        :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.[0m
[1m        :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.[0m
[1m        :param cookies: (optional) Dict or CookieJar object to send with the :class:`Request`.[0m
[1m        :param files: (optional) Dictionary of 'name': file-like-objects (or {'name': ('filename', fileobj)}) for multipart encoding upload.[0m
[1m        :param auth: (optional) Auth tuple to enable Basic/Digest/Custom HTTP Auth.[0m
[1m        :param timeout: (optional) Float describing the timeout of the request.[0m
[1m        :param allow_redirects: (optional) Boolean. Set to True if POST/PUT/DELETE redirect following is allowed.[0m
[1m        :param proxies: (optional) Dictionary mapping protocol to the URL of the proxy.[0m
[1m        :param verify: (optional) if ``True``, the SSL cert will be verified. A CA_BUNDLE path can also be provided.[0m
[1m        :param stream: (optional) if ``False``, the response content will be immediately downloaded.[0m
[1m        :param cert: (optional) if String, path to ssl client cert file (.pem). If Tuple, ('cert', 'key') pair.[0m
[1m    [0m
[1m        Usage::[0m
[1m    [0m
[1m          >>> import requests[0m
[1m          >>> req = requests.request('GET', 'http://httpbin.org/get')[0m
[1m          <Response [200]>[0m
[1m        """[0m
[1m    [0m
[1m        session = sessions.Session()[0m
[1m>       return session.request(method=method, url=url, **kwargs)[0m

requests/api.py:44: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x26a8f90>, method = 'get'
url = 'http://httpbin.org/basic-auth/user/pass', params = None, data = None
headers = None, cookies = None, files = None, auth = None, timeout = None
allow_redirects = True, proxies = OrderedDict(), hooks = None, stream = False
verify = True, cert = None

[1m    def request(self, method, url,[0m
[1m        params=None,[0m
[1m        data=None,[0m
[1m        headers=None,[0m
[1m        cookies=None,[0m
[1m        files=None,[0m
[1m        auth=None,[0m
[1m        timeout=None,[0m
[1m        allow_redirects=True,[0m
[1m        proxies=None,[0m
[1m        hooks=None,[0m
[1m        stream=None,[0m
[1m        verify=None,[0m
[1m        cert=None):[0m
[1m        """Constructs a :class:`Request <Request>`, prepares it and sends it.[0m
[1m            Returns :class:`Response <Response>` object.[0m
[1m    [0m
[1m            :param method: method for the new :class:`Request` object.[0m
[1m            :param url: URL for the new :class:`Request` object.[0m
[1m            :param params: (optional) Dictionary or bytes to be sent in the query[0m
[1m                string for the :class:`Request`.[0m
[1m            :param data: (optional) Dictionary or bytes to send in the body of the[0m
[1m                :class:`Request`.[0m
[1m            :param headers: (optional) Dictionary of HTTP Headers to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param cookies: (optional) Dict or CookieJar object to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param files: (optional) Dictionary of 'filename': file-like-objects[0m
[1m                for multipart encoding upload.[0m
[1m            :param auth: (optional) Auth tuple or callable to enable[0m
[1m                Basic/Digest/Custom HTTP Auth.[0m
[1m            :param timeout: (optional) Float describing the timeout of the[0m
[1m                request.[0m
[1m            :param allow_redirects: (optional) Boolean. Set to True by default.[0m
[1m            :param proxies: (optional) Dictionary mapping protocol to the URL of[0m
[1m                the proxy.[0m
[1m            :param stream: (optional) whether to immediately download the response[0m
[1m                content. Defaults to ``False``.[0m
[1m            :param verify: (optional) if ``True``, the SSL cert will be verified.[0m
[1m                A CA_BUNDLE path can also be provided.[0m
[1m            :param cert: (optional) if String, path to ssl client cert file (.pem).[0m
[1m                If Tuple, ('cert', 'key') pair.[0m
[1m            """[0m
[1m        # Create the Request.[0m
[1m        req = Request([0m
[1m            method = method.upper(),[0m
[1m            url = url,[0m
[1m            headers = headers,[0m
[1m            files = files,[0m
[1m            data = data or {},[0m
[1m            params = params or {},[0m
[1m            auth = auth,[0m
[1m            cookies = cookies,[0m
[1m            hooks = hooks,[0m
[1m        )[0m
[1m        prep = self.prepare_request(req)[0m
[1m    [0m
[1m        proxies = proxies or {}[0m
[1m    [0m
[1m        # Gather clues from the surrounding environment.[0m
[1m        if self.trust_env:[0m
[1m            # Set environment's proxies.[0m
[1m            env_proxies = get_environ_proxies(url) or {}[0m
[1m            for (k, v) in env_proxies.items():[0m
[1m                proxies.setdefault(k, v)[0m
[1m    [0m
[1m            # Look for configuration.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('REQUESTS_CA_BUNDLE')[0m
[1m    [0m
[1m            # Curl compatibility.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('CURL_CA_BUNDLE')[0m
[1m    [0m
[1m        # Merge all the kwargs.[0m
[1m        proxies = merge_setting(proxies, self.proxies)[0m
[1m        stream = merge_setting(stream, self.stream)[0m
[1m        verify = merge_setting(verify, self.verify)[0m
[1m        cert = merge_setting(cert, self.cert)[0m
[1m    [0m
[1m        # Send the request.[0m
[1m        send_kwargs = {[0m
[1m            'stream': stream,[0m
[1m            'timeout': timeout,[0m
[1m            'verify': verify,[0m
[1m            'cert': cert,[0m
[1m            'proxies': proxies,[0m
[1m            'allow_redirects': allow_redirects,[0m
[1m        }[0m
[1m>       resp = self.send(prep, **send_kwargs)[0m

requests/sessions.py:357: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x26a8f90>
request = <PreparedRequest [GET]>
kwargs = {'cert': None, 'proxies': OrderedDict(), 'stream': False, 'timeout': None, ...}
allow_redirects = True, stream = False, timeout = None, verify = True
cert = None, proxies = OrderedDict(), hooks = {'response': []}

[1m    def send(self, request, **kwargs):[0m
[1m        """Send a given PreparedRequest."""[0m
[1m        # Set defaults that the hooks can utilize to ensure they always have[0m
[1m        # the correct parameters to reproduce the previous request.[0m
[1m        kwargs.setdefault('stream', self.stream)[0m
[1m        kwargs.setdefault('verify', self.verify)[0m
[1m        kwargs.setdefault('cert', self.cert)[0m
[1m        kwargs.setdefault('proxies', self.proxies)[0m
[1m    [0m
[1m        # It's possible that users might accidentally send a Request object.[0m
[1m        # Guard against that specific failure case.[0m
[1m        if not isinstance(request, PreparedRequest):[0m
[1m            raise ValueError('You can only send PreparedRequests.')[0m
[1m    [0m
[1m        # Set up variables needed for resolve_redirects and dispatching of[0m
[1m        # hooks[0m
[1m        allow_redirects = kwargs.pop('allow_redirects', True)[0m
[1m        stream = kwargs.get('stream')[0m
[1m        timeout = kwargs.get('timeout')[0m
[1m        verify = kwargs.get('verify')[0m
[1m        cert = kwargs.get('cert')[0m
[1m        proxies = kwargs.get('proxies')[0m
[1m        hooks = request.hooks[0m
[1m    [0m
[1m        # Get the appropriate adapter to use[0m
[1m        adapter = self.get_adapter(url=request.url)[0m
[1m    [0m
[1m        # Start time (approximately) of the request[0m
[1m        start = datetime.utcnow()[0m
[1m        # Send the request[0m
[1m>       r = adapter.send(request, **kwargs)[0m

requests/sessions.py:460: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.adapters.HTTPAdapter object at 0x26a8c90>
request = <PreparedRequest [GET]>, stream = False, timeout = None, verify = True
cert = None, proxies = OrderedDict()

[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):[0m
[1m        """Sends PreparedRequest object. Returns Response object.[0m
[1m    [0m
[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.[0m
[1m            :param stream: (optional) Whether to stream the request content.[0m
[1m            :param timeout: (optional) The timeout on the request.[0m
[1m            :param verify: (optional) Whether to verify SSL certificates.[0m
[1m            :param vert: (optional) Any user-provided SSL certificate to be trusted.[0m
[1m            :param proxies: (optional) The proxies dictionary to apply to the request.[0m
[1m            """[0m
[1m    [0m
[1m        conn = self.get_connection(request.url, proxies)[0m
[1m    [0m
[1m        self.cert_verify(conn, request.url, verify, cert)[0m
[1m        url = self.request_url(request, proxies)[0m
[1m        self.add_headers(request)[0m
[1m    [0m
[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)[0m
[1m    [0m
[1m        if stream:[0m
[1m            timeout = Timeout(connect=timeout)[0m
[1m        else:[0m
[1m>           timeout = Timeout(connect=timeout, read=timeout)[0m
[1m[31mE           TypeError: Timeout does not take keyword arguments[0m

requests/adapters.py:305: TypeError
__________________ RequestsTestCase.test_cookie_quote_wrapped __________________

self = <test_requests.RequestsTestCase testMethod=test_cookie_quote_wrapped>

[1m    def test_cookie_quote_wrapped(self):[0m
[1m        s = requests.session()[0m
[1m>       s.get(httpbin('cookies/set?foo="bar:baz"'))[0m

test_requests.py:164: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x26a5950>
url = 'http://httpbin.org/cookies/set?foo="bar:baz"'
kwargs = {'allow_redirects': True}

[1m    def get(self, url, **kwargs):[0m
[1m        """Sends a GET request. Returns :class:`Response` object.[0m
[1m    [0m
[1m            :param url: URL for the new :class:`Request` object.[0m
[1m            :param \*\*kwargs: Optional arguments that ``request`` takes.[0m
[1m            """[0m
[1m    [0m
[1m        kwargs.setdefault('allow_redirects', True)[0m
[1m>       return self.request('GET', url, **kwargs)[0m

requests/sessions.py:369: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x26a5950>, method = 'GET'
url = 'http://httpbin.org/cookies/set?foo="bar:baz"', params = None, data = None
headers = None, cookies = None, files = None, auth = None, timeout = None
allow_redirects = True, proxies = OrderedDict(), hooks = None, stream = False
verify = True, cert = None

[1m    def request(self, method, url,[0m
[1m        params=None,[0m
[1m        data=None,[0m
[1m        headers=None,[0m
[1m        cookies=None,[0m
[1m        files=None,[0m
[1m        auth=None,[0m
[1m        timeout=None,[0m
[1m        allow_redirects=True,[0m
[1m        proxies=None,[0m
[1m        hooks=None,[0m
[1m        stream=None,[0m
[1m        verify=None,[0m
[1m        cert=None):[0m
[1m        """Constructs a :class:`Request <Request>`, prepares it and sends it.[0m
[1m            Returns :class:`Response <Response>` object.[0m
[1m    [0m
[1m            :param method: method for the new :class:`Request` object.[0m
[1m            :param url: URL for the new :class:`Request` object.[0m
[1m            :param params: (optional) Dictionary or bytes to be sent in the query[0m
[1m                string for the :class:`Request`.[0m
[1m            :param data: (optional) Dictionary or bytes to send in the body of the[0m
[1m                :class:`Request`.[0m
[1m            :param headers: (optional) Dictionary of HTTP Headers to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param cookies: (optional) Dict or CookieJar object to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param files: (optional) Dictionary of 'filename': file-like-objects[0m
[1m                for multipart encoding upload.[0m
[1m            :param auth: (optional) Auth tuple or callable to enable[0m
[1m                Basic/Digest/Custom HTTP Auth.[0m
[1m            :param timeout: (optional) Float describing the timeout of the[0m
[1m                request.[0m
[1m            :param allow_redirects: (optional) Boolean. Set to True by default.[0m
[1m            :param proxies: (optional) Dictionary mapping protocol to the URL of[0m
[1m                the proxy.[0m
[1m            :param stream: (optional) whether to immediately download the response[0m
[1m                content. Defaults to ``False``.[0m
[1m            :param verify: (optional) if ``True``, the SSL cert will be verified.[0m
[1m                A CA_BUNDLE path can also be provided.[0m
[1m            :param cert: (optional) if String, path to ssl client cert file (.pem).[0m
[1m                If Tuple, ('cert', 'key') pair.[0m
[1m            """[0m
[1m        # Create the Request.[0m
[1m        req = Request([0m
[1m            method = method.upper(),[0m
[1m            url = url,[0m
[1m            headers = headers,[0m
[1m            files = files,[0m
[1m            data = data or {},[0m
[1m            params = params or {},[0m
[1m            auth = auth,[0m
[1m            cookies = cookies,[0m
[1m            hooks = hooks,[0m
[1m        )[0m
[1m        prep = self.prepare_request(req)[0m
[1m    [0m
[1m        proxies = proxies or {}[0m
[1m    [0m
[1m        # Gather clues from the surrounding environment.[0m
[1m        if self.trust_env:[0m
[1m            # Set environment's proxies.[0m
[1m            env_proxies = get_environ_proxies(url) or {}[0m
[1m            for (k, v) in env_proxies.items():[0m
[1m                proxies.setdefault(k, v)[0m
[1m    [0m
[1m            # Look for configuration.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('REQUESTS_CA_BUNDLE')[0m
[1m    [0m
[1m            # Curl compatibility.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('CURL_CA_BUNDLE')[0m
[1m    [0m
[1m        # Merge all the kwargs.[0m
[1m        proxies = merge_setting(proxies, self.proxies)[0m
[1m        stream = merge_setting(stream, self.stream)[0m
[1m        verify = merge_setting(verify, self.verify)[0m
[1m        cert = merge_setting(cert, self.cert)[0m
[1m    [0m
[1m        # Send the request.[0m
[1m        send_kwargs = {[0m
[1m            'stream': stream,[0m
[1m            'timeout': timeout,[0m
[1m            'verify': verify,[0m
[1m            'cert': cert,[0m
[1m            'proxies': proxies,[0m
[1m            'allow_redirects': allow_redirects,[0m
[1m        }[0m
[1m>       resp = self.send(prep, **send_kwargs)[0m

requests/sessions.py:357: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x26a5950>
request = <PreparedRequest [GET]>
kwargs = {'cert': None, 'proxies': OrderedDict(), 'stream': False, 'timeout': None, ...}
allow_redirects = True, stream = False, timeout = None, verify = True
cert = None, proxies = OrderedDict(), hooks = {'response': []}

[1m    def send(self, request, **kwargs):[0m
[1m        """Send a given PreparedRequest."""[0m
[1m        # Set defaults that the hooks can utilize to ensure they always have[0m
[1m        # the correct parameters to reproduce the previous request.[0m
[1m        kwargs.setdefault('stream', self.stream)[0m
[1m        kwargs.setdefault('verify', self.verify)[0m
[1m        kwargs.setdefault('cert', self.cert)[0m
[1m        kwargs.setdefault('proxies', self.proxies)[0m
[1m    [0m
[1m        # It's possible that users might accidentally send a Request object.[0m
[1m        # Guard against that specific failure case.[0m
[1m        if not isinstance(request, PreparedRequest):[0m
[1m            raise ValueError('You can only send PreparedRequests.')[0m
[1m    [0m
[1m        # Set up variables needed for resolve_redirects and dispatching of[0m
[1m        # hooks[0m
[1m        allow_redirects = kwargs.pop('allow_redirects', True)[0m
[1m        stream = kwargs.get('stream')[0m
[1m        timeout = kwargs.get('timeout')[0m
[1m        verify = kwargs.get('verify')[0m
[1m        cert = kwargs.get('cert')[0m
[1m        proxies = kwargs.get('proxies')[0m
[1m        hooks = request.hooks[0m
[1m    [0m
[1m        # Get the appropriate adapter to use[0m
[1m        adapter = self.get_adapter(url=request.url)[0m
[1m    [0m
[1m        # Start time (approximately) of the request[0m
[1m        start = datetime.utcnow()[0m
[1m        # Send the request[0m
[1m>       r = adapter.send(request, **kwargs)[0m

requests/sessions.py:460: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.adapters.HTTPAdapter object at 0x26a5c10>
request = <PreparedRequest [GET]>, stream = False, timeout = None, verify = True
cert = None, proxies = OrderedDict()

[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):[0m
[1m        """Sends PreparedRequest object. Returns Response object.[0m
[1m    [0m
[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.[0m
[1m            :param stream: (optional) Whether to stream the request content.[0m
[1m            :param timeout: (optional) The timeout on the request.[0m
[1m            :param verify: (optional) Whether to verify SSL certificates.[0m
[1m            :param vert: (optional) Any user-provided SSL certificate to be trusted.[0m
[1m            :param proxies: (optional) The proxies dictionary to apply to the request.[0m
[1m            """[0m
[1m    [0m
[1m        conn = self.get_connection(request.url, proxies)[0m
[1m    [0m
[1m        self.cert_verify(conn, request.url, verify, cert)[0m
[1m        url = self.request_url(request, proxies)[0m
[1m        self.add_headers(request)[0m
[1m    [0m
[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)[0m
[1m    [0m
[1m        if stream:[0m
[1m            timeout = Timeout(connect=timeout)[0m
[1m        else:[0m
[1m>           timeout = Timeout(connect=timeout, read=timeout)[0m
[1m[31mE           TypeError: Timeout does not take keyword arguments[0m

requests/adapters.py:305: TypeError
________________ RequestsTestCase.test_cookie_removed_on_expire ________________

self = <test_requests.RequestsTestCase testMethod=test_cookie_removed_on_expire>

[1m    def test_cookie_removed_on_expire(self):[0m
[1m        s = requests.session()[0m
[1m>       s.get(httpbin('cookies/set?foo=bar'))[0m

test_requests.py:151: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x276b850>
url = 'http://httpbin.org/cookies/set?foo=bar'
kwargs = {'allow_redirects': True}

[1m    def get(self, url, **kwargs):[0m
[1m        """Sends a GET request. Returns :class:`Response` object.[0m
[1m    [0m
[1m            :param url: URL for the new :class:`Request` object.[0m
[1m            :param \*\*kwargs: Optional arguments that ``request`` takes.[0m
[1m            """[0m
[1m    [0m
[1m        kwargs.setdefault('allow_redirects', True)[0m
[1m>       return self.request('GET', url, **kwargs)[0m

requests/sessions.py:369: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x276b850>, method = 'GET'
url = 'http://httpbin.org/cookies/set?foo=bar', params = None, data = None
headers = None, cookies = None, files = None, auth = None, timeout = None
allow_redirects = True, proxies = OrderedDict(), hooks = None, stream = False
verify = True, cert = None

[1m    def request(self, method, url,[0m
[1m        params=None,[0m
[1m        data=None,[0m
[1m        headers=None,[0m
[1m        cookies=None,[0m
[1m        files=None,[0m
[1m        auth=None,[0m
[1m        timeout=None,[0m
[1m        allow_redirects=True,[0m
[1m        proxies=None,[0m
[1m        hooks=None,[0m
[1m        stream=None,[0m
[1m        verify=None,[0m
[1m        cert=None):[0m
[1m        """Constructs a :class:`Request <Request>`, prepares it and sends it.[0m
[1m            Returns :class:`Response <Response>` object.[0m
[1m    [0m
[1m            :param method: method for the new :class:`Request` object.[0m
[1m            :param url: URL for the new :class:`Request` object.[0m
[1m            :param params: (optional) Dictionary or bytes to be sent in the query[0m
[1m                string for the :class:`Request`.[0m
[1m            :param data: (optional) Dictionary or bytes to send in the body of the[0m
[1m                :class:`Request`.[0m
[1m            :param headers: (optional) Dictionary of HTTP Headers to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param cookies: (optional) Dict or CookieJar object to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param files: (optional) Dictionary of 'filename': file-like-objects[0m
[1m                for multipart encoding upload.[0m
[1m            :param auth: (optional) Auth tuple or callable to enable[0m
[1m                Basic/Digest/Custom HTTP Auth.[0m
[1m            :param timeout: (optional) Float describing the timeout of the[0m
[1m                request.[0m
[1m            :param allow_redirects: (optional) Boolean. Set to True by default.[0m
[1m            :param proxies: (optional) Dictionary mapping protocol to the URL of[0m
[1m                the proxy.[0m
[1m            :param stream: (optional) whether to immediately download the response[0m
[1m                content. Defaults to ``False``.[0m
[1m            :param verify: (optional) if ``True``, the SSL cert will be verified.[0m
[1m                A CA_BUNDLE path can also be provided.[0m
[1m            :param cert: (optional) if String, path to ssl client cert file (.pem).[0m
[1m                If Tuple, ('cert', 'key') pair.[0m
[1m            """[0m
[1m        # Create the Request.[0m
[1m        req = Request([0m
[1m            method = method.upper(),[0m
[1m            url = url,[0m
[1m            headers = headers,[0m
[1m            files = files,[0m
[1m            data = data or {},[0m
[1m            params = params or {},[0m
[1m            auth = auth,[0m
[1m            cookies = cookies,[0m
[1m            hooks = hooks,[0m
[1m        )[0m
[1m        prep = self.prepare_request(req)[0m
[1m    [0m
[1m        proxies = proxies or {}[0m
[1m    [0m
[1m        # Gather clues from the surrounding environment.[0m
[1m        if self.trust_env:[0m
[1m            # Set environment's proxies.[0m
[1m            env_proxies = get_environ_proxies(url) or {}[0m
[1m            for (k, v) in env_proxies.items():[0m
[1m                proxies.setdefault(k, v)[0m
[1m    [0m
[1m            # Look for configuration.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('REQUESTS_CA_BUNDLE')[0m
[1m    [0m
[1m            # Curl compatibility.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('CURL_CA_BUNDLE')[0m
[1m    [0m
[1m        # Merge all the kwargs.[0m
[1m        proxies = merge_setting(proxies, self.proxies)[0m
[1m        stream = merge_setting(stream, self.stream)[0m
[1m        verify = merge_setting(verify, self.verify)[0m
[1m        cert = merge_setting(cert, self.cert)[0m
[1m    [0m
[1m        # Send the request.[0m
[1m        send_kwargs = {[0m
[1m            'stream': stream,[0m
[1m            'timeout': timeout,[0m
[1m            'verify': verify,[0m
[1m            'cert': cert,[0m
[1m            'proxies': proxies,[0m
[1m            'allow_redirects': allow_redirects,[0m
[1m        }[0m
[1m>       resp = self.send(prep, **send_kwargs)[0m

requests/sessions.py:357: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x276b850>
request = <PreparedRequest [GET]>
kwargs = {'cert': None, 'proxies': OrderedDict(), 'stream': False, 'timeout': None, ...}
allow_redirects = True, stream = False, timeout = None, verify = True
cert = None, proxies = OrderedDict(), hooks = {'response': []}

[1m    def send(self, request, **kwargs):[0m
[1m        """Send a given PreparedRequest."""[0m
[1m        # Set defaults that the hooks can utilize to ensure they always have[0m
[1m        # the correct parameters to reproduce the previous request.[0m
[1m        kwargs.setdefault('stream', self.stream)[0m
[1m        kwargs.setdefault('verify', self.verify)[0m
[1m        kwargs.setdefault('cert', self.cert)[0m
[1m        kwargs.setdefault('proxies', self.proxies)[0m
[1m    [0m
[1m        # It's possible that users might accidentally send a Request object.[0m
[1m        # Guard against that specific failure case.[0m
[1m        if not isinstance(request, PreparedRequest):[0m
[1m            raise ValueError('You can only send PreparedRequests.')[0m
[1m    [0m
[1m        # Set up variables needed for resolve_redirects and dispatching of[0m
[1m        # hooks[0m
[1m        allow_redirects = kwargs.pop('allow_redirects', True)[0m
[1m        stream = kwargs.get('stream')[0m
[1m        timeout = kwargs.get('timeout')[0m
[1m        verify = kwargs.get('verify')[0m
[1m        cert = kwargs.get('cert')[0m
[1m        proxies = kwargs.get('proxies')[0m
[1m        hooks = request.hooks[0m
[1m    [0m
[1m        # Get the appropriate adapter to use[0m
[1m        adapter = self.get_adapter(url=request.url)[0m
[1m    [0m
[1m        # Start time (approximately) of the request[0m
[1m        start = datetime.utcnow()[0m
[1m        # Send the request[0m
[1m>       r = adapter.send(request, **kwargs)[0m

requests/sessions.py:460: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.adapters.HTTPAdapter object at 0x276bd10>
request = <PreparedRequest [GET]>, stream = False, timeout = None, verify = True
cert = None, proxies = OrderedDict()

[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):[0m
[1m        """Sends PreparedRequest object. Returns Response object.[0m
[1m    [0m
[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.[0m
[1m            :param stream: (optional) Whether to stream the request content.[0m
[1m            :param timeout: (optional) The timeout on the request.[0m
[1m            :param verify: (optional) Whether to verify SSL certificates.[0m
[1m            :param vert: (optional) Any user-provided SSL certificate to be trusted.[0m
[1m            :param proxies: (optional) The proxies dictionary to apply to the request.[0m
[1m            """[0m
[1m    [0m
[1m        conn = self.get_connection(request.url, proxies)[0m
[1m    [0m
[1m        self.cert_verify(conn, request.url, verify, cert)[0m
[1m        url = self.request_url(request, proxies)[0m
[1m        self.add_headers(request)[0m
[1m    [0m
[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)[0m
[1m    [0m
[1m        if stream:[0m
[1m            timeout = Timeout(connect=timeout)[0m
[1m        else:[0m
[1m>           timeout = Timeout(connect=timeout, read=timeout)[0m
[1m[31mE           TypeError: Timeout does not take keyword arguments[0m

requests/adapters.py:305: TypeError
________________ RequestsTestCase.test_cookie_sent_on_redirect _________________

self = <test_requests.RequestsTestCase testMethod=test_cookie_sent_on_redirect>

[1m    def test_cookie_sent_on_redirect(self):[0m
[1m        s = requests.session()[0m
[1m>       s.get(httpbin('cookies/set?foo=bar'))[0m

test_requests.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x2774710>
url = 'http://httpbin.org/cookies/set?foo=bar'
kwargs = {'allow_redirects': True}

[1m    def get(self, url, **kwargs):[0m
[1m        """Sends a GET request. Returns :class:`Response` object.[0m
[1m    [0m
[1m            :param url: URL for the new :class:`Request` object.[0m
[1m            :param \*\*kwargs: Optional arguments that ``request`` takes.[0m
[1m            """[0m
[1m    [0m
[1m        kwargs.setdefault('allow_redirects', True)[0m
[1m>       return self.request('GET', url, **kwargs)[0m

requests/sessions.py:369: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x2774710>, method = 'GET'
url = 'http://httpbin.org/cookies/set?foo=bar', params = None, data = None
headers = None, cookies = None, files = None, auth = None, timeout = None
allow_redirects = True, proxies = OrderedDict(), hooks = None, stream = False
verify = True, cert = None

[1m    def request(self, method, url,[0m
[1m        params=None,[0m
[1m        data=None,[0m
[1m        headers=None,[0m
[1m        cookies=None,[0m
[1m        files=None,[0m
[1m        auth=None,[0m
[1m        timeout=None,[0m
[1m        allow_redirects=True,[0m
[1m        proxies=None,[0m
[1m        hooks=None,[0m
[1m        stream=None,[0m
[1m        verify=None,[0m
[1m        cert=None):[0m
[1m        """Constructs a :class:`Request <Request>`, prepares it and sends it.[0m
[1m            Returns :class:`Response <Response>` object.[0m
[1m    [0m
[1m            :param method: method for the new :class:`Request` object.[0m
[1m            :param url: URL for the new :class:`Request` object.[0m
[1m            :param params: (optional) Dictionary or bytes to be sent in the query[0m
[1m                string for the :class:`Request`.[0m
[1m            :param data: (optional) Dictionary or bytes to send in the body of the[0m
[1m                :class:`Request`.[0m
[1m            :param headers: (optional) Dictionary of HTTP Headers to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param cookies: (optional) Dict or CookieJar object to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param files: (optional) Dictionary of 'filename': file-like-objects[0m
[1m                for multipart encoding upload.[0m
[1m            :param auth: (optional) Auth tuple or callable to enable[0m
[1m                Basic/Digest/Custom HTTP Auth.[0m
[1m            :param timeout: (optional) Float describing the timeout of the[0m
[1m                request.[0m
[1m            :param allow_redirects: (optional) Boolean. Set to True by default.[0m
[1m            :param proxies: (optional) Dictionary mapping protocol to the URL of[0m
[1m                the proxy.[0m
[1m            :param stream: (optional) whether to immediately download the response[0m
[1m                content. Defaults to ``False``.[0m
[1m            :param verify: (optional) if ``True``, the SSL cert will be verified.[0m
[1m                A CA_BUNDLE path can also be provided.[0m
[1m            :param cert: (optional) if String, path to ssl client cert file (.pem).[0m
[1m                If Tuple, ('cert', 'key') pair.[0m
[1m            """[0m
[1m        # Create the Request.[0m
[1m        req = Request([0m
[1m            method = method.upper(),[0m
[1m            url = url,[0m
[1m            headers = headers,[0m
[1m            files = files,[0m
[1m            data = data or {},[0m
[1m            params = params or {},[0m
[1m            auth = auth,[0m
[1m            cookies = cookies,[0m
[1m            hooks = hooks,[0m
[1m        )[0m
[1m        prep = self.prepare_request(req)[0m
[1m    [0m
[1m        proxies = proxies or {}[0m
[1m    [0m
[1m        # Gather clues from the surrounding environment.[0m
[1m        if self.trust_env:[0m
[1m            # Set environment's proxies.[0m
[1m            env_proxies = get_environ_proxies(url) or {}[0m
[1m            for (k, v) in env_proxies.items():[0m
[1m                proxies.setdefault(k, v)[0m
[1m    [0m
[1m            # Look for configuration.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('REQUESTS_CA_BUNDLE')[0m
[1m    [0m
[1m            # Curl compatibility.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('CURL_CA_BUNDLE')[0m
[1m    [0m
[1m        # Merge all the kwargs.[0m
[1m        proxies = merge_setting(proxies, self.proxies)[0m
[1m        stream = merge_setting(stream, self.stream)[0m
[1m        verify = merge_setting(verify, self.verify)[0m
[1m        cert = merge_setting(cert, self.cert)[0m
[1m    [0m
[1m        # Send the request.[0m
[1m        send_kwargs = {[0m
[1m            'stream': stream,[0m
[1m            'timeout': timeout,[0m
[1m            'verify': verify,[0m
[1m            'cert': cert,[0m
[1m            'proxies': proxies,[0m
[1m            'allow_redirects': allow_redirects,[0m
[1m        }[0m
[1m>       resp = self.send(prep, **send_kwargs)[0m

requests/sessions.py:357: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x2774710>
request = <PreparedRequest [GET]>
kwargs = {'cert': None, 'proxies': OrderedDict(), 'stream': False, 'timeout': None, ...}
allow_redirects = True, stream = False, timeout = None, verify = True
cert = None, proxies = OrderedDict(), hooks = {'response': []}

[1m    def send(self, request, **kwargs):[0m
[1m        """Send a given PreparedRequest."""[0m
[1m        # Set defaults that the hooks can utilize to ensure they always have[0m
[1m        # the correct parameters to reproduce the previous request.[0m
[1m        kwargs.setdefault('stream', self.stream)[0m
[1m        kwargs.setdefault('verify', self.verify)[0m
[1m        kwargs.setdefault('cert', self.cert)[0m
[1m        kwargs.setdefault('proxies', self.proxies)[0m
[1m    [0m
[1m        # It's possible that users might accidentally send a Request object.[0m
[1m        # Guard against that specific failure case.[0m
[1m        if not isinstance(request, PreparedRequest):[0m
[1m            raise ValueError('You can only send PreparedRequests.')[0m
[1m    [0m
[1m        # Set up variables needed for resolve_redirects and dispatching of[0m
[1m        # hooks[0m
[1m        allow_redirects = kwargs.pop('allow_redirects', True)[0m
[1m        stream = kwargs.get('stream')[0m
[1m        timeout = kwargs.get('timeout')[0m
[1m        verify = kwargs.get('verify')[0m
[1m        cert = kwargs.get('cert')[0m
[1m        proxies = kwargs.get('proxies')[0m
[1m        hooks = request.hooks[0m
[1m    [0m
[1m        # Get the appropriate adapter to use[0m
[1m        adapter = self.get_adapter(url=request.url)[0m
[1m    [0m
[1m        # Start time (approximately) of the request[0m
[1m        start = datetime.utcnow()[0m
[1m        # Send the request[0m
[1m>       r = adapter.send(request, **kwargs)[0m

requests/sessions.py:460: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.adapters.HTTPAdapter object at 0x2774ad0>
request = <PreparedRequest [GET]>, stream = False, timeout = None, verify = True
cert = None, proxies = OrderedDict()

[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):[0m
[1m        """Sends PreparedRequest object. Returns Response object.[0m
[1m    [0m
[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.[0m
[1m            :param stream: (optional) Whether to stream the request content.[0m
[1m            :param timeout: (optional) The timeout on the request.[0m
[1m            :param verify: (optional) Whether to verify SSL certificates.[0m
[1m            :param vert: (optional) Any user-provided SSL certificate to be trusted.[0m
[1m            :param proxies: (optional) The proxies dictionary to apply to the request.[0m
[1m            """[0m
[1m    [0m
[1m        conn = self.get_connection(request.url, proxies)[0m
[1m    [0m
[1m        self.cert_verify(conn, request.url, verify, cert)[0m
[1m        url = self.request_url(request, proxies)[0m
[1m        self.add_headers(request)[0m
[1m    [0m
[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)[0m
[1m    [0m
[1m        if stream:[0m
[1m            timeout = Timeout(connect=timeout)[0m
[1m        else:[0m
[1m>           timeout = Timeout(connect=timeout, read=timeout)[0m
[1m[31mE           TypeError: Timeout does not take keyword arguments[0m

requests/adapters.py:305: TypeError
__________________ RequestsTestCase.test_custom_content_type ___________________

self = <test_requests.RequestsTestCase testMethod=test_custom_content_type>

[1m    def test_custom_content_type(self):[0m
[1m        r = requests.post(httpbin('post'),[0m
[1m                          data={'stuff': json.dumps({'a': 123})},[0m
[1m                          files={'file1': ('test_requests.py', open(__file__, 'rb')),[0m
[1m                                 'file2': ('test_requests', open(__file__, 'rb'),[0m
[1m>                                          'text/py-content-type')})[0m

test_requests.py:441: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

url = 'http://httpbin.org/post', data = {'stuff': '{"a": 123}'}
kwargs = {'files': {'file1': ('test_requests.py', <open file '/home/travis/build/kennethreitz/requests/test_requests.py', mode ...en file '/home/travis/build/kennethreitz/requests/test_requests.py', mode 'rb' at 0x2a36540>, 'text/py-content-type')}}

[1m    def post(url, data=None, **kwargs):[0m
[1m        """Sends a POST request. Returns :class:`Response` object.[0m
[1m    [0m
[1m        :param url: URL for the new :class:`Request` object.[0m
[1m        :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.[0m
[1m        :param \*\*kwargs: Optional arguments that ``request`` takes.[0m
[1m        """[0m
[1m    [0m
[1m>       return request('post', url, data=data, **kwargs)[0m

requests/api.py:88: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

method = 'post', url = 'http://httpbin.org/post'
kwargs = {'data': {'stuff': '{"a": 123}'}, 'files': {'file1': ('test_requests.py', <open file '/home/travis/build/kennethreitz/...en file '/home/travis/build/kennethreitz/requests/test_requests.py', mode 'rb' at 0x2a36540>, 'text/py-content-type')}}
session = <requests.sessions.Session object at 0x2794a90>

[1m    def request(method, url, **kwargs):[0m
[1m        """Constructs and sends a :class:`Request <Request>`.[0m
[1m        Returns :class:`Response <Response>` object.[0m
[1m    [0m
[1m        :param method: method for the new :class:`Request` object.[0m
[1m        :param url: URL for the new :class:`Request` object.[0m
[1m        :param params: (optional) Dictionary or bytes to be sent in the query string for the :class:`Request`.[0m
[1m        :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.[0m
[1m        :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.[0m
[1m        :param cookies: (optional) Dict or CookieJar object to send with the :class:`Request`.[0m
[1m        :param files: (optional) Dictionary of 'name': file-like-objects (or {'name': ('filename', fileobj)}) for multipart encoding upload.[0m
[1m        :param auth: (optional) Auth tuple to enable Basic/Digest/Custom HTTP Auth.[0m
[1m        :param timeout: (optional) Float describing the timeout of the request.[0m
[1m        :param allow_redirects: (optional) Boolean. Set to True if POST/PUT/DELETE redirect following is allowed.[0m
[1m        :param proxies: (optional) Dictionary mapping protocol to the URL of the proxy.[0m
[1m        :param verify: (optional) if ``True``, the SSL cert will be verified. A CA_BUNDLE path can also be provided.[0m
[1m        :param stream: (optional) if ``False``, the response content will be immediately downloaded.[0m
[1m        :param cert: (optional) if String, path to ssl client cert file (.pem). If Tuple, ('cert', 'key') pair.[0m
[1m    [0m
[1m        Usage::[0m
[1m    [0m
[1m          >>> import requests[0m
[1m          >>> req = requests.request('GET', 'http://httpbin.org/get')[0m
[1m          <Response [200]>[0m
[1m        """[0m
[1m    [0m
[1m        session = sessions.Session()[0m
[1m>       return session.request(method=method, url=url, **kwargs)[0m

requests/api.py:44: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x2794a90>, method = 'post'
url = 'http://httpbin.org/post', params = None, data = {'stuff': '{"a": 123}'}
headers = None, cookies = None
files = {'file1': ('test_requests.py', <open file '/home/travis/build/kennethreitz/requests/test_requests.py', mode 'rb' at 0x...pen file '/home/travis/build/kennethreitz/requests/test_requests.py', mode 'rb' at 0x2a36540>, 'text/py-content-type')}
auth = None, timeout = None, allow_redirects = True, proxies = OrderedDict()
hooks = None, stream = False, verify = True, cert = None

[1m    def request(self, method, url,[0m
[1m        params=None,[0m
[1m        data=None,[0m
[1m        headers=None,[0m
[1m        cookies=None,[0m
[1m        files=None,[0m
[1m        auth=None,[0m
[1m        timeout=None,[0m
[1m        allow_redirects=True,[0m
[1m        proxies=None,[0m
[1m        hooks=None,[0m
[1m        stream=None,[0m
[1m        verify=None,[0m
[1m        cert=None):[0m
[1m        """Constructs a :class:`Request <Request>`, prepares it and sends it.[0m
[1m            Returns :class:`Response <Response>` object.[0m
[1m    [0m
[1m            :param method: method for the new :class:`Request` object.[0m
[1m            :param url: URL for the new :class:`Request` object.[0m
[1m            :param params: (optional) Dictionary or bytes to be sent in the query[0m
[1m                string for the :class:`Request`.[0m
[1m            :param data: (optional) Dictionary or bytes to send in the body of the[0m
[1m                :class:`Request`.[0m
[1m            :param headers: (optional) Dictionary of HTTP Headers to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param cookies: (optional) Dict or CookieJar object to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param files: (optional) Dictionary of 'filename': file-like-objects[0m
[1m                for multipart encoding upload.[0m
[1m            :param auth: (optional) Auth tuple or callable to enable[0m
[1m                Basic/Digest/Custom HTTP Auth.[0m
[1m            :param timeout: (optional) Float describing the timeout of the[0m
[1m                request.[0m
[1m            :param allow_redirects: (optional) Boolean. Set to True by default.[0m
[1m            :param proxies: (optional) Dictionary mapping protocol to the URL of[0m
[1m                the proxy.[0m
[1m            :param stream: (optional) whether to immediately download the response[0m
[1m                content. Defaults to ``False``.[0m
[1m            :param verify: (optional) if ``True``, the SSL cert will be verified.[0m
[1m                A CA_BUNDLE path can also be provided.[0m
[1m            :param cert: (optional) if String, path to ssl client cert file (.pem).[0m
[1m                If Tuple, ('cert', 'key') pair.[0m
[1m            """[0m
[1m        # Create the Request.[0m
[1m        req = Request([0m
[1m            method = method.upper(),[0m
[1m            url = url,[0m
[1m            headers = headers,[0m
[1m            files = files,[0m
[1m            data = data or {},[0m
[1m            params = params or {},[0m
[1m            auth = auth,[0m
[1m            cookies = cookies,[0m
[1m            hooks = hooks,[0m
[1m        )[0m
[1m        prep = self.prepare_request(req)[0m
[1m    [0m
[1m        proxies = proxies or {}[0m
[1m    [0m
[1m        # Gather clues from the surrounding environment.[0m
[1m        if self.trust_env:[0m
[1m            # Set environment's proxies.[0m
[1m            env_proxies = get_environ_proxies(url) or {}[0m
[1m            for (k, v) in env_proxies.items():[0m
[1m                proxies.setdefault(k, v)[0m
[1m    [0m
[1m            # Look for configuration.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('REQUESTS_CA_BUNDLE')[0m
[1m    [0m
[1m            # Curl compatibility.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('CURL_CA_BUNDLE')[0m
[1m    [0m
[1m        # Merge all the kwargs.[0m
[1m        proxies = merge_setting(proxies, self.proxies)[0m
[1m        stream = merge_setting(stream, self.stream)[0m
[1m        verify = merge_setting(verify, self.verify)[0m
[1m        cert = merge_setting(cert, self.cert)[0m
[1m    [0m
[1m        # Send the request.[0m
[1m        send_kwargs = {[0m
[1m            'stream': stream,[0m
[1m            'timeout': timeout,[0m
[1m            'verify': verify,[0m
[1m            'cert': cert,[0m
[1m            'proxies': proxies,[0m
[1m            'allow_redirects': allow_redirects,[0m
[1m        }[0m
[1m>       resp = self.send(prep, **send_kwargs)[0m

requests/sessions.py:357: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x2794a90>
request = <PreparedRequest [POST]>
kwargs = {'cert': None, 'proxies': OrderedDict(), 'stream': False, 'timeout': None, ...}
allow_redirects = True, stream = False, timeout = None, verify = True
cert = None, proxies = OrderedDict(), hooks = {'response': []}

[1m    def send(self, request, **kwargs):[0m
[1m        """Send a given PreparedRequest."""[0m
[1m        # Set defaults that the hooks can utilize to ensure they always have[0m
[1m        # the correct parameters to reproduce the previous request.[0m
[1m        kwargs.setdefault('stream', self.stream)[0m
[1m        kwargs.setdefault('verify', self.verify)[0m
[1m        kwargs.setdefault('cert', self.cert)[0m
[1m        kwargs.setdefault('proxies', self.proxies)[0m
[1m    [0m
[1m        # It's possible that users might accidentally send a Request object.[0m
[1m        # Guard against that specific failure case.[0m
[1m        if not isinstance(request, PreparedRequest):[0m
[1m            raise ValueError('You can only send PreparedRequests.')[0m
[1m    [0m
[1m        # Set up variables needed for resolve_redirects and dispatching of[0m
[1m        # hooks[0m
[1m        allow_redirects = kwargs.pop('allow_redirects', True)[0m
[1m        stream = kwargs.get('stream')[0m
[1m        timeout = kwargs.get('timeout')[0m
[1m        verify = kwargs.get('verify')[0m
[1m        cert = kwargs.get('cert')[0m
[1m        proxies = kwargs.get('proxies')[0m
[1m        hooks = request.hooks[0m
[1m    [0m
[1m        # Get the appropriate adapter to use[0m
[1m        adapter = self.get_adapter(url=request.url)[0m
[1m    [0m
[1m        # Start time (approximately) of the request[0m
[1m        start = datetime.utcnow()[0m
[1m        # Send the request[0m
[1m>       r = adapter.send(request, **kwargs)[0m

requests/sessions.py:460: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.adapters.HTTPAdapter object at 0x2794910>
request = <PreparedRequest [POST]>, stream = False, timeout = None
verify = True, cert = None, proxies = OrderedDict()

[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):[0m
[1m        """Sends PreparedRequest object. Returns Response object.[0m
[1m    [0m
[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.[0m
[1m            :param stream: (optional) Whether to stream the request content.[0m
[1m            :param timeout: (optional) The timeout on the request.[0m
[1m            :param verify: (optional) Whether to verify SSL certificates.[0m
[1m            :param vert: (optional) Any user-provided SSL certificate to be trusted.[0m
[1m            :param proxies: (optional) The proxies dictionary to apply to the request.[0m
[1m            """[0m
[1m    [0m
[1m        conn = self.get_connection(request.url, proxies)[0m
[1m    [0m
[1m        self.cert_verify(conn, request.url, verify, cert)[0m
[1m        url = self.request_url(request, proxies)[0m
[1m        self.add_headers(request)[0m
[1m    [0m
[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)[0m
[1m    [0m
[1m        if stream:[0m
[1m            timeout = Timeout(connect=timeout)[0m
[1m        else:[0m
[1m>           timeout = Timeout(connect=timeout, read=timeout)[0m
[1m[31mE           TypeError: Timeout does not take keyword arguments[0m

requests/adapters.py:305: TypeError
____________________ RequestsTestCase.test_decompress_gzip _____________________

self = <test_requests.RequestsTestCase testMethod=test_decompress_gzip>

[1m    def test_decompress_gzip(self):[0m
[1m>       r = requests.get(httpbin('gzip'))[0m

test_requests.py:377: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

url = 'http://httpbin.org/gzip', kwargs = {'allow_redirects': True}

[1m    def get(url, **kwargs):[0m
[1m        """Sends a GET request. Returns :class:`Response` object.[0m
[1m    [0m
[1m        :param url: URL for the new :class:`Request` object.[0m
[1m        :param \*\*kwargs: Optional arguments that ``request`` takes.[0m
[1m        """[0m
[1m    [0m
[1m        kwargs.setdefault('allow_redirects', True)[0m
[1m>       return request('get', url, **kwargs)[0m

requests/api.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

method = 'get', url = 'http://httpbin.org/gzip'
kwargs = {'allow_redirects': True}
session = <requests.sessions.Session object at 0x2779050>

[1m    def request(method, url, **kwargs):[0m
[1m        """Constructs and sends a :class:`Request <Request>`.[0m
[1m        Returns :class:`Response <Response>` object.[0m
[1m    [0m
[1m        :param method: method for the new :class:`Request` object.[0m
[1m        :param url: URL for the new :class:`Request` object.[0m
[1m        :param params: (optional) Dictionary or bytes to be sent in the query string for the :class:`Request`.[0m
[1m        :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.[0m
[1m        :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.[0m
[1m        :param cookies: (optional) Dict or CookieJar object to send with the :class:`Request`.[0m
[1m        :param files: (optional) Dictionary of 'name': file-like-objects (or {'name': ('filename', fileobj)}) for multipart encoding upload.[0m
[1m        :param auth: (optional) Auth tuple to enable Basic/Digest/Custom HTTP Auth.[0m
[1m        :param timeout: (optional) Float describing the timeout of the request.[0m
[1m        :param allow_redirects: (optional) Boolean. Set to True if POST/PUT/DELETE redirect following is allowed.[0m
[1m        :param proxies: (optional) Dictionary mapping protocol to the URL of the proxy.[0m
[1m        :param verify: (optional) if ``True``, the SSL cert will be verified. A CA_BUNDLE path can also be provided.[0m
[1m        :param stream: (optional) if ``False``, the response content will be immediately downloaded.[0m
[1m        :param cert: (optional) if String, path to ssl client cert file (.pem). If Tuple, ('cert', 'key') pair.[0m
[1m    [0m
[1m        Usage::[0m
[1m    [0m
[1m          >>> import requests[0m
[1m          >>> req = requests.request('GET', 'http://httpbin.org/get')[0m
[1m          <Response [200]>[0m
[1m        """[0m
[1m    [0m
[1m        session = sessions.Session()[0m
[1m>       return session.request(method=method, url=url, **kwargs)[0m

requests/api.py:44: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x2779050>, method = 'get'
url = 'http://httpbin.org/gzip', params = None, data = None, headers = None
cookies = None, files = None, auth = None, timeout = None
allow_redirects = True, proxies = OrderedDict(), hooks = None, stream = False
verify = True, cert = None

[1m    def request(self, method, url,[0m
[1m        params=None,[0m
[1m        data=None,[0m
[1m        headers=None,[0m
[1m        cookies=None,[0m
[1m        files=None,[0m
[1m        auth=None,[0m
[1m        timeout=None,[0m
[1m        allow_redirects=True,[0m
[1m        proxies=None,[0m
[1m        hooks=None,[0m
[1m        stream=None,[0m
[1m        verify=None,[0m
[1m        cert=None):[0m
[1m        """Constructs a :class:`Request <Request>`, prepares it and sends it.[0m
[1m            Returns :class:`Response <Response>` object.[0m
[1m    [0m
[1m            :param method: method for the new :class:`Request` object.[0m
[1m            :param url: URL for the new :class:`Request` object.[0m
[1m            :param params: (optional) Dictionary or bytes to be sent in the query[0m
[1m                string for the :class:`Request`.[0m
[1m            :param data: (optional) Dictionary or bytes to send in the body of the[0m
[1m                :class:`Request`.[0m
[1m            :param headers: (optional) Dictionary of HTTP Headers to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param cookies: (optional) Dict or CookieJar object to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param files: (optional) Dictionary of 'filename': file-like-objects[0m
[1m                for multipart encoding upload.[0m
[1m            :param auth: (optional) Auth tuple or callable to enable[0m
[1m                Basic/Digest/Custom HTTP Auth.[0m
[1m            :param timeout: (optional) Float describing the timeout of the[0m
[1m                request.[0m
[1m            :param allow_redirects: (optional) Boolean. Set to True by default.[0m
[1m            :param proxies: (optional) Dictionary mapping protocol to the URL of[0m
[1m                the proxy.[0m
[1m            :param stream: (optional) whether to immediately download the response[0m
[1m                content. Defaults to ``False``.[0m
[1m            :param verify: (optional) if ``True``, the SSL cert will be verified.[0m
[1m                A CA_BUNDLE path can also be provided.[0m
[1m            :param cert: (optional) if String, path to ssl client cert file (.pem).[0m
[1m                If Tuple, ('cert', 'key') pair.[0m
[1m            """[0m
[1m        # Create the Request.[0m
[1m        req = Request([0m
[1m            method = method.upper(),[0m
[1m            url = url,[0m
[1m            headers = headers,[0m
[1m            files = files,[0m
[1m            data = data or {},[0m
[1m            params = params or {},[0m
[1m            auth = auth,[0m
[1m            cookies = cookies,[0m
[1m            hooks = hooks,[0m
[1m        )[0m
[1m        prep = self.prepare_request(req)[0m
[1m    [0m
[1m        proxies = proxies or {}[0m
[1m    [0m
[1m        # Gather clues from the surrounding environment.[0m
[1m        if self.trust_env:[0m
[1m            # Set environment's proxies.[0m
[1m            env_proxies = get_environ_proxies(url) or {}[0m
[1m            for (k, v) in env_proxies.items():[0m
[1m                proxies.setdefault(k, v)[0m
[1m    [0m
[1m            # Look for configuration.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('REQUESTS_CA_BUNDLE')[0m
[1m    [0m
[1m            # Curl compatibility.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('CURL_CA_BUNDLE')[0m
[1m    [0m
[1m        # Merge all the kwargs.[0m
[1m        proxies = merge_setting(proxies, self.proxies)[0m
[1m        stream = merge_setting(stream, self.stream)[0m
[1m        verify = merge_setting(verify, self.verify)[0m
[1m        cert = merge_setting(cert, self.cert)[0m
[1m    [0m
[1m        # Send the request.[0m
[1m        send_kwargs = {[0m
[1m            'stream': stream,[0m
[1m            'timeout': timeout,[0m
[1m            'verify': verify,[0m
[1m            'cert': cert,[0m
[1m            'proxies': proxies,[0m
[1m            'allow_redirects': allow_redirects,[0m
[1m        }[0m
[1m>       resp = self.send(prep, **send_kwargs)[0m

requests/sessions.py:357: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x2779050>
request = <PreparedRequest [GET]>
kwargs = {'cert': None, 'proxies': OrderedDict(), 'stream': False, 'timeout': None, ...}
allow_redirects = True, stream = False, timeout = None, verify = True
cert = None, proxies = OrderedDict(), hooks = {'response': []}

[1m    def send(self, request, **kwargs):[0m
[1m        """Send a given PreparedRequest."""[0m
[1m        # Set defaults that the hooks can utilize to ensure they always have[0m
[1m        # the correct parameters to reproduce the previous request.[0m
[1m        kwargs.setdefault('stream', self.stream)[0m
[1m        kwargs.setdefault('verify', self.verify)[0m
[1m        kwargs.setdefault('cert', self.cert)[0m
[1m        kwargs.setdefault('proxies', self.proxies)[0m
[1m    [0m
[1m        # It's possible that users might accidentally send a Request object.[0m
[1m        # Guard against that specific failure case.[0m
[1m        if not isinstance(request, PreparedRequest):[0m
[1m            raise ValueError('You can only send PreparedRequests.')[0m
[1m    [0m
[1m        # Set up variables needed for resolve_redirects and dispatching of[0m
[1m        # hooks[0m
[1m        allow_redirects = kwargs.pop('allow_redirects', True)[0m
[1m        stream = kwargs.get('stream')[0m
[1m        timeout = kwargs.get('timeout')[0m
[1m        verify = kwargs.get('verify')[0m
[1m        cert = kwargs.get('cert')[0m
[1m        proxies = kwargs.get('proxies')[0m
[1m        hooks = request.hooks[0m
[1m    [0m
[1m        # Get the appropriate adapter to use[0m
[1m        adapter = self.get_adapter(url=request.url)[0m
[1m    [0m
[1m        # Start time (approximately) of the request[0m
[1m        start = datetime.utcnow()[0m
[1m        # Send the request[0m
[1m>       r = adapter.send(request, **kwargs)[0m

requests/sessions.py:460: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.adapters.HTTPAdapter object at 0x27793d0>
request = <PreparedRequest [GET]>, stream = False, timeout = None, verify = True
cert = None, proxies = OrderedDict()

[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):[0m
[1m        """Sends PreparedRequest object. Returns Response object.[0m
[1m    [0m
[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.[0m
[1m            :param stream: (optional) Whether to stream the request content.[0m
[1m            :param timeout: (optional) The timeout on the request.[0m
[1m            :param verify: (optional) Whether to verify SSL certificates.[0m
[1m            :param vert: (optional) Any user-provided SSL certificate to be trusted.[0m
[1m            :param proxies: (optional) The proxies dictionary to apply to the request.[0m
[1m            """[0m
[1m    [0m
[1m        conn = self.get_connection(request.url, proxies)[0m
[1m    [0m
[1m        self.cert_verify(conn, request.url, verify, cert)[0m
[1m        url = self.request_url(request, proxies)[0m
[1m        self.add_headers(request)[0m
[1m    [0m
[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)[0m
[1m    [0m
[1m        if stream:[0m
[1m            timeout = Timeout(connect=timeout)[0m
[1m        else:[0m
[1m>           timeout = Timeout(connect=timeout, read=timeout)[0m
[1m[31mE           TypeError: Timeout does not take keyword arguments[0m

requests/adapters.py:305: TypeError
__________ RequestsTestCase.test_different_encodings_dont_break_post ___________

self = <test_requests.RequestsTestCase testMethod=test_different_encodings_dont_break_post>

[1m    def test_different_encodings_dont_break_post(self):[0m
[1m        r = requests.post(httpbin('post'),[0m
[1m                          data={'stuff': json.dumps({'a': 123})},[0m
[1m                          params={'blah': 'asdf1234'},[0m
[1m>                         files={'file': ('test_requests.py', open(__file__, 'rb'))})[0m

test_requests.py:401: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

url = 'http://httpbin.org/post', data = {'stuff': '{"a": 123}'}
kwargs = {'files': {'file': ('test_requests.py', <open file '/home/travis/build/kennethreitz/requests/test_requests.py', mode 'rb' at 0x2a36810>)}, 'params': {'blah': 'asdf1234'}}

[1m    def post(url, data=None, **kwargs):[0m
[1m        """Sends a POST request. Returns :class:`Response` object.[0m
[1m    [0m
[1m        :param url: URL for the new :class:`Request` object.[0m
[1m        :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.[0m
[1m        :param \*\*kwargs: Optional arguments that ``request`` takes.[0m
[1m        """[0m
[1m    [0m
[1m>       return request('post', url, data=data, **kwargs)[0m

requests/api.py:88: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

method = 'post', url = 'http://httpbin.org/post'
kwargs = {'data': {'stuff': '{"a": 123}'}, 'files': {'file': ('test_requests.py', <open file '/home/travis/build/kennethreitz/requests/test_requests.py', mode 'rb' at 0x2a36810>)}, 'params': {'blah': 'asdf1234'}}
session = <requests.sessions.Session object at 0x2790850>

[1m    def request(method, url, **kwargs):[0m
[1m        """Constructs and sends a :class:`Request <Request>`.[0m
[1m        Returns :class:`Response <Response>` object.[0m
[1m    [0m
[1m        :param method: method for the new :class:`Request` object.[0m
[1m        :param url: URL for the new :class:`Request` object.[0m
[1m        :param params: (optional) Dictionary or bytes to be sent in the query string for the :class:`Request`.[0m
[1m        :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.[0m
[1m        :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.[0m
[1m        :param cookies: (optional) Dict or CookieJar object to send with the :class:`Request`.[0m
[1m        :param files: (optional) Dictionary of 'name': file-like-objects (or {'name': ('filename', fileobj)}) for multipart encoding upload.[0m
[1m        :param auth: (optional) Auth tuple to enable Basic/Digest/Custom HTTP Auth.[0m
[1m        :param timeout: (optional) Float describing the timeout of the request.[0m
[1m        :param allow_redirects: (optional) Boolean. Set to True if POST/PUT/DELETE redirect following is allowed.[0m
[1m        :param proxies: (optional) Dictionary mapping protocol to the URL of the proxy.[0m
[1m        :param verify: (optional) if ``True``, the SSL cert will be verified. A CA_BUNDLE path can also be provided.[0m
[1m        :param stream: (optional) if ``False``, the response content will be immediately downloaded.[0m
[1m        :param cert: (optional) if String, path to ssl client cert file (.pem). If Tuple, ('cert', 'key') pair.[0m
[1m    [0m
[1m        Usage::[0m
[1m    [0m
[1m          >>> import requests[0m
[1m          >>> req = requests.request('GET', 'http://httpbin.org/get')[0m
[1m          <Response [200]>[0m
[1m        """[0m
[1m    [0m
[1m        session = sessions.Session()[0m
[1m>       return session.request(method=method, url=url, **kwargs)[0m

requests/api.py:44: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x2790850>, method = 'post'
url = 'http://httpbin.org/post', params = {'blah': 'asdf1234'}
data = {'stuff': '{"a": 123}'}, headers = None, cookies = None
files = {'file': ('test_requests.py', <open file '/home/travis/build/kennethreitz/requests/test_requests.py', mode 'rb' at 0x2a36810>)}
auth = None, timeout = None, allow_redirects = True, proxies = OrderedDict()
hooks = None, stream = False, verify = True, cert = None

[1m    def request(self, method, url,[0m
[1m        params=None,[0m
[1m        data=None,[0m
[1m        headers=None,[0m
[1m        cookies=None,[0m
[1m        files=None,[0m
[1m        auth=None,[0m
[1m        timeout=None,[0m
[1m        allow_redirects=True,[0m
[1m        proxies=None,[0m
[1m        hooks=None,[0m
[1m        stream=None,[0m
[1m        verify=None,[0m
[1m        cert=None):[0m
[1m        """Constructs a :class:`Request <Request>`, prepares it and sends it.[0m
[1m            Returns :class:`Response <Response>` object.[0m
[1m    [0m
[1m            :param method: method for the new :class:`Request` object.[0m
[1m            :param url: URL for the new :class:`Request` object.[0m
[1m            :param params: (optional) Dictionary or bytes to be sent in the query[0m
[1m                string for the :class:`Request`.[0m
[1m            :param data: (optional) Dictionary or bytes to send in the body of the[0m
[1m                :class:`Request`.[0m
[1m            :param headers: (optional) Dictionary of HTTP Headers to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param cookies: (optional) Dict or CookieJar object to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param files: (optional) Dictionary of 'filename': file-like-objects[0m
[1m                for multipart encoding upload.[0m
[1m            :param auth: (optional) Auth tuple or callable to enable[0m
[1m                Basic/Digest/Custom HTTP Auth.[0m
[1m            :param timeout: (optional) Float describing the timeout of the[0m
[1m                request.[0m
[1m            :param allow_redirects: (optional) Boolean. Set to True by default.[0m
[1m            :param proxies: (optional) Dictionary mapping protocol to the URL of[0m
[1m                the proxy.[0m
[1m            :param stream: (optional) whether to immediately download the response[0m
[1m                content. Defaults to ``False``.[0m
[1m            :param verify: (optional) if ``True``, the SSL cert will be verified.[0m
[1m                A CA_BUNDLE path can also be provided.[0m
[1m            :param cert: (optional) if String, path to ssl client cert file (.pem).[0m
[1m                If Tuple, ('cert', 'key') pair.[0m
[1m            """[0m
[1m        # Create the Request.[0m
[1m        req = Request([0m
[1m            method = method.upper(),[0m
[1m            url = url,[0m
[1m            headers = headers,[0m
[1m            files = files,[0m
[1m            data = data or {},[0m
[1m            params = params or {},[0m
[1m            auth = auth,[0m
[1m            cookies = cookies,[0m
[1m            hooks = hooks,[0m
[1m        )[0m
[1m        prep = self.prepare_request(req)[0m
[1m    [0m
[1m        proxies = proxies or {}[0m
[1m    [0m
[1m        # Gather clues from the surrounding environment.[0m
[1m        if self.trust_env:[0m
[1m            # Set environment's proxies.[0m
[1m            env_proxies = get_environ_proxies(url) or {}[0m
[1m            for (k, v) in env_proxies.items():[0m
[1m                proxies.setdefault(k, v)[0m
[1m    [0m
[1m            # Look for configuration.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('REQUESTS_CA_BUNDLE')[0m
[1m    [0m
[1m            # Curl compatibility.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('CURL_CA_BUNDLE')[0m
[1m    [0m
[1m        # Merge all the kwargs.[0m
[1m        proxies = merge_setting(proxies, self.proxies)[0m
[1m        stream = merge_setting(stream, self.stream)[0m
[1m        verify = merge_setting(verify, self.verify)[0m
[1m        cert = merge_setting(cert, self.cert)[0m
[1m    [0m
[1m        # Send the request.[0m
[1m        send_kwargs = {[0m
[1m            'stream': stream,[0m
[1m            'timeout': timeout,[0m
[1m            'verify': verify,[0m
[1m            'cert': cert,[0m
[1m            'proxies': proxies,[0m
[1m            'allow_redirects': allow_redirects,[0m
[1m        }[0m
[1m>       resp = self.send(prep, **send_kwargs)[0m

requests/sessions.py:357: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x2790850>
request = <PreparedRequest [POST]>
kwargs = {'cert': None, 'proxies': OrderedDict(), 'stream': False, 'timeout': None, ...}
allow_redirects = True, stream = False, timeout = None, verify = True
cert = None, proxies = OrderedDict(), hooks = {'response': []}

[1m    def send(self, request, **kwargs):[0m
[1m        """Send a given PreparedRequest."""[0m
[1m        # Set defaults that the hooks can utilize to ensure they always have[0m
[1m        # the correct parameters to reproduce the previous request.[0m
[1m        kwargs.setdefault('stream', self.stream)[0m
[1m        kwargs.setdefault('verify', self.verify)[0m
[1m        kwargs.setdefault('cert', self.cert)[0m
[1m        kwargs.setdefault('proxies', self.proxies)[0m
[1m    [0m
[1m        # It's possible that users might accidentally send a Request object.[0m
[1m        # Guard against that specific failure case.[0m
[1m        if not isinstance(request, PreparedRequest):[0m
[1m            raise ValueError('You can only send PreparedRequests.')[0m
[1m    [0m
[1m        # Set up variables needed for resolve_redirects and dispatching of[0m
[1m        # hooks[0m
[1m        allow_redirects = kwargs.pop('allow_redirects', True)[0m
[1m        stream = kwargs.get('stream')[0m
[1m        timeout = kwargs.get('timeout')[0m
[1m        verify = kwargs.get('verify')[0m
[1m        cert = kwargs.get('cert')[0m
[1m        proxies = kwargs.get('proxies')[0m
[1m        hooks = request.hooks[0m
[1m    [0m
[1m        # Get the appropriate adapter to use[0m
[1m        adapter = self.get_adapter(url=request.url)[0m
[1m    [0m
[1m        # Start time (approximately) of the request[0m
[1m        start = datetime.utcnow()[0m
[1m        # Send the request[0m
[1m>       r = adapter.send(request, **kwargs)[0m

requests/sessions.py:460: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.adapters.HTTPAdapter object at 0x2790e50>
request = <PreparedRequest [POST]>, stream = False, timeout = None
verify = True, cert = None, proxies = OrderedDict()

[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):[0m
[1m        """Sends PreparedRequest object. Returns Response object.[0m
[1m    [0m
[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.[0m
[1m            :param stream: (optional) Whether to stream the request content.[0m
[1m            :param timeout: (optional) The timeout on the request.[0m
[1m            :param verify: (optional) Whether to verify SSL certificates.[0m
[1m            :param vert: (optional) Any user-provided SSL certificate to be trusted.[0m
[1m            :param proxies: (optional) The proxies dictionary to apply to the request.[0m
[1m            """[0m
[1m    [0m
[1m        conn = self.get_connection(request.url, proxies)[0m
[1m    [0m
[1m        self.cert_verify(conn, request.url, verify, cert)[0m
[1m        url = self.request_url(request, proxies)[0m
[1m        self.add_headers(request)[0m
[1m    [0m
[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)[0m
[1m    [0m
[1m        if stream:[0m
[1m            timeout = Timeout(connect=timeout)[0m
[1m        else:[0m
[1m>           timeout = Timeout(connect=timeout, read=timeout)[0m
[1m[31mE           TypeError: Timeout does not take keyword arguments[0m

requests/adapters.py:305: TypeError
_______________________ RequestsTestCase.test_fixes_1329 _______________________

self = <test_requests.RequestsTestCase testMethod=test_fixes_1329>

[1m    def test_fixes_1329(self):[0m
[1m        """[0m
[1m            Ensure that header updates are done case-insensitively.[0m
[1m            """[0m
[1m        s = requests.Session()[0m
[1m        s.headers.update({'ACCEPT': 'BOGUS'})[0m
[1m        s.headers.update({'accept': 'application/json'})[0m
[1m>       r = s.get(httpbin('get'))[0m

test_requests.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x268fb90>
url = 'http://httpbin.org/get', kwargs = {'allow_redirects': True}

[1m    def get(self, url, **kwargs):[0m
[1m        """Sends a GET request. Returns :class:`Response` object.[0m
[1m    [0m
[1m            :param url: URL for the new :class:`Request` object.[0m
[1m            :param \*\*kwargs: Optional arguments that ``request`` takes.[0m
[1m            """[0m
[1m    [0m
[1m        kwargs.setdefault('allow_redirects', True)[0m
[1m>       return self.request('GET', url, **kwargs)[0m

requests/sessions.py:369: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x268fb90>, method = 'GET'
url = 'http://httpbin.org/get', params = None, data = None, headers = None
cookies = None, files = None, auth = None, timeout = None
allow_redirects = True, proxies = OrderedDict(), hooks = None, stream = False
verify = True, cert = None

[1m    def request(self, method, url,[0m
[1m        params=None,[0m
[1m        data=None,[0m
[1m        headers=None,[0m
[1m        cookies=None,[0m
[1m        files=None,[0m
[1m        auth=None,[0m
[1m        timeout=None,[0m
[1m        allow_redirects=True,[0m
[1m        proxies=None,[0m
[1m        hooks=None,[0m
[1m        stream=None,[0m
[1m        verify=None,[0m
[1m        cert=None):[0m
[1m        """Constructs a :class:`Request <Request>`, prepares it and sends it.[0m
[1m            Returns :class:`Response <Response>` object.[0m
[1m    [0m
[1m            :param method: method for the new :class:`Request` object.[0m
[1m            :param url: URL for the new :class:`Request` object.[0m
[1m            :param params: (optional) Dictionary or bytes to be sent in the query[0m
[1m                string for the :class:`Request`.[0m
[1m            :param data: (optional) Dictionary or bytes to send in the body of the[0m
[1m                :class:`Request`.[0m
[1m            :param headers: (optional) Dictionary of HTTP Headers to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param cookies: (optional) Dict or CookieJar object to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param files: (optional) Dictionary of 'filename': file-like-objects[0m
[1m                for multipart encoding upload.[0m
[1m            :param auth: (optional) Auth tuple or callable to enable[0m
[1m                Basic/Digest/Custom HTTP Auth.[0m
[1m            :param timeout: (optional) Float describing the timeout of the[0m
[1m                request.[0m
[1m            :param allow_redirects: (optional) Boolean. Set to True by default.[0m
[1m            :param proxies: (optional) Dictionary mapping protocol to the URL of[0m
[1m                the proxy.[0m
[1m            :param stream: (optional) whether to immediately download the response[0m
[1m                content. Defaults to ``False``.[0m
[1m            :param verify: (optional) if ``True``, the SSL cert will be verified.[0m
[1m                A CA_BUNDLE path can also be provided.[0m
[1m            :param cert: (optional) if String, path to ssl client cert file (.pem).[0m
[1m                If Tuple, ('cert', 'key') pair.[0m
[1m            """[0m
[1m        # Create the Request.[0m
[1m        req = Request([0m
[1m            method = method.upper(),[0m
[1m            url = url,[0m
[1m            headers = headers,[0m
[1m            files = files,[0m
[1m            data = data or {},[0m
[1m            params = params or {},[0m
[1m            auth = auth,[0m
[1m            cookies = cookies,[0m
[1m            hooks = hooks,[0m
[1m        )[0m
[1m        prep = self.prepare_request(req)[0m
[1m    [0m
[1m        proxies = proxies or {}[0m
[1m    [0m
[1m        # Gather clues from the surrounding environment.[0m
[1m        if self.trust_env:[0m
[1m            # Set environment's proxies.[0m
[1m            env_proxies = get_environ_proxies(url) or {}[0m
[1m            for (k, v) in env_proxies.items():[0m
[1m                proxies.setdefault(k, v)[0m
[1m    [0m
[1m            # Look for configuration.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('REQUESTS_CA_BUNDLE')[0m
[1m    [0m
[1m            # Curl compatibility.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('CURL_CA_BUNDLE')[0m
[1m    [0m
[1m        # Merge all the kwargs.[0m
[1m        proxies = merge_setting(proxies, self.proxies)[0m
[1m        stream = merge_setting(stream, self.stream)[0m
[1m        verify = merge_setting(verify, self.verify)[0m
[1m        cert = merge_setting(cert, self.cert)[0m
[1m    [0m
[1m        # Send the request.[0m
[1m        send_kwargs = {[0m
[1m            'stream': stream,[0m
[1m            'timeout': timeout,[0m
[1m            'verify': verify,[0m
[1m            'cert': cert,[0m
[1m            'proxies': proxies,[0m
[1m            'allow_redirects': allow_redirects,[0m
[1m        }[0m
[1m>       resp = self.send(prep, **send_kwargs)[0m

requests/sessions.py:357: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x268fb90>
request = <PreparedRequest [GET]>
kwargs = {'cert': None, 'proxies': OrderedDict(), 'stream': False, 'timeout': None, ...}
allow_redirects = True, stream = False, timeout = None, verify = True
cert = None, proxies = OrderedDict(), hooks = {'response': []}

[1m    def send(self, request, **kwargs):[0m
[1m        """Send a given PreparedRequest."""[0m
[1m        # Set defaults that the hooks can utilize to ensure they always have[0m
[1m        # the correct parameters to reproduce the previous request.[0m
[1m        kwargs.setdefault('stream', self.stream)[0m
[1m        kwargs.setdefault('verify', self.verify)[0m
[1m        kwargs.setdefault('cert', self.cert)[0m
[1m        kwargs.setdefault('proxies', self.proxies)[0m
[1m    [0m
[1m        # It's possible that users might accidentally send a Request object.[0m
[1m        # Guard against that specific failure case.[0m
[1m        if not isinstance(request, PreparedRequest):[0m
[1m            raise ValueError('You can only send PreparedRequests.')[0m
[1m    [0m
[1m        # Set up variables needed for resolve_redirects and dispatching of[0m
[1m        # hooks[0m
[1m        allow_redirects = kwargs.pop('allow_redirects', True)[0m
[1m        stream = kwargs.get('stream')[0m
[1m        timeout = kwargs.get('timeout')[0m
[1m        verify = kwargs.get('verify')[0m
[1m        cert = kwargs.get('cert')[0m
[1m        proxies = kwargs.get('proxies')[0m
[1m        hooks = request.hooks[0m
[1m    [0m
[1m        # Get the appropriate adapter to use[0m
[1m        adapter = self.get_adapter(url=request.url)[0m
[1m    [0m
[1m        # Start time (approximately) of the request[0m
[1m        start = datetime.utcnow()[0m
[1m        # Send the request[0m
[1m>       r = adapter.send(request, **kwargs)[0m

requests/sessions.py:460: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.adapters.HTTPAdapter object at 0x26a2f10>
request = <PreparedRequest [GET]>, stream = False, timeout = None, verify = True
cert = None, proxies = OrderedDict()

[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):[0m
[1m        """Sends PreparedRequest object. Returns Response object.[0m
[1m    [0m
[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.[0m
[1m            :param stream: (optional) Whether to stream the request content.[0m
[1m            :param timeout: (optional) The timeout on the request.[0m
[1m            :param verify: (optional) Whether to verify SSL certificates.[0m
[1m            :param vert: (optional) Any user-provided SSL certificate to be trusted.[0m
[1m            :param proxies: (optional) The proxies dictionary to apply to the request.[0m
[1m            """[0m
[1m    [0m
[1m        conn = self.get_connection(request.url, proxies)[0m
[1m    [0m
[1m        self.cert_verify(conn, request.url, verify, cert)[0m
[1m        url = self.request_url(request, proxies)[0m
[1m        self.add_headers(request)[0m
[1m    [0m
[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)[0m
[1m    [0m
[1m        if stream:[0m
[1m            timeout = Timeout(connect=timeout)[0m
[1m        else:[0m
[1m>           timeout = Timeout(connect=timeout, read=timeout)[0m
[1m[31mE           TypeError: Timeout does not take keyword arguments[0m

requests/adapters.py:305: TypeError
________________ RequestsTestCase.test_generic_cookiejar_works _________________

self = <test_requests.RequestsTestCase testMethod=test_generic_cookiejar_works>

[1m    def test_generic_cookiejar_works(self):[0m
[1m        cj = cookielib.CookieJar()[0m
[1m        cookiejar_from_dict({'foo': 'bar'}, cj)[0m
[1m        s = requests.session()[0m
[1m        s.cookies = cj[0m
[1m>       r = s.get(httpbin('cookies'))[0m

test_requests.py:180: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x27909d0>
url = 'http://httpbin.org/cookies', kwargs = {'allow_redirects': True}

[1m    def get(self, url, **kwargs):[0m
[1m        """Sends a GET request. Returns :class:`Response` object.[0m
[1m    [0m
[1m            :param url: URL for the new :class:`Request` object.[0m
[1m            :param \*\*kwargs: Optional arguments that ``request`` takes.[0m
[1m            """[0m
[1m    [0m
[1m        kwargs.setdefault('allow_redirects', True)[0m
[1m>       return self.request('GET', url, **kwargs)[0m

requests/sessions.py:369: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x27909d0>, method = 'GET'
url = 'http://httpbin.org/cookies', params = None, data = None, headers = None
cookies = None, files = None, auth = None, timeout = None
allow_redirects = True, proxies = OrderedDict(), hooks = None, stream = False
verify = True, cert = None

[1m    def request(self, method, url,[0m
[1m        params=None,[0m
[1m        data=None,[0m
[1m        headers=None,[0m
[1m        cookies=None,[0m
[1m        files=None,[0m
[1m        auth=None,[0m
[1m        timeout=None,[0m
[1m        allow_redirects=True,[0m
[1m        proxies=None,[0m
[1m        hooks=None,[0m
[1m        stream=None,[0m
[1m        verify=None,[0m
[1m        cert=None):[0m
[1m        """Constructs a :class:`Request <Request>`, prepares it and sends it.[0m
[1m            Returns :class:`Response <Response>` object.[0m
[1m    [0m
[1m            :param method: method for the new :class:`Request` object.[0m
[1m            :param url: URL for the new :class:`Request` object.[0m
[1m            :param params: (optional) Dictionary or bytes to be sent in the query[0m
[1m                string for the :class:`Request`.[0m
[1m            :param data: (optional) Dictionary or bytes to send in the body of the[0m
[1m                :class:`Request`.[0m
[1m            :param headers: (optional) Dictionary of HTTP Headers to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param cookies: (optional) Dict or CookieJar object to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param files: (optional) Dictionary of 'filename': file-like-objects[0m
[1m                for multipart encoding upload.[0m
[1m            :param auth: (optional) Auth tuple or callable to enable[0m
[1m                Basic/Digest/Custom HTTP Auth.[0m
[1m            :param timeout: (optional) Float describing the timeout of the[0m
[1m                request.[0m
[1m            :param allow_redirects: (optional) Boolean. Set to True by default.[0m
[1m            :param proxies: (optional) Dictionary mapping protocol to the URL of[0m
[1m                the proxy.[0m
[1m            :param stream: (optional) whether to immediately download the response[0m
[1m                content. Defaults to ``False``.[0m
[1m            :param verify: (optional) if ``True``, the SSL cert will be verified.[0m
[1m                A CA_BUNDLE path can also be provided.[0m
[1m            :param cert: (optional) if String, path to ssl client cert file (.pem).[0m
[1m                If Tuple, ('cert', 'key') pair.[0m
[1m            """[0m
[1m        # Create the Request.[0m
[1m        req = Request([0m
[1m            method = method.upper(),[0m
[1m            url = url,[0m
[1m            headers = headers,[0m
[1m            files = files,[0m
[1m            data = data or {},[0m
[1m            params = params or {},[0m
[1m            auth = auth,[0m
[1m            cookies = cookies,[0m
[1m            hooks = hooks,[0m
[1m        )[0m
[1m        prep = self.prepare_request(req)[0m
[1m    [0m
[1m        proxies = proxies or {}[0m
[1m    [0m
[1m        # Gather clues from the surrounding environment.[0m
[1m        if self.trust_env:[0m
[1m            # Set environment's proxies.[0m
[1m            env_proxies = get_environ_proxies(url) or {}[0m
[1m            for (k, v) in env_proxies.items():[0m
[1m                proxies.setdefault(k, v)[0m
[1m    [0m
[1m            # Look for configuration.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('REQUESTS_CA_BUNDLE')[0m
[1m    [0m
[1m            # Curl compatibility.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('CURL_CA_BUNDLE')[0m
[1m    [0m
[1m        # Merge all the kwargs.[0m
[1m        proxies = merge_setting(proxies, self.proxies)[0m
[1m        stream = merge_setting(stream, self.stream)[0m
[1m        verify = merge_setting(verify, self.verify)[0m
[1m        cert = merge_setting(cert, self.cert)[0m
[1m    [0m
[1m        # Send the request.[0m
[1m        send_kwargs = {[0m
[1m            'stream': stream,[0m
[1m            'timeout': timeout,[0m
[1m            'verify': verify,[0m
[1m            'cert': cert,[0m
[1m            'proxies': proxies,[0m
[1m            'allow_redirects': allow_redirects,[0m
[1m        }[0m
[1m>       resp = self.send(prep, **send_kwargs)[0m

requests/sessions.py:357: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x27909d0>
request = <PreparedRequest [GET]>
kwargs = {'cert': None, 'proxies': OrderedDict(), 'stream': False, 'timeout': None, ...}
allow_redirects = True, stream = False, timeout = None, verify = True
cert = None, proxies = OrderedDict(), hooks = {'response': []}

[1m    def send(self, request, **kwargs):[0m
[1m        """Send a given PreparedRequest."""[0m
[1m        # Set defaults that the hooks can utilize to ensure they always have[0m
[1m        # the correct parameters to reproduce the previous request.[0m
[1m        kwargs.setdefault('stream', self.stream)[0m
[1m        kwargs.setdefault('verify', self.verify)[0m
[1m        kwargs.setdefault('cert', self.cert)[0m
[1m        kwargs.setdefault('proxies', self.proxies)[0m
[1m    [0m
[1m        # It's possible that users might accidentally send a Request object.[0m
[1m        # Guard against that specific failure case.[0m
[1m        if not isinstance(request, PreparedRequest):[0m
[1m            raise ValueError('You can only send PreparedRequests.')[0m
[1m    [0m
[1m        # Set up variables needed for resolve_redirects and dispatching of[0m
[1m        # hooks[0m
[1m        allow_redirects = kwargs.pop('allow_redirects', True)[0m
[1m        stream = kwargs.get('stream')[0m
[1m        timeout = kwargs.get('timeout')[0m
[1m        verify = kwargs.get('verify')[0m
[1m        cert = kwargs.get('cert')[0m
[1m        proxies = kwargs.get('proxies')[0m
[1m        hooks = request.hooks[0m
[1m    [0m
[1m        # Get the appropriate adapter to use[0m
[1m        adapter = self.get_adapter(url=request.url)[0m
[1m    [0m
[1m        # Start time (approximately) of the request[0m
[1m        start = datetime.utcnow()[0m
[1m        # Send the request[0m
[1m>       r = adapter.send(request, **kwargs)[0m

requests/sessions.py:460: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.adapters.HTTPAdapter object at 0x2790510>
request = <PreparedRequest [GET]>, stream = False, timeout = None, verify = True
cert = None, proxies = OrderedDict()

[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):[0m
[1m        """Sends PreparedRequest object. Returns Response object.[0m
[1m    [0m
[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.[0m
[1m            :param stream: (optional) Whether to stream the request content.[0m
[1m            :param timeout: (optional) The timeout on the request.[0m
[1m            :param verify: (optional) Whether to verify SSL certificates.[0m
[1m            :param vert: (optional) Any user-provided SSL certificate to be trusted.[0m
[1m            :param proxies: (optional) The proxies dictionary to apply to the request.[0m
[1m            """[0m
[1m    [0m
[1m        conn = self.get_connection(request.url, proxies)[0m
[1m    [0m
[1m        self.cert_verify(conn, request.url, verify, cert)[0m
[1m        url = self.request_url(request, proxies)[0m
[1m        self.add_headers(request)[0m
[1m    [0m
[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)[0m
[1m    [0m
[1m        if stream:[0m
[1m            timeout = Timeout(connect=timeout)[0m
[1m        else:[0m
[1m>           timeout = Timeout(connect=timeout, read=timeout)[0m
[1m[31mE           TypeError: Timeout does not take keyword arguments[0m

requests/adapters.py:305: TypeError
___________ RequestsTestCase.test_header_remove_is_case_insensitive ____________

self = <test_requests.RequestsTestCase testMethod=test_header_remove_is_case_insensitive>

[1m    def test_header_remove_is_case_insensitive(self):[0m
[1m        # From issue #1321[0m
[1m        s = requests.Session()[0m
[1m        s.headers['foo'] = 'bar'[0m
[1m>       r = s.get(httpbin('get'), headers={'FOO': None})[0m

test_requests.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x29d3810>
url = 'http://httpbin.org/get'
kwargs = {'allow_redirects': True, 'headers': {'FOO': None}}

[1m    def get(self, url, **kwargs):[0m
[1m        """Sends a GET request. Returns :class:`Response` object.[0m
[1m    [0m
[1m            :param url: URL for the new :class:`Request` object.[0m
[1m            :param \*\*kwargs: Optional arguments that ``request`` takes.[0m
[1m            """[0m
[1m    [0m
[1m        kwargs.setdefault('allow_redirects', True)[0m
[1m>       return self.request('GET', url, **kwargs)[0m

requests/sessions.py:369: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x29d3810>, method = 'GET'
url = 'http://httpbin.org/get', params = None, data = None
headers = {'FOO': None}, cookies = None, files = None, auth = None
timeout = None, allow_redirects = True, proxies = OrderedDict(), hooks = None
stream = False, verify = True, cert = None

[1m    def request(self, method, url,[0m
[1m        params=None,[0m
[1m        data=None,[0m
[1m        headers=None,[0m
[1m        cookies=None,[0m
[1m        files=None,[0m
[1m        auth=None,[0m
[1m        timeout=None,[0m
[1m        allow_redirects=True,[0m
[1m        proxies=None,[0m
[1m        hooks=None,[0m
[1m        stream=None,[0m
[1m        verify=None,[0m
[1m        cert=None):[0m
[1m        """Constructs a :class:`Request <Request>`, prepares it and sends it.[0m
[1m            Returns :class:`Response <Response>` object.[0m
[1m    [0m
[1m            :param method: method for the new :class:`Request` object.[0m
[1m            :param url: URL for the new :class:`Request` object.[0m
[1m            :param params: (optional) Dictionary or bytes to be sent in the query[0m
[1m                string for the :class:`Request`.[0m
[1m            :param data: (optional) Dictionary or bytes to send in the body of the[0m
[1m                :class:`Request`.[0m
[1m            :param headers: (optional) Dictionary of HTTP Headers to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param cookies: (optional) Dict or CookieJar object to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param files: (optional) Dictionary of 'filename': file-like-objects[0m
[1m                for multipart encoding upload.[0m
[1m            :param auth: (optional) Auth tuple or callable to enable[0m
[1m                Basic/Digest/Custom HTTP Auth.[0m
[1m            :param timeout: (optional) Float describing the timeout of the[0m
[1m                request.[0m
[1m            :param allow_redirects: (optional) Boolean. Set to True by default.[0m
[1m            :param proxies: (optional) Dictionary mapping protocol to the URL of[0m
[1m                the proxy.[0m
[1m            :param stream: (optional) whether to immediately download the response[0m
[1m                content. Defaults to ``False``.[0m
[1m            :param verify: (optional) if ``True``, the SSL cert will be verified.[0m
[1m                A CA_BUNDLE path can also be provided.[0m
[1m            :param cert: (optional) if String, path to ssl client cert file (.pem).[0m
[1m                If Tuple, ('cert', 'key') pair.[0m
[1m            """[0m
[1m        # Create the Request.[0m
[1m        req = Request([0m
[1m            method = method.upper(),[0m
[1m            url = url,[0m
[1m            headers = headers,[0m
[1m            files = files,[0m
[1m            data = data or {},[0m
[1m            params = params or {},[0m
[1m            auth = auth,[0m
[1m            cookies = cookies,[0m
[1m            hooks = hooks,[0m
[1m        )[0m
[1m        prep = self.prepare_request(req)[0m
[1m    [0m
[1m        proxies = proxies or {}[0m
[1m    [0m
[1m        # Gather clues from the surrounding environment.[0m
[1m        if self.trust_env:[0m
[1m            # Set environment's proxies.[0m
[1m            env_proxies = get_environ_proxies(url) or {}[0m
[1m            for (k, v) in env_proxies.items():[0m
[1m                proxies.setdefault(k, v)[0m
[1m    [0m
[1m            # Look for configuration.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('REQUESTS_CA_BUNDLE')[0m
[1m    [0m
[1m            # Curl compatibility.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('CURL_CA_BUNDLE')[0m
[1m    [0m
[1m        # Merge all the kwargs.[0m
[1m        proxies = merge_setting(proxies, self.proxies)[0m
[1m        stream = merge_setting(stream, self.stream)[0m
[1m        verify = merge_setting(verify, self.verify)[0m
[1m        cert = merge_setting(cert, self.cert)[0m
[1m    [0m
[1m        # Send the request.[0m
[1m        send_kwargs = {[0m
[1m            'stream': stream,[0m
[1m            'timeout': timeout,[0m
[1m            'verify': verify,[0m
[1m            'cert': cert,[0m
[1m            'proxies': proxies,[0m
[1m            'allow_redirects': allow_redirects,[0m
[1m        }[0m
[1m>       resp = self.send(prep, **send_kwargs)[0m

requests/sessions.py:357: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x29d3810>
request = <PreparedRequest [GET]>
kwargs = {'cert': None, 'proxies': OrderedDict(), 'stream': False, 'timeout': None, ...}
allow_redirects = True, stream = False, timeout = None, verify = True
cert = None, proxies = OrderedDict(), hooks = {'response': []}

[1m    def send(self, request, **kwargs):[0m
[1m        """Send a given PreparedRequest."""[0m
[1m        # Set defaults that the hooks can utilize to ensure they always have[0m
[1m        # the correct parameters to reproduce the previous request.[0m
[1m        kwargs.setdefault('stream', self.stream)[0m
[1m        kwargs.setdefault('verify', self.verify)[0m
[1m        kwargs.setdefault('cert', self.cert)[0m
[1m        kwargs.setdefault('proxies', self.proxies)[0m
[1m    [0m
[1m        # It's possible that users might accidentally send a Request object.[0m
[1m        # Guard against that specific failure case.[0m
[1m        if not isinstance(request, PreparedRequest):[0m
[1m            raise ValueError('You can only send PreparedRequests.')[0m
[1m    [0m
[1m        # Set up variables needed for resolve_redirects and dispatching of[0m
[1m        # hooks[0m
[1m        allow_redirects = kwargs.pop('allow_redirects', True)[0m
[1m        stream = kwargs.get('stream')[0m
[1m        timeout = kwargs.get('timeout')[0m
[1m        verify = kwargs.get('verify')[0m
[1m        cert = kwargs.get('cert')[0m
[1m        proxies = kwargs.get('proxies')[0m
[1m        hooks = request.hooks[0m
[1m    [0m
[1m        # Get the appropriate adapter to use[0m
[1m        adapter = self.get_adapter(url=request.url)[0m
[1m    [0m
[1m        # Start time (approximately) of the request[0m
[1m        start = datetime.utcnow()[0m
[1m        # Send the request[0m
[1m>       r = adapter.send(request, **kwargs)[0m

requests/sessions.py:460: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.adapters.HTTPAdapter object at 0x29d3c90>
request = <PreparedRequest [GET]>, stream = False, timeout = None, verify = True
cert = None, proxies = OrderedDict()

[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):[0m
[1m        """Sends PreparedRequest object. Returns Response object.[0m
[1m    [0m
[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.[0m
[1m            :param stream: (optional) Whether to stream the request content.[0m
[1m            :param timeout: (optional) The timeout on the request.[0m
[1m            :param verify: (optional) Whether to verify SSL certificates.[0m
[1m            :param vert: (optional) Any user-provided SSL certificate to be trusted.[0m
[1m            :param proxies: (optional) The proxies dictionary to apply to the request.[0m
[1m            """[0m
[1m    [0m
[1m        conn = self.get_connection(request.url, proxies)[0m
[1m    [0m
[1m        self.cert_verify(conn, request.url, verify, cert)[0m
[1m        url = self.request_url(request, proxies)[0m
[1m        self.add_headers(request)[0m
[1m    [0m
[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)[0m
[1m    [0m
[1m        if stream:[0m
[1m            timeout = Timeout(connect=timeout)[0m
[1m        else:[0m
[1m>           timeout = Timeout(connect=timeout, read=timeout)[0m
[1m[31mE           TypeError: Timeout does not take keyword arguments[0m

requests/adapters.py:305: TypeError
______________ RequestsTestCase.test_mixed_case_scheme_acceptable ______________

self = <test_requests.RequestsTestCase testMethod=test_mixed_case_scheme_acceptable>

[1m    def test_mixed_case_scheme_acceptable(self):[0m
[1m        s = requests.Session()[0m
[1m        s.proxies = getproxies()[0m
[1m        parts = urlparse(httpbin('get'))[0m
[1m        schemes = ['http://', 'HTTP://', 'hTTp://', 'HttP://',[0m
[1m                   'https://', 'HTTPS://', 'hTTps://', 'HttPs://'][0m
[1m        for scheme in schemes:[0m
[1m            url = scheme + parts.netloc + parts.path[0m
[1m            r = requests.Request('GET', url)[0m
[1m>           r = s.send(r.prepare())[0m

test_requests.py:102: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x2a44250>
request = <PreparedRequest [GET]>
kwargs = {'cert': None, 'proxies': {}, 'stream': False, 'verify': True}
allow_redirects = True, stream = False, timeout = None, verify = True
cert = None, proxies = {}, hooks = {'response': []}

[1m    def send(self, request, **kwargs):[0m
[1m        """Send a given PreparedRequest."""[0m
[1m        # Set defaults that the hooks can utilize to ensure they always have[0m
[1m        # the correct parameters to reproduce the previous request.[0m
[1m        kwargs.setdefault('stream', self.stream)[0m
[1m        kwargs.setdefault('verify', self.verify)[0m
[1m        kwargs.setdefault('cert', self.cert)[0m
[1m        kwargs.setdefault('proxies', self.proxies)[0m
[1m    [0m
[1m        # It's possible that users might accidentally send a Request object.[0m
[1m        # Guard against that specific failure case.[0m
[1m        if not isinstance(request, PreparedRequest):[0m
[1m            raise ValueError('You can only send PreparedRequests.')[0m
[1m    [0m
[1m        # Set up variables needed for resolve_redirects and dispatching of[0m
[1m        # hooks[0m
[1m        allow_redirects = kwargs.pop('allow_redirects', True)[0m
[1m        stream = kwargs.get('stream')[0m
[1m        timeout = kwargs.get('timeout')[0m
[1m        verify = kwargs.get('verify')[0m
[1m        cert = kwargs.get('cert')[0m
[1m        proxies = kwargs.get('proxies')[0m
[1m        hooks = request.hooks[0m
[1m    [0m
[1m        # Get the appropriate adapter to use[0m
[1m        adapter = self.get_adapter(url=request.url)[0m
[1m    [0m
[1m        # Start time (approximately) of the request[0m
[1m        start = datetime.utcnow()[0m
[1m        # Send the request[0m
[1m>       r = adapter.send(request, **kwargs)[0m

requests/sessions.py:460: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.adapters.HTTPAdapter object at 0x2a34450>
request = <PreparedRequest [GET]>, stream = False, timeout = None, verify = True
cert = None, proxies = {}

[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):[0m
[1m        """Sends PreparedRequest object. Returns Response object.[0m
[1m    [0m
[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.[0m
[1m            :param stream: (optional) Whether to stream the request content.[0m
[1m            :param timeout: (optional) The timeout on the request.[0m
[1m            :param verify: (optional) Whether to verify SSL certificates.[0m
[1m            :param vert: (optional) Any user-provided SSL certificate to be trusted.[0m
[1m            :param proxies: (optional) The proxies dictionary to apply to the request.[0m
[1m            """[0m
[1m    [0m
[1m        conn = self.get_connection(request.url, proxies)[0m
[1m    [0m
[1m        self.cert_verify(conn, request.url, verify, cert)[0m
[1m        url = self.request_url(request, proxies)[0m
[1m        self.add_headers(request)[0m
[1m    [0m
[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)[0m
[1m    [0m
[1m        if stream:[0m
[1m            timeout = Timeout(connect=timeout)[0m
[1m        else:[0m
[1m>           timeout = Timeout(connect=timeout, read=timeout)[0m
[1m[31mE           TypeError: Timeout does not take keyword arguments[0m

requests/adapters.py:305: TypeError
____________ RequestsTestCase.test_params_are_merged_case_sensitive ____________

self = <test_requests.RequestsTestCase testMethod=test_params_are_merged_case_sensitive>

[1m    def test_params_are_merged_case_sensitive(self):[0m
[1m        s = requests.Session()[0m
[1m        s.params['foo'] = 'bar'[0m
[1m>       r = s.get(httpbin('get'), params={'FOO': 'bar'})[0m

test_requests.py:650: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x2a47a90>
url = 'http://httpbin.org/get'
kwargs = {'allow_redirects': True, 'params': {'FOO': 'bar'}}

[1m    def get(self, url, **kwargs):[0m
[1m        """Sends a GET request. Returns :class:`Response` object.[0m
[1m    [0m
[1m            :param url: URL for the new :class:`Request` object.[0m
[1m            :param \*\*kwargs: Optional arguments that ``request`` takes.[0m
[1m            """[0m
[1m    [0m
[1m        kwargs.setdefault('allow_redirects', True)[0m
[1m>       return self.request('GET', url, **kwargs)[0m

requests/sessions.py:369: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x2a47a90>, method = 'GET'
url = 'http://httpbin.org/get', params = {'FOO': 'bar'}, data = None
headers = None, cookies = None, files = None, auth = None, timeout = None
allow_redirects = True, proxies = OrderedDict(), hooks = None, stream = False
verify = True, cert = None

[1m    def request(self, method, url,[0m
[1m        params=None,[0m
[1m        data=None,[0m
[1m        headers=None,[0m
[1m        cookies=None,[0m
[1m        files=None,[0m
[1m        auth=None,[0m
[1m        timeout=None,[0m
[1m        allow_redirects=True,[0m
[1m        proxies=None,[0m
[1m        hooks=None,[0m
[1m        stream=None,[0m
[1m        verify=None,[0m
[1m        cert=None):[0m
[1m        """Constructs a :class:`Request <Request>`, prepares it and sends it.[0m
[1m            Returns :class:`Response <Response>` object.[0m
[1m    [0m
[1m            :param method: method for the new :class:`Request` object.[0m
[1m            :param url: URL for the new :class:`Request` object.[0m
[1m            :param params: (optional) Dictionary or bytes to be sent in the query[0m
[1m                string for the :class:`Request`.[0m
[1m            :param data: (optional) Dictionary or bytes to send in the body of the[0m
[1m                :class:`Request`.[0m
[1m            :param headers: (optional) Dictionary of HTTP Headers to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param cookies: (optional) Dict or CookieJar object to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param files: (optional) Dictionary of 'filename': file-like-objects[0m
[1m                for multipart encoding upload.[0m
[1m            :param auth: (optional) Auth tuple or callable to enable[0m
[1m                Basic/Digest/Custom HTTP Auth.[0m
[1m            :param timeout: (optional) Float describing the timeout of the[0m
[1m                request.[0m
[1m            :param allow_redirects: (optional) Boolean. Set to True by default.[0m
[1m            :param proxies: (optional) Dictionary mapping protocol to the URL of[0m
[1m                the proxy.[0m
[1m            :param stream: (optional) whether to immediately download the response[0m
[1m                content. Defaults to ``False``.[0m
[1m            :param verify: (optional) if ``True``, the SSL cert will be verified.[0m
[1m                A CA_BUNDLE path can also be provided.[0m
[1m            :param cert: (optional) if String, path to ssl client cert file (.pem).[0m
[1m                If Tuple, ('cert', 'key') pair.[0m
[1m            """[0m
[1m        # Create the Request.[0m
[1m        req = Request([0m
[1m            method = method.upper(),[0m
[1m            url = url,[0m
[1m            headers = headers,[0m
[1m            files = files,[0m
[1m            data = data or {},[0m
[1m            params = params or {},[0m
[1m            auth = auth,[0m
[1m            cookies = cookies,[0m
[1m            hooks = hooks,[0m
[1m        )[0m
[1m        prep = self.prepare_request(req)[0m
[1m    [0m
[1m        proxies = proxies or {}[0m
[1m    [0m
[1m        # Gather clues from the surrounding environment.[0m
[1m        if self.trust_env:[0m
[1m            # Set environment's proxies.[0m
[1m            env_proxies = get_environ_proxies(url) or {}[0m
[1m            for (k, v) in env_proxies.items():[0m
[1m                proxies.setdefault(k, v)[0m
[1m    [0m
[1m            # Look for configuration.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('REQUESTS_CA_BUNDLE')[0m
[1m    [0m
[1m            # Curl compatibility.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('CURL_CA_BUNDLE')[0m
[1m    [0m
[1m        # Merge all the kwargs.[0m
[1m        proxies = merge_setting(proxies, self.proxies)[0m
[1m        stream = merge_setting(stream, self.stream)[0m
[1m        verify = merge_setting(verify, self.verify)[0m
[1m        cert = merge_setting(cert, self.cert)[0m
[1m    [0m
[1m        # Send the request.[0m
[1m        send_kwargs = {[0m
[1m            'stream': stream,[0m
[1m            'timeout': timeout,[0m
[1m            'verify': verify,[0m
[1m            'cert': cert,[0m
[1m            'proxies': proxies,[0m
[1m            'allow_redirects': allow_redirects,[0m
[1m        }[0m
[1m>       resp = self.send(prep, **send_kwargs)[0m

requests/sessions.py:357: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x2a47a90>
request = <PreparedRequest [GET]>
kwargs = {'cert': None, 'proxies': OrderedDict(), 'stream': False, 'timeout': None, ...}
allow_redirects = True, stream = False, timeout = None, verify = True
cert = None, proxies = OrderedDict(), hooks = {'response': []}

[1m    def send(self, request, **kwargs):[0m
[1m        """Send a given PreparedRequest."""[0m
[1m        # Set defaults that the hooks can utilize to ensure they always have[0m
[1m        # the correct parameters to reproduce the previous request.[0m
[1m        kwargs.setdefault('stream', self.stream)[0m
[1m        kwargs.setdefault('verify', self.verify)[0m
[1m        kwargs.setdefault('cert', self.cert)[0m
[1m        kwargs.setdefault('proxies', self.proxies)[0m
[1m    [0m
[1m        # It's possible that users might accidentally send a Request object.[0m
[1m        # Guard against that specific failure case.[0m
[1m        if not isinstance(request, PreparedRequest):[0m
[1m            raise ValueError('You can only send PreparedRequests.')[0m
[1m    [0m
[1m        # Set up variables needed for resolve_redirects and dispatching of[0m
[1m        # hooks[0m
[1m        allow_redirects = kwargs.pop('allow_redirects', True)[0m
[1m        stream = kwargs.get('stream')[0m
[1m        timeout = kwargs.get('timeout')[0m
[1m        verify = kwargs.get('verify')[0m
[1m        cert = kwargs.get('cert')[0m
[1m        proxies = kwargs.get('proxies')[0m
[1m        hooks = request.hooks[0m
[1m    [0m
[1m        # Get the appropriate adapter to use[0m
[1m        adapter = self.get_adapter(url=request.url)[0m
[1m    [0m
[1m        # Start time (approximately) of the request[0m
[1m        start = datetime.utcnow()[0m
[1m        # Send the request[0m
[1m>       r = adapter.send(request, **kwargs)[0m

requests/sessions.py:460: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.adapters.HTTPAdapter object at 0x2a47f90>
request = <PreparedRequest [GET]>, stream = False, timeout = None, verify = True
cert = None, proxies = OrderedDict()

[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):[0m
[1m        """Sends PreparedRequest object. Returns Response object.[0m
[1m    [0m
[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.[0m
[1m            :param stream: (optional) Whether to stream the request content.[0m
[1m            :param timeout: (optional) The timeout on the request.[0m
[1m            :param verify: (optional) Whether to verify SSL certificates.[0m
[1m            :param vert: (optional) Any user-provided SSL certificate to be trusted.[0m
[1m            :param proxies: (optional) The proxies dictionary to apply to the request.[0m
[1m            """[0m
[1m    [0m
[1m        conn = self.get_connection(request.url, proxies)[0m
[1m    [0m
[1m        self.cert_verify(conn, request.url, verify, cert)[0m
[1m        url = self.request_url(request, proxies)[0m
[1m        self.add_headers(request)[0m
[1m    [0m
[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)[0m
[1m    [0m
[1m        if stream:[0m
[1m            timeout = Timeout(connect=timeout)[0m
[1m        else:[0m
[1m>           timeout = Timeout(connect=timeout, read=timeout)[0m
[1m[31mE           TypeError: Timeout does not take keyword arguments[0m

requests/adapters.py:305: TypeError
_________________ RequestsTestCase.test_prepared_from_session __________________

self = <test_requests.RequestsTestCase testMethod=test_prepared_from_session>

[1m    def test_prepared_from_session(self):[0m
[1m        class DummyAuth(requests.auth.AuthBase):[0m
[1m            def __call__(self, r):[0m
[1m                r.headers['Dummy-Auth-Test'] = 'dummy-auth-test-ok'[0m
[1m                return r[0m
[1m    [0m
[1m        req = requests.Request('GET', httpbin('headers'))[0m
[1m        self.assertEqual(req.auth, None)[0m
[1m    [0m
[1m        s = requests.Session()[0m
[1m        s.auth = DummyAuth()[0m
[1m    [0m
[1m        prep = s.prepare_request(req)[0m
[1m>       resp = s.send(prep)[0m

test_requests.py:479: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x2a29150>
request = <PreparedRequest [GET]>
kwargs = {'cert': None, 'proxies': {}, 'stream': False, 'verify': True}
allow_redirects = True, stream = False, timeout = None, verify = True
cert = None, proxies = {}, hooks = {'response': []}

[1m    def send(self, request, **kwargs):[0m
[1m        """Send a given PreparedRequest."""[0m
[1m        # Set defaults that the hooks can utilize to ensure they always have[0m
[1m        # the correct parameters to reproduce the previous request.[0m
[1m        kwargs.setdefault('stream', self.stream)[0m
[1m        kwargs.setdefault('verify', self.verify)[0m
[1m        kwargs.setdefault('cert', self.cert)[0m
[1m        kwargs.setdefault('proxies', self.proxies)[0m
[1m    [0m
[1m        # It's possible that users might accidentally send a Request object.[0m
[1m        # Guard against that specific failure case.[0m
[1m        if not isinstance(request, PreparedRequest):[0m
[1m            raise ValueError('You can only send PreparedRequests.')[0m
[1m    [0m
[1m        # Set up variables needed for resolve_redirects and dispatching of[0m
[1m        # hooks[0m
[1m        allow_redirects = kwargs.pop('allow_redirects', True)[0m
[1m        stream = kwargs.get('stream')[0m
[1m        timeout = kwargs.get('timeout')[0m
[1m        verify = kwargs.get('verify')[0m
[1m        cert = kwargs.get('cert')[0m
[1m        proxies = kwargs.get('proxies')[0m
[1m        hooks = request.hooks[0m
[1m    [0m
[1m        # Get the appropriate adapter to use[0m
[1m        adapter = self.get_adapter(url=request.url)[0m
[1m    [0m
[1m        # Start time (approximately) of the request[0m
[1m        start = datetime.utcnow()[0m
[1m        # Send the request[0m
[1m>       r = adapter.send(request, **kwargs)[0m

requests/sessions.py:460: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.adapters.HTTPAdapter object at 0x2a29f10>
request = <PreparedRequest [GET]>, stream = False, timeout = None, verify = True
cert = None, proxies = {}

[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):[0m
[1m        """Sends PreparedRequest object. Returns Response object.[0m
[1m    [0m
[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.[0m
[1m            :param stream: (optional) Whether to stream the request content.[0m
[1m            :param timeout: (optional) The timeout on the request.[0m
[1m            :param verify: (optional) Whether to verify SSL certificates.[0m
[1m            :param vert: (optional) Any user-provided SSL certificate to be trusted.[0m
[1m            :param proxies: (optional) The proxies dictionary to apply to the request.[0m
[1m            """[0m
[1m    [0m
[1m        conn = self.get_connection(request.url, proxies)[0m
[1m    [0m
[1m        self.cert_verify(conn, request.url, verify, cert)[0m
[1m        url = self.request_url(request, proxies)[0m
[1m        self.add_headers(request)[0m
[1m    [0m
[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)[0m
[1m    [0m
[1m        if stream:[0m
[1m            timeout = Timeout(connect=timeout)[0m
[1m        else:[0m
[1m>           timeout = Timeout(connect=timeout, read=timeout)[0m
[1m[31mE           TypeError: Timeout does not take keyword arguments[0m

requests/adapters.py:305: TypeError
_________________ RequestsTestCase.test_prepared_request_hook __________________

self = <test_requests.RequestsTestCase testMethod=test_prepared_request_hook>

[1m    def test_prepared_request_hook(self):[0m
[1m        def hook(resp, **kwargs):[0m
[1m            resp.hook_working = True[0m
[1m            return resp[0m
[1m    [0m
[1m        req = requests.Request('GET', HTTPBIN, hooks={'response': hook})[0m
[1m        prep = req.prepare()[0m
[1m    [0m
[1m        s = requests.Session()[0m
[1m        s.proxies = getproxies()[0m
[1m>       resp = s.send(prep)[0m

test_requests.py:462: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x275c650>
request = <PreparedRequest [GET]>
kwargs = {'cert': None, 'proxies': {}, 'stream': False, 'verify': True}
allow_redirects = True, stream = False, timeout = None, verify = True
cert = None, proxies = {}, hooks = {'response': [<function hook at 0x29336e0>]}

[1m    def send(self, request, **kwargs):[0m
[1m        """Send a given PreparedRequest."""[0m
[1m        # Set defaults that the hooks can utilize to ensure they always have[0m
[1m        # the correct parameters to reproduce the previous request.[0m
[1m        kwargs.setdefault('stream', self.stream)[0m
[1m        kwargs.setdefault('verify', self.verify)[0m
[1m        kwargs.setdefault('cert', self.cert)[0m
[1m        kwargs.setdefault('proxies', self.proxies)[0m
[1m    [0m
[1m        # It's possible that users might accidentally send a Request object.[0m
[1m        # Guard against that specific failure case.[0m
[1m        if not isinstance(request, PreparedRequest):[0m
[1m            raise ValueError('You can only send PreparedRequests.')[0m
[1m    [0m
[1m        # Set up variables needed for resolve_redirects and dispatching of[0m
[1m        # hooks[0m
[1m        allow_redirects = kwargs.pop('allow_redirects', True)[0m
[1m        stream = kwargs.get('stream')[0m
[1m        timeout = kwargs.get('timeout')[0m
[1m        verify = kwargs.get('verify')[0m
[1m        cert = kwargs.get('cert')[0m
[1m        proxies = kwargs.get('proxies')[0m
[1m        hooks = request.hooks[0m
[1m    [0m
[1m        # Get the appropriate adapter to use[0m
[1m        adapter = self.get_adapter(url=request.url)[0m
[1m    [0m
[1m        # Start time (approximately) of the request[0m
[1m        start = datetime.utcnow()[0m
[1m        # Send the request[0m
[1m>       r = adapter.send(request, **kwargs)[0m

requests/sessions.py:460: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.adapters.HTTPAdapter object at 0x275c810>
request = <PreparedRequest [GET]>, stream = False, timeout = None, verify = True
cert = None, proxies = {}

[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):[0m
[1m        """Sends PreparedRequest object. Returns Response object.[0m
[1m    [0m
[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.[0m
[1m            :param stream: (optional) Whether to stream the request content.[0m
[1m            :param timeout: (optional) The timeout on the request.[0m
[1m            :param verify: (optional) Whether to verify SSL certificates.[0m
[1m            :param vert: (optional) Any user-provided SSL certificate to be trusted.[0m
[1m            :param proxies: (optional) The proxies dictionary to apply to the request.[0m
[1m            """[0m
[1m    [0m
[1m        conn = self.get_connection(request.url, proxies)[0m
[1m    [0m
[1m        self.cert_verify(conn, request.url, verify, cert)[0m
[1m        url = self.request_url(request, proxies)[0m
[1m        self.add_headers(request)[0m
[1m    [0m
[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)[0m
[1m    [0m
[1m        if stream:[0m
[1m            timeout = Timeout(connect=timeout)[0m
[1m        else:[0m
[1m>           timeout = Timeout(connect=timeout, read=timeout)[0m
[1m[31mE           TypeError: Timeout does not take keyword arguments[0m

requests/adapters.py:305: TypeError
________ RequestsTestCase.test_request_cookie_overrides_session_cookie _________

self = <test_requests.RequestsTestCase testMethod=test_request_cookie_overrides_session_cookie>

[1m    def test_request_cookie_overrides_session_cookie(self):[0m
[1m        s = requests.session()[0m
[1m        s.cookies['foo'] = 'bar'[0m
[1m>       r = s.get(httpbin('cookies'), cookies={'foo': 'baz'})[0m

test_requests.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x2a3e210>
url = 'http://httpbin.org/cookies'
kwargs = {'allow_redirects': True, 'cookies': {'foo': 'baz'}}

[1m    def get(self, url, **kwargs):[0m
[1m        """Sends a GET request. Returns :class:`Response` object.[0m
[1m    [0m
[1m            :param url: URL for the new :class:`Request` object.[0m
[1m            :param \*\*kwargs: Optional arguments that ``request`` takes.[0m
[1m            """[0m
[1m    [0m
[1m        kwargs.setdefault('allow_redirects', True)[0m
[1m>       return self.request('GET', url, **kwargs)[0m

requests/sessions.py:369: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x2a3e210>, method = 'GET'
url = 'http://httpbin.org/cookies', params = None, data = None, headers = None
cookies = {'foo': 'baz'}, files = None, auth = None, timeout = None
allow_redirects = True, proxies = OrderedDict(), hooks = None, stream = False
verify = True, cert = None

[1m    def request(self, method, url,[0m
[1m        params=None,[0m
[1m        data=None,[0m
[1m        headers=None,[0m
[1m        cookies=None,[0m
[1m        files=None,[0m
[1m        auth=None,[0m
[1m        timeout=None,[0m
[1m        allow_redirects=True,[0m
[1m        proxies=None,[0m
[1m        hooks=None,[0m
[1m        stream=None,[0m
[1m        verify=None,[0m
[1m        cert=None):[0m
[1m        """Constructs a :class:`Request <Request>`, prepares it and sends it.[0m
[1m            Returns :class:`Response <Response>` object.[0m
[1m    [0m
[1m            :param method: method for the new :class:`Request` object.[0m
[1m            :param url: URL for the new :class:`Request` object.[0m
[1m            :param params: (optional) Dictionary or bytes to be sent in the query[0m
[1m                string for the :class:`Request`.[0m
[1m            :param data: (optional) Dictionary or bytes to send in the body of the[0m
[1m                :class:`Request`.[0m
[1m            :param headers: (optional) Dictionary of HTTP Headers to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param cookies: (optional) Dict or CookieJar object to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param files: (optional) Dictionary of 'filename': file-like-objects[0m
[1m                for multipart encoding upload.[0m
[1m            :param auth: (optional) Auth tuple or callable to enable[0m
[1m                Basic/Digest/Custom HTTP Auth.[0m
[1m            :param timeout: (optional) Float describing the timeout of the[0m
[1m                request.[0m
[1m            :param allow_redirects: (optional) Boolean. Set to True by default.[0m
[1m            :param proxies: (optional) Dictionary mapping protocol to the URL of[0m
[1m                the proxy.[0m
[1m            :param stream: (optional) whether to immediately download the response[0m
[1m                content. Defaults to ``False``.[0m
[1m            :param verify: (optional) if ``True``, the SSL cert will be verified.[0m
[1m                A CA_BUNDLE path can also be provided.[0m
[1m            :param cert: (optional) if String, path to ssl client cert file (.pem).[0m
[1m                If Tuple, ('cert', 'key') pair.[0m
[1m            """[0m
[1m        # Create the Request.[0m
[1m        req = Request([0m
[1m            method = method.upper(),[0m
[1m            url = url,[0m
[1m            headers = headers,[0m
[1m            files = files,[0m
[1m            data = data or {},[0m
[1m            params = params or {},[0m
[1m            auth = auth,[0m
[1m            cookies = cookies,[0m
[1m            hooks = hooks,[0m
[1m        )[0m
[1m        prep = self.prepare_request(req)[0m
[1m    [0m
[1m        proxies = proxies or {}[0m
[1m    [0m
[1m        # Gather clues from the surrounding environment.[0m
[1m        if self.trust_env:[0m
[1m            # Set environment's proxies.[0m
[1m            env_proxies = get_environ_proxies(url) or {}[0m
[1m            for (k, v) in env_proxies.items():[0m
[1m                proxies.setdefault(k, v)[0m
[1m    [0m
[1m            # Look for configuration.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('REQUESTS_CA_BUNDLE')[0m
[1m    [0m
[1m            # Curl compatibility.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('CURL_CA_BUNDLE')[0m
[1m    [0m
[1m        # Merge all the kwargs.[0m
[1m        proxies = merge_setting(proxies, self.proxies)[0m
[1m        stream = merge_setting(stream, self.stream)[0m
[1m        verify = merge_setting(verify, self.verify)[0m
[1m        cert = merge_setting(cert, self.cert)[0m
[1m    [0m
[1m        # Send the request.[0m
[1m        send_kwargs = {[0m
[1m            'stream': stream,[0m
[1m            'timeout': timeout,[0m
[1m            'verify': verify,[0m
[1m            'cert': cert,[0m
[1m            'proxies': proxies,[0m
[1m            'allow_redirects': allow_redirects,[0m
[1m        }[0m
[1m>       resp = self.send(prep, **send_kwargs)[0m

requests/sessions.py:357: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x2a3e210>
request = <PreparedRequest [GET]>
kwargs = {'cert': None, 'proxies': OrderedDict(), 'stream': False, 'timeout': None, ...}
allow_redirects = True, stream = False, timeout = None, verify = True
cert = None, proxies = OrderedDict(), hooks = {'response': []}

[1m    def send(self, request, **kwargs):[0m
[1m        """Send a given PreparedRequest."""[0m
[1m        # Set defaults that the hooks can utilize to ensure they always have[0m
[1m        # the correct parameters to reproduce the previous request.[0m
[1m        kwargs.setdefault('stream', self.stream)[0m
[1m        kwargs.setdefault('verify', self.verify)[0m
[1m        kwargs.setdefault('cert', self.cert)[0m
[1m        kwargs.setdefault('proxies', self.proxies)[0m
[1m    [0m
[1m        # It's possible that users might accidentally send a Request object.[0m
[1m        # Guard against that specific failure case.[0m
[1m        if not isinstance(request, PreparedRequest):[0m
[1m            raise ValueError('You can only send PreparedRequests.')[0m
[1m    [0m
[1m        # Set up variables needed for resolve_redirects and dispatching of[0m
[1m        # hooks[0m
[1m        allow_redirects = kwargs.pop('allow_redirects', True)[0m
[1m        stream = kwargs.get('stream')[0m
[1m        timeout = kwargs.get('timeout')[0m
[1m        verify = kwargs.get('verify')[0m
[1m        cert = kwargs.get('cert')[0m
[1m        proxies = kwargs.get('proxies')[0m
[1m        hooks = request.hooks[0m
[1m    [0m
[1m        # Get the appropriate adapter to use[0m
[1m        adapter = self.get_adapter(url=request.url)[0m
[1m    [0m
[1m        # Start time (approximately) of the request[0m
[1m        start = datetime.utcnow()[0m
[1m        # Send the request[0m
[1m>       r = adapter.send(request, **kwargs)[0m

requests/sessions.py:460: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.adapters.HTTPAdapter object at 0x2a3e3d0>
request = <PreparedRequest [GET]>, stream = False, timeout = None, verify = True
cert = None, proxies = OrderedDict()

[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):[0m
[1m        """Sends PreparedRequest object. Returns Response object.[0m
[1m    [0m
[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.[0m
[1m            :param stream: (optional) Whether to stream the request content.[0m
[1m            :param timeout: (optional) The timeout on the request.[0m
[1m            :param verify: (optional) Whether to verify SSL certificates.[0m
[1m            :param vert: (optional) Any user-provided SSL certificate to be trusted.[0m
[1m            :param proxies: (optional) The proxies dictionary to apply to the request.[0m
[1m            """[0m
[1m    [0m
[1m        conn = self.get_connection(request.url, proxies)[0m
[1m    [0m
[1m        self.cert_verify(conn, request.url, verify, cert)[0m
[1m        url = self.request_url(request, proxies)[0m
[1m        self.add_headers(request)[0m
[1m    [0m
[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)[0m
[1m    [0m
[1m        if stream:[0m
[1m            timeout = Timeout(connect=timeout)[0m
[1m        else:[0m
[1m>           timeout = Timeout(connect=timeout, read=timeout)[0m
[1m[31mE           TypeError: Timeout does not take keyword arguments[0m

requests/adapters.py:305: TypeError
_____________________ RequestsTestCase.test_request_ok_set _____________________

self = <test_requests.RequestsTestCase testMethod=test_request_ok_set>

[1m    def test_request_ok_set(self):[0m
[1m>       r = requests.get(httpbin('status', '404'))[0m

test_requests.py:366: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

url = 'http://httpbin.org/status/404', kwargs = {'allow_redirects': True}

[1m    def get(url, **kwargs):[0m
[1m        """Sends a GET request. Returns :class:`Response` object.[0m
[1m    [0m
[1m        :param url: URL for the new :class:`Request` object.[0m
[1m        :param \*\*kwargs: Optional arguments that ``request`` takes.[0m
[1m        """[0m
[1m    [0m
[1m        kwargs.setdefault('allow_redirects', True)[0m
[1m>       return request('get', url, **kwargs)[0m

requests/api.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

method = 'get', url = 'http://httpbin.org/status/404'
kwargs = {'allow_redirects': True}
session = <requests.sessions.Session object at 0x276af10>

[1m    def request(method, url, **kwargs):[0m
[1m        """Constructs and sends a :class:`Request <Request>`.[0m
[1m        Returns :class:`Response <Response>` object.[0m
[1m    [0m
[1m        :param method: method for the new :class:`Request` object.[0m
[1m        :param url: URL for the new :class:`Request` object.[0m
[1m        :param params: (optional) Dictionary or bytes to be sent in the query string for the :class:`Request`.[0m
[1m        :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.[0m
[1m        :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.[0m
[1m        :param cookies: (optional) Dict or CookieJar object to send with the :class:`Request`.[0m
[1m        :param files: (optional) Dictionary of 'name': file-like-objects (or {'name': ('filename', fileobj)}) for multipart encoding upload.[0m
[1m        :param auth: (optional) Auth tuple to enable Basic/Digest/Custom HTTP Auth.[0m
[1m        :param timeout: (optional) Float describing the timeout of the request.[0m
[1m        :param allow_redirects: (optional) Boolean. Set to True if POST/PUT/DELETE redirect following is allowed.[0m
[1m        :param proxies: (optional) Dictionary mapping protocol to the URL of the proxy.[0m
[1m        :param verify: (optional) if ``True``, the SSL cert will be verified. A CA_BUNDLE path can also be provided.[0m
[1m        :param stream: (optional) if ``False``, the response content will be immediately downloaded.[0m
[1m        :param cert: (optional) if String, path to ssl client cert file (.pem). If Tuple, ('cert', 'key') pair.[0m
[1m    [0m
[1m        Usage::[0m
[1m    [0m
[1m          >>> import requests[0m
[1m          >>> req = requests.request('GET', 'http://httpbin.org/get')[0m
[1m          <Response [200]>[0m
[1m        """[0m
[1m    [0m
[1m        session = sessions.Session()[0m
[1m>       return session.request(method=method, url=url, **kwargs)[0m

requests/api.py:44: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x276af10>, method = 'get'
url = 'http://httpbin.org/status/404', params = None, data = None
headers = None, cookies = None, files = None, auth = None, timeout = None
allow_redirects = True, proxies = OrderedDict(), hooks = None, stream = False
verify = True, cert = None

[1m    def request(self, method, url,[0m
[1m        params=None,[0m
[1m        data=None,[0m
[1m        headers=None,[0m
[1m        cookies=None,[0m
[1m        files=None,[0m
[1m        auth=None,[0m
[1m        timeout=None,[0m
[1m        allow_redirects=True,[0m
[1m        proxies=None,[0m
[1m        hooks=None,[0m
[1m        stream=None,[0m
[1m        verify=None,[0m
[1m        cert=None):[0m
[1m        """Constructs a :class:`Request <Request>`, prepares it and sends it.[0m
[1m            Returns :class:`Response <Response>` object.[0m
[1m    [0m
[1m            :param method: method for the new :class:`Request` object.[0m
[1m            :param url: URL for the new :class:`Request` object.[0m
[1m            :param params: (optional) Dictionary or bytes to be sent in the query[0m
[1m                string for the :class:`Request`.[0m
[1m            :param data: (optional) Dictionary or bytes to send in the body of the[0m
[1m                :class:`Request`.[0m
[1m            :param headers: (optional) Dictionary of HTTP Headers to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param cookies: (optional) Dict or CookieJar object to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param files: (optional) Dictionary of 'filename': file-like-objects[0m
[1m                for multipart encoding upload.[0m
[1m            :param auth: (optional) Auth tuple or callable to enable[0m
[1m                Basic/Digest/Custom HTTP Auth.[0m
[1m            :param timeout: (optional) Float describing the timeout of the[0m
[1m                request.[0m
[1m            :param allow_redirects: (optional) Boolean. Set to True by default.[0m
[1m            :param proxies: (optional) Dictionary mapping protocol to the URL of[0m
[1m                the proxy.[0m
[1m            :param stream: (optional) whether to immediately download the response[0m
[1m                content. Defaults to ``False``.[0m
[1m            :param verify: (optional) if ``True``, the SSL cert will be verified.[0m
[1m                A CA_BUNDLE path can also be provided.[0m
[1m            :param cert: (optional) if String, path to ssl client cert file (.pem).[0m
[1m                If Tuple, ('cert', 'key') pair.[0m
[1m            """[0m
[1m        # Create the Request.[0m
[1m        req = Request([0m
[1m            method = method.upper(),[0m
[1m            url = url,[0m
[1m            headers = headers,[0m
[1m            files = files,[0m
[1m            data = data or {},[0m
[1m            params = params or {},[0m
[1m            auth = auth,[0m
[1m            cookies = cookies,[0m
[1m            hooks = hooks,[0m
[1m        )[0m
[1m        prep = self.prepare_request(req)[0m
[1m    [0m
[1m        proxies = proxies or {}[0m
[1m    [0m
[1m        # Gather clues from the surrounding environment.[0m
[1m        if self.trust_env:[0m
[1m            # Set environment's proxies.[0m
[1m            env_proxies = get_environ_proxies(url) or {}[0m
[1m            for (k, v) in env_proxies.items():[0m
[1m                proxies.setdefault(k, v)[0m
[1m    [0m
[1m            # Look for configuration.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('REQUESTS_CA_BUNDLE')[0m
[1m    [0m
[1m            # Curl compatibility.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('CURL_CA_BUNDLE')[0m
[1m    [0m
[1m        # Merge all the kwargs.[0m
[1m        proxies = merge_setting(proxies, self.proxies)[0m
[1m        stream = merge_setting(stream, self.stream)[0m
[1m        verify = merge_setting(verify, self.verify)[0m
[1m        cert = merge_setting(cert, self.cert)[0m
[1m    [0m
[1m        # Send the request.[0m
[1m        send_kwargs = {[0m
[1m            'stream': stream,[0m
[1m            'timeout': timeout,[0m
[1m            'verify': verify,[0m
[1m            'cert': cert,[0m
[1m            'proxies': proxies,[0m
[1m            'allow_redirects': allow_redirects,[0m
[1m        }[0m
[1m>       resp = self.send(prep, **send_kwargs)[0m

requests/sessions.py:357: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x276af10>
request = <PreparedRequest [GET]>
kwargs = {'cert': None, 'proxies': OrderedDict(), 'stream': False, 'timeout': None, ...}
allow_redirects = True, stream = False, timeout = None, verify = True
cert = None, proxies = OrderedDict(), hooks = {'response': []}

[1m    def send(self, request, **kwargs):[0m
[1m        """Send a given PreparedRequest."""[0m
[1m        # Set defaults that the hooks can utilize to ensure they always have[0m
[1m        # the correct parameters to reproduce the previous request.[0m
[1m        kwargs.setdefault('stream', self.stream)[0m
[1m        kwargs.setdefault('verify', self.verify)[0m
[1m        kwargs.setdefault('cert', self.cert)[0m
[1m        kwargs.setdefault('proxies', self.proxies)[0m
[1m    [0m
[1m        # It's possible that users might accidentally send a Request object.[0m
[1m        # Guard against that specific failure case.[0m
[1m        if not isinstance(request, PreparedRequest):[0m
[1m            raise ValueError('You can only send PreparedRequests.')[0m
[1m    [0m
[1m        # Set up variables needed for resolve_redirects and dispatching of[0m
[1m        # hooks[0m
[1m        allow_redirects = kwargs.pop('allow_redirects', True)[0m
[1m        stream = kwargs.get('stream')[0m
[1m        timeout = kwargs.get('timeout')[0m
[1m        verify = kwargs.get('verify')[0m
[1m        cert = kwargs.get('cert')[0m
[1m        proxies = kwargs.get('proxies')[0m
[1m        hooks = request.hooks[0m
[1m    [0m
[1m        # Get the appropriate adapter to use[0m
[1m        adapter = self.get_adapter(url=request.url)[0m
[1m    [0m
[1m        # Start time (approximately) of the request[0m
[1m        start = datetime.utcnow()[0m
[1m        # Send the request[0m
[1m>       r = adapter.send(request, **kwargs)[0m

requests/sessions.py:460: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.adapters.HTTPAdapter object at 0x276a290>
request = <PreparedRequest [GET]>, stream = False, timeout = None, verify = True
cert = None, proxies = OrderedDict()

[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):[0m
[1m        """Sends PreparedRequest object. Returns Response object.[0m
[1m    [0m
[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.[0m
[1m            :param stream: (optional) Whether to stream the request content.[0m
[1m            :param timeout: (optional) The timeout on the request.[0m
[1m            :param verify: (optional) Whether to verify SSL certificates.[0m
[1m            :param vert: (optional) Any user-provided SSL certificate to be trusted.[0m
[1m            :param proxies: (optional) The proxies dictionary to apply to the request.[0m
[1m            """[0m
[1m    [0m
[1m        conn = self.get_connection(request.url, proxies)[0m
[1m    [0m
[1m        self.cert_verify(conn, request.url, verify, cert)[0m
[1m        url = self.request_url(request, proxies)[0m
[1m        self.add_headers(request)[0m
[1m    [0m
[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)[0m
[1m    [0m
[1m        if stream:[0m
[1m            timeout = Timeout(connect=timeout)[0m
[1m        else:[0m
[1m>           timeout = Timeout(connect=timeout, read=timeout)[0m
[1m[31mE           TypeError: Timeout does not take keyword arguments[0m

requests/adapters.py:305: TypeError
_________ RequestsTestCase.test_requests_in_history_are_not_overridden _________

self = <test_requests.RequestsTestCase testMethod=test_requests_in_history_are_not_overridden>

[1m    def test_requests_in_history_are_not_overridden(self):[0m
[1m>       resp = requests.get(httpbin('redirect/3'))[0m

test_requests.py:187: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

url = 'http://httpbin.org/redirect/3', kwargs = {'allow_redirects': True}

[1m    def get(url, **kwargs):[0m
[1m        """Sends a GET request. Returns :class:`Response` object.[0m
[1m    [0m
[1m        :param url: URL for the new :class:`Request` object.[0m
[1m        :param \*\*kwargs: Optional arguments that ``request`` takes.[0m
[1m        """[0m
[1m    [0m
[1m        kwargs.setdefault('allow_redirects', True)[0m
[1m>       return request('get', url, **kwargs)[0m

requests/api.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

method = 'get', url = 'http://httpbin.org/redirect/3'
kwargs = {'allow_redirects': True}
session = <requests.sessions.Session object at 0x26a7910>

[1m    def request(method, url, **kwargs):[0m
[1m        """Constructs and sends a :class:`Request <Request>`.[0m
[1m        Returns :class:`Response <Response>` object.[0m
[1m    [0m
[1m        :param method: method for the new :class:`Request` object.[0m
[1m        :param url: URL for the new :class:`Request` object.[0m
[1m        :param params: (optional) Dictionary or bytes to be sent in the query string for the :class:`Request`.[0m
[1m        :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.[0m
[1m        :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.[0m
[1m        :param cookies: (optional) Dict or CookieJar object to send with the :class:`Request`.[0m
[1m        :param files: (optional) Dictionary of 'name': file-like-objects (or {'name': ('filename', fileobj)}) for multipart encoding upload.[0m
[1m        :param auth: (optional) Auth tuple to enable Basic/Digest/Custom HTTP Auth.[0m
[1m        :param timeout: (optional) Float describing the timeout of the request.[0m
[1m        :param allow_redirects: (optional) Boolean. Set to True if POST/PUT/DELETE redirect following is allowed.[0m
[1m        :param proxies: (optional) Dictionary mapping protocol to the URL of the proxy.[0m
[1m        :param verify: (optional) if ``True``, the SSL cert will be verified. A CA_BUNDLE path can also be provided.[0m
[1m        :param stream: (optional) if ``False``, the response content will be immediately downloaded.[0m
[1m        :param cert: (optional) if String, path to ssl client cert file (.pem). If Tuple, ('cert', 'key') pair.[0m
[1m    [0m
[1m        Usage::[0m
[1m    [0m
[1m          >>> import requests[0m
[1m          >>> req = requests.request('GET', 'http://httpbin.org/get')[0m
[1m          <Response [200]>[0m
[1m        """[0m
[1m    [0m
[1m        session = sessions.Session()[0m
[1m>       return session.request(method=method, url=url, **kwargs)[0m

requests/api.py:44: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x26a7910>, method = 'get'
url = 'http://httpbin.org/redirect/3', params = None, data = None
headers = None, cookies = None, files = None, auth = None, timeout = None
allow_redirects = True, proxies = OrderedDict(), hooks = None, stream = False
verify = True, cert = None

[1m    def request(self, method, url,[0m
[1m        params=None,[0m
[1m        data=None,[0m
[1m        headers=None,[0m
[1m        cookies=None,[0m
[1m        files=None,[0m
[1m        auth=None,[0m
[1m        timeout=None,[0m
[1m        allow_redirects=True,[0m
[1m        proxies=None,[0m
[1m        hooks=None,[0m
[1m        stream=None,[0m
[1m        verify=None,[0m
[1m        cert=None):[0m
[1m        """Constructs a :class:`Request <Request>`, prepares it and sends it.[0m
[1m            Returns :class:`Response <Response>` object.[0m
[1m    [0m
[1m            :param method: method for the new :class:`Request` object.[0m
[1m            :param url: URL for the new :class:`Request` object.[0m
[1m            :param params: (optional) Dictionary or bytes to be sent in the query[0m
[1m                string for the :class:`Request`.[0m
[1m            :param data: (optional) Dictionary or bytes to send in the body of the[0m
[1m                :class:`Request`.[0m
[1m            :param headers: (optional) Dictionary of HTTP Headers to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param cookies: (optional) Dict or CookieJar object to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param files: (optional) Dictionary of 'filename': file-like-objects[0m
[1m                for multipart encoding upload.[0m
[1m            :param auth: (optional) Auth tuple or callable to enable[0m
[1m                Basic/Digest/Custom HTTP Auth.[0m
[1m            :param timeout: (optional) Float describing the timeout of the[0m
[1m                request.[0m
[1m            :param allow_redirects: (optional) Boolean. Set to True by default.[0m
[1m            :param proxies: (optional) Dictionary mapping protocol to the URL of[0m
[1m                the proxy.[0m
[1m            :param stream: (optional) whether to immediately download the response[0m
[1m                content. Defaults to ``False``.[0m
[1m            :param verify: (optional) if ``True``, the SSL cert will be verified.[0m
[1m                A CA_BUNDLE path can also be provided.[0m
[1m            :param cert: (optional) if String, path to ssl client cert file (.pem).[0m
[1m                If Tuple, ('cert', 'key') pair.[0m
[1m            """[0m
[1m        # Create the Request.[0m
[1m        req = Request([0m
[1m            method = method.upper(),[0m
[1m            url = url,[0m
[1m            headers = headers,[0m
[1m            files = files,[0m
[1m            data = data or {},[0m
[1m            params = params or {},[0m
[1m            auth = auth,[0m
[1m            cookies = cookies,[0m
[1m            hooks = hooks,[0m
[1m        )[0m
[1m        prep = self.prepare_request(req)[0m
[1m    [0m
[1m        proxies = proxies or {}[0m
[1m    [0m
[1m        # Gather clues from the surrounding environment.[0m
[1m        if self.trust_env:[0m
[1m            # Set environment's proxies.[0m
[1m            env_proxies = get_environ_proxies(url) or {}[0m
[1m            for (k, v) in env_proxies.items():[0m
[1m                proxies.setdefault(k, v)[0m
[1m    [0m
[1m            # Look for configuration.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('REQUESTS_CA_BUNDLE')[0m
[1m    [0m
[1m            # Curl compatibility.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('CURL_CA_BUNDLE')[0m
[1m    [0m
[1m        # Merge all the kwargs.[0m
[1m        proxies = merge_setting(proxies, self.proxies)[0m
[1m        stream = merge_setting(stream, self.stream)[0m
[1m        verify = merge_setting(verify, self.verify)[0m
[1m        cert = merge_setting(cert, self.cert)[0m
[1m    [0m
[1m        # Send the request.[0m
[1m        send_kwargs = {[0m
[1m            'stream': stream,[0m
[1m            'timeout': timeout,[0m
[1m            'verify': verify,[0m
[1m            'cert': cert,[0m
[1m            'proxies': proxies,[0m
[1m            'allow_redirects': allow_redirects,[0m
[1m        }[0m
[1m>       resp = self.send(prep, **send_kwargs)[0m

requests/sessions.py:357: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x26a7910>
request = <PreparedRequest [GET]>
kwargs = {'cert': None, 'proxies': OrderedDict(), 'stream': False, 'timeout': None, ...}
allow_redirects = True, stream = False, timeout = None, verify = True
cert = None, proxies = OrderedDict(), hooks = {'response': []}

[1m    def send(self, request, **kwargs):[0m
[1m        """Send a given PreparedRequest."""[0m
[1m        # Set defaults that the hooks can utilize to ensure they always have[0m
[1m        # the correct parameters to reproduce the previous request.[0m
[1m        kwargs.setdefault('stream', self.stream)[0m
[1m        kwargs.setdefault('verify', self.verify)[0m
[1m        kwargs.setdefault('cert', self.cert)[0m
[1m        kwargs.setdefault('proxies', self.proxies)[0m
[1m    [0m
[1m        # It's possible that users might accidentally send a Request object.[0m
[1m        # Guard against that specific failure case.[0m
[1m        if not isinstance(request, PreparedRequest):[0m
[1m            raise ValueError('You can only send PreparedRequests.')[0m
[1m    [0m
[1m        # Set up variables needed for resolve_redirects and dispatching of[0m
[1m        # hooks[0m
[1m        allow_redirects = kwargs.pop('allow_redirects', True)[0m
[1m        stream = kwargs.get('stream')[0m
[1m        timeout = kwargs.get('timeout')[0m
[1m        verify = kwargs.get('verify')[0m
[1m        cert = kwargs.get('cert')[0m
[1m        proxies = kwargs.get('proxies')[0m
[1m        hooks = request.hooks[0m
[1m    [0m
[1m        # Get the appropriate adapter to use[0m
[1m        adapter = self.get_adapter(url=request.url)[0m
[1m    [0m
[1m        # Start time (approximately) of the request[0m
[1m        start = datetime.utcnow()[0m
[1m        # Send the request[0m
[1m>       r = adapter.send(request, **kwargs)[0m

requests/sessions.py:460: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.adapters.HTTPAdapter object at 0x26a7fd0>
request = <PreparedRequest [GET]>, stream = False, timeout = None, verify = True
cert = None, proxies = OrderedDict()

[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):[0m
[1m        """Sends PreparedRequest object. Returns Response object.[0m
[1m    [0m
[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.[0m
[1m            :param stream: (optional) Whether to stream the request content.[0m
[1m            :param timeout: (optional) The timeout on the request.[0m
[1m            :param verify: (optional) Whether to verify SSL certificates.[0m
[1m            :param vert: (optional) Any user-provided SSL certificate to be trusted.[0m
[1m            :param proxies: (optional) The proxies dictionary to apply to the request.[0m
[1m            """[0m
[1m    [0m
[1m        conn = self.get_connection(request.url, proxies)[0m
[1m    [0m
[1m        self.cert_verify(conn, request.url, verify, cert)[0m
[1m        url = self.request_url(request, proxies)[0m
[1m        self.add_headers(request)[0m
[1m    [0m
[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)[0m
[1m    [0m
[1m        if stream:[0m
[1m            timeout = Timeout(connect=timeout)[0m
[1m        else:[0m
[1m>           timeout = Timeout(connect=timeout, read=timeout)[0m
[1m[31mE           TypeError: Timeout does not take keyword arguments[0m

requests/adapters.py:305: TypeError
____________________ RequestsTestCase.test_session_pickling ____________________

self = <test_requests.RequestsTestCase testMethod=test_session_pickling>

[1m    def test_session_pickling(self):[0m
[1m        r = requests.Request('GET', httpbin('get'))[0m
[1m        s = requests.Session()[0m
[1m    [0m
[1m        s = pickle.loads(pickle.dumps(s))[0m
[1m        s.proxies = getproxies()[0m
[1m    [0m
[1m>       r = s.send(r.prepare())[0m

test_requests.py:570: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x29d3e10>
request = <PreparedRequest [GET]>
kwargs = {'cert': None, 'proxies': {}, 'stream': False, 'verify': True}
allow_redirects = True, stream = False, timeout = None, verify = True
cert = None, proxies = {}, hooks = {'response': []}

[1m    def send(self, request, **kwargs):[0m
[1m        """Send a given PreparedRequest."""[0m
[1m        # Set defaults that the hooks can utilize to ensure they always have[0m
[1m        # the correct parameters to reproduce the previous request.[0m
[1m        kwargs.setdefault('stream', self.stream)[0m
[1m        kwargs.setdefault('verify', self.verify)[0m
[1m        kwargs.setdefault('cert', self.cert)[0m
[1m        kwargs.setdefault('proxies', self.proxies)[0m
[1m    [0m
[1m        # It's possible that users might accidentally send a Request object.[0m
[1m        # Guard against that specific failure case.[0m
[1m        if not isinstance(request, PreparedRequest):[0m
[1m            raise ValueError('You can only send PreparedRequests.')[0m
[1m    [0m
[1m        # Set up variables needed for resolve_redirects and dispatching of[0m
[1m        # hooks[0m
[1m        allow_redirects = kwargs.pop('allow_redirects', True)[0m
[1m        stream = kwargs.get('stream')[0m
[1m        timeout = kwargs.get('timeout')[0m
[1m        verify = kwargs.get('verify')[0m
[1m        cert = kwargs.get('cert')[0m
[1m        proxies = kwargs.get('proxies')[0m
[1m        hooks = request.hooks[0m
[1m    [0m
[1m        # Get the appropriate adapter to use[0m
[1m        adapter = self.get_adapter(url=request.url)[0m
[1m    [0m
[1m        # Start time (approximately) of the request[0m
[1m        start = datetime.utcnow()[0m
[1m        # Send the request[0m
[1m>       r = adapter.send(request, **kwargs)[0m

requests/sessions.py:460: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.adapters.HTTPAdapter object at 0x29d3e50>
request = <PreparedRequest [GET]>, stream = False, timeout = None, verify = True
cert = None, proxies = {}

[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):[0m
[1m        """Sends PreparedRequest object. Returns Response object.[0m
[1m    [0m
[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.[0m
[1m            :param stream: (optional) Whether to stream the request content.[0m
[1m            :param timeout: (optional) The timeout on the request.[0m
[1m            :param verify: (optional) Whether to verify SSL certificates.[0m
[1m            :param vert: (optional) Any user-provided SSL certificate to be trusted.[0m
[1m            :param proxies: (optional) The proxies dictionary to apply to the request.[0m
[1m            """[0m
[1m    [0m
[1m        conn = self.get_connection(request.url, proxies)[0m
[1m    [0m
[1m        self.cert_verify(conn, request.url, verify, cert)[0m
[1m        url = self.request_url(request, proxies)[0m
[1m        self.add_headers(request)[0m
[1m    [0m
[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)[0m
[1m    [0m
[1m        if stream:[0m
[1m            timeout = Timeout(connect=timeout)[0m
[1m        else:[0m
[1m>           timeout = Timeout(connect=timeout, read=timeout)[0m
[1m[31mE           TypeError: Timeout does not take keyword arguments[0m

requests/adapters.py:305: TypeError
___________________ RequestsTestCase.test_set_cookie_on_301 ____________________

self = <test_requests.RequestsTestCase testMethod=test_set_cookie_on_301>

[1m    def test_set_cookie_on_301(self):[0m
[1m        s = requests.session()[0m
[1m        url = httpbin('cookies/set?foo=bar')[0m
[1m>       r = s.get(url)[0m

test_requests.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x278dd50>
url = 'http://httpbin.org/cookies/set?foo=bar'
kwargs = {'allow_redirects': True}

[1m    def get(self, url, **kwargs):[0m
[1m        """Sends a GET request. Returns :class:`Response` object.[0m
[1m    [0m
[1m            :param url: URL for the new :class:`Request` object.[0m
[1m            :param \*\*kwargs: Optional arguments that ``request`` takes.[0m
[1m            """[0m
[1m    [0m
[1m        kwargs.setdefault('allow_redirects', True)[0m
[1m>       return self.request('GET', url, **kwargs)[0m

requests/sessions.py:369: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x278dd50>, method = 'GET'
url = 'http://httpbin.org/cookies/set?foo=bar', params = None, data = None
headers = None, cookies = None, files = None, auth = None, timeout = None
allow_redirects = True, proxies = OrderedDict(), hooks = None, stream = False
verify = True, cert = None

[1m    def request(self, method, url,[0m
[1m        params=None,[0m
[1m        data=None,[0m
[1m        headers=None,[0m
[1m        cookies=None,[0m
[1m        files=None,[0m
[1m        auth=None,[0m
[1m        timeout=None,[0m
[1m        allow_redirects=True,[0m
[1m        proxies=None,[0m
[1m        hooks=None,[0m
[1m        stream=None,[0m
[1m        verify=None,[0m
[1m        cert=None):[0m
[1m        """Constructs a :class:`Request <Request>`, prepares it and sends it.[0m
[1m            Returns :class:`Response <Response>` object.[0m
[1m    [0m
[1m            :param method: method for the new :class:`Request` object.[0m
[1m            :param url: URL for the new :class:`Request` object.[0m
[1m            :param params: (optional) Dictionary or bytes to be sent in the query[0m
[1m                string for the :class:`Request`.[0m
[1m            :param data: (optional) Dictionary or bytes to send in the body of the[0m
[1m                :class:`Request`.[0m
[1m            :param headers: (optional) Dictionary of HTTP Headers to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param cookies: (optional) Dict or CookieJar object to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param files: (optional) Dictionary of 'filename': file-like-objects[0m
[1m                for multipart encoding upload.[0m
[1m            :param auth: (optional) Auth tuple or callable to enable[0m
[1m                Basic/Digest/Custom HTTP Auth.[0m
[1m            :param timeout: (optional) Float describing the timeout of the[0m
[1m                request.[0m
[1m            :param allow_redirects: (optional) Boolean. Set to True by default.[0m
[1m            :param proxies: (optional) Dictionary mapping protocol to the URL of[0m
[1m                the proxy.[0m
[1m            :param stream: (optional) whether to immediately download the response[0m
[1m                content. Defaults to ``False``.[0m
[1m            :param verify: (optional) if ``True``, the SSL cert will be verified.[0m
[1m                A CA_BUNDLE path can also be provided.[0m
[1m            :param cert: (optional) if String, path to ssl client cert file (.pem).[0m
[1m                If Tuple, ('cert', 'key') pair.[0m
[1m            """[0m
[1m        # Create the Request.[0m
[1m        req = Request([0m
[1m            method = method.upper(),[0m
[1m            url = url,[0m
[1m            headers = headers,[0m
[1m            files = files,[0m
[1m            data = data or {},[0m
[1m            params = params or {},[0m
[1m            auth = auth,[0m
[1m            cookies = cookies,[0m
[1m            hooks = hooks,[0m
[1m        )[0m
[1m        prep = self.prepare_request(req)[0m
[1m    [0m
[1m        proxies = proxies or {}[0m
[1m    [0m
[1m        # Gather clues from the surrounding environment.[0m
[1m        if self.trust_env:[0m
[1m            # Set environment's proxies.[0m
[1m            env_proxies = get_environ_proxies(url) or {}[0m
[1m            for (k, v) in env_proxies.items():[0m
[1m                proxies.setdefault(k, v)[0m
[1m    [0m
[1m            # Look for configuration.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('REQUESTS_CA_BUNDLE')[0m
[1m    [0m
[1m            # Curl compatibility.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('CURL_CA_BUNDLE')[0m
[1m    [0m
[1m        # Merge all the kwargs.[0m
[1m        proxies = merge_setting(proxies, self.proxies)[0m
[1m        stream = merge_setting(stream, self.stream)[0m
[1m        verify = merge_setting(verify, self.verify)[0m
[1m        cert = merge_setting(cert, self.cert)[0m
[1m    [0m
[1m        # Send the request.[0m
[1m        send_kwargs = {[0m
[1m            'stream': stream,[0m
[1m            'timeout': timeout,[0m
[1m            'verify': verify,[0m
[1m            'cert': cert,[0m
[1m            'proxies': proxies,[0m
[1m            'allow_redirects': allow_redirects,[0m
[1m        }[0m
[1m>       resp = self.send(prep, **send_kwargs)[0m

requests/sessions.py:357: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x278dd50>
request = <PreparedRequest [GET]>
kwargs = {'cert': None, 'proxies': OrderedDict(), 'stream': False, 'timeout': None, ...}
allow_redirects = True, stream = False, timeout = None, verify = True
cert = None, proxies = OrderedDict(), hooks = {'response': []}

[1m    def send(self, request, **kwargs):[0m
[1m        """Send a given PreparedRequest."""[0m
[1m        # Set defaults that the hooks can utilize to ensure they always have[0m
[1m        # the correct parameters to reproduce the previous request.[0m
[1m        kwargs.setdefault('stream', self.stream)[0m
[1m        kwargs.setdefault('verify', self.verify)[0m
[1m        kwargs.setdefault('cert', self.cert)[0m
[1m        kwargs.setdefault('proxies', self.proxies)[0m
[1m    [0m
[1m        # It's possible that users might accidentally send a Request object.[0m
[1m        # Guard against that specific failure case.[0m
[1m        if not isinstance(request, PreparedRequest):[0m
[1m            raise ValueError('You can only send PreparedRequests.')[0m
[1m    [0m
[1m        # Set up variables needed for resolve_redirects and dispatching of[0m
[1m        # hooks[0m
[1m        allow_redirects = kwargs.pop('allow_redirects', True)[0m
[1m        stream = kwargs.get('stream')[0m
[1m        timeout = kwargs.get('timeout')[0m
[1m        verify = kwargs.get('verify')[0m
[1m        cert = kwargs.get('cert')[0m
[1m        proxies = kwargs.get('proxies')[0m
[1m        hooks = request.hooks[0m
[1m    [0m
[1m        # Get the appropriate adapter to use[0m
[1m        adapter = self.get_adapter(url=request.url)[0m
[1m    [0m
[1m        # Start time (approximately) of the request[0m
[1m        start = datetime.utcnow()[0m
[1m        # Send the request[0m
[1m>       r = adapter.send(request, **kwargs)[0m

requests/sessions.py:460: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.adapters.HTTPAdapter object at 0x278ded0>
request = <PreparedRequest [GET]>, stream = False, timeout = None, verify = True
cert = None, proxies = OrderedDict()

[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):[0m
[1m        """Sends PreparedRequest object. Returns Response object.[0m
[1m    [0m
[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.[0m
[1m            :param stream: (optional) Whether to stream the request content.[0m
[1m            :param timeout: (optional) The timeout on the request.[0m
[1m            :param verify: (optional) Whether to verify SSL certificates.[0m
[1m            :param vert: (optional) Any user-provided SSL certificate to be trusted.[0m
[1m            :param proxies: (optional) The proxies dictionary to apply to the request.[0m
[1m            """[0m
[1m    [0m
[1m        conn = self.get_connection(request.url, proxies)[0m
[1m    [0m
[1m        self.cert_verify(conn, request.url, verify, cert)[0m
[1m        url = self.request_url(request, proxies)[0m
[1m        self.add_headers(request)[0m
[1m    [0m
[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)[0m
[1m    [0m
[1m        if stream:[0m
[1m            timeout = Timeout(connect=timeout)[0m
[1m        else:[0m
[1m>           timeout = Timeout(connect=timeout, read=timeout)[0m
[1m[31mE           TypeError: Timeout does not take keyword arguments[0m

requests/adapters.py:305: TypeError
_____________________ RequestsTestCase.test_status_raising _____________________

self = <test_requests.RequestsTestCase testMethod=test_status_raising>

[1m    def test_status_raising(self):[0m
[1m>       r = requests.get(httpbin('status', '404'))[0m

test_requests.py:370: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

url = 'http://httpbin.org/status/404', kwargs = {'allow_redirects': True}

[1m    def get(url, **kwargs):[0m
[1m        """Sends a GET request. Returns :class:`Response` object.[0m
[1m    [0m
[1m        :param url: URL for the new :class:`Request` object.[0m
[1m        :param \*\*kwargs: Optional arguments that ``request`` takes.[0m
[1m        """[0m
[1m    [0m
[1m        kwargs.setdefault('allow_redirects', True)[0m
[1m>       return request('get', url, **kwargs)[0m

requests/api.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

method = 'get', url = 'http://httpbin.org/status/404'
kwargs = {'allow_redirects': True}
session = <requests.sessions.Session object at 0x276f450>

[1m    def request(method, url, **kwargs):[0m
[1m        """Constructs and sends a :class:`Request <Request>`.[0m
[1m        Returns :class:`Response <Response>` object.[0m
[1m    [0m
[1m        :param method: method for the new :class:`Request` object.[0m
[1m        :param url: URL for the new :class:`Request` object.[0m
[1m        :param params: (optional) Dictionary or bytes to be sent in the query string for the :class:`Request`.[0m
[1m        :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.[0m
[1m        :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.[0m
[1m        :param cookies: (optional) Dict or CookieJar object to send with the :class:`Request`.[0m
[1m        :param files: (optional) Dictionary of 'name': file-like-objects (or {'name': ('filename', fileobj)}) for multipart encoding upload.[0m
[1m        :param auth: (optional) Auth tuple to enable Basic/Digest/Custom HTTP Auth.[0m
[1m        :param timeout: (optional) Float describing the timeout of the request.[0m
[1m        :param allow_redirects: (optional) Boolean. Set to True if POST/PUT/DELETE redirect following is allowed.[0m
[1m        :param proxies: (optional) Dictionary mapping protocol to the URL of the proxy.[0m
[1m        :param verify: (optional) if ``True``, the SSL cert will be verified. A CA_BUNDLE path can also be provided.[0m
[1m        :param stream: (optional) if ``False``, the response content will be immediately downloaded.[0m
[1m        :param cert: (optional) if String, path to ssl client cert file (.pem). If Tuple, ('cert', 'key') pair.[0m
[1m    [0m
[1m        Usage::[0m
[1m    [0m
[1m          >>> import requests[0m
[1m          >>> req = requests.request('GET', 'http://httpbin.org/get')[0m
[1m          <Response [200]>[0m
[1m        """[0m
[1m    [0m
[1m        session = sessions.Session()[0m
[1m>       return session.request(method=method, url=url, **kwargs)[0m

requests/api.py:44: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x276f450>, method = 'get'
url = 'http://httpbin.org/status/404', params = None, data = None
headers = None, cookies = None, files = None, auth = None, timeout = None
allow_redirects = True, proxies = OrderedDict(), hooks = None, stream = False
verify = True, cert = None

[1m    def request(self, method, url,[0m
[1m        params=None,[0m
[1m        data=None,[0m
[1m        headers=None,[0m
[1m        cookies=None,[0m
[1m        files=None,[0m
[1m        auth=None,[0m
[1m        timeout=None,[0m
[1m        allow_redirects=True,[0m
[1m        proxies=None,[0m
[1m        hooks=None,[0m
[1m        stream=None,[0m
[1m        verify=None,[0m
[1m        cert=None):[0m
[1m        """Constructs a :class:`Request <Request>`, prepares it and sends it.[0m
[1m            Returns :class:`Response <Response>` object.[0m
[1m    [0m
[1m            :param method: method for the new :class:`Request` object.[0m
[1m            :param url: URL for the new :class:`Request` object.[0m
[1m            :param params: (optional) Dictionary or bytes to be sent in the query[0m
[1m                string for the :class:`Request`.[0m
[1m            :param data: (optional) Dictionary or bytes to send in the body of the[0m
[1m                :class:`Request`.[0m
[1m            :param headers: (optional) Dictionary of HTTP Headers to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param cookies: (optional) Dict or CookieJar object to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param files: (optional) Dictionary of 'filename': file-like-objects[0m
[1m                for multipart encoding upload.[0m
[1m            :param auth: (optional) Auth tuple or callable to enable[0m
[1m                Basic/Digest/Custom HTTP Auth.[0m
[1m            :param timeout: (optional) Float describing the timeout of the[0m
[1m                request.[0m
[1m            :param allow_redirects: (optional) Boolean. Set to True by default.[0m
[1m            :param proxies: (optional) Dictionary mapping protocol to the URL of[0m
[1m                the proxy.[0m
[1m            :param stream: (optional) whether to immediately download the response[0m
[1m                content. Defaults to ``False``.[0m
[1m            :param verify: (optional) if ``True``, the SSL cert will be verified.[0m
[1m                A CA_BUNDLE path can also be provided.[0m
[1m            :param cert: (optional) if String, path to ssl client cert file (.pem).[0m
[1m                If Tuple, ('cert', 'key') pair.[0m
[1m            """[0m
[1m        # Create the Request.[0m
[1m        req = Request([0m
[1m            method = method.upper(),[0m
[1m            url = url,[0m
[1m            headers = headers,[0m
[1m            files = files,[0m
[1m            data = data or {},[0m
[1m            params = params or {},[0m
[1m            auth = auth,[0m
[1m            cookies = cookies,[0m
[1m            hooks = hooks,[0m
[1m        )[0m
[1m        prep = self.prepare_request(req)[0m
[1m    [0m
[1m        proxies = proxies or {}[0m
[1m    [0m
[1m        # Gather clues from the surrounding environment.[0m
[1m        if self.trust_env:[0m
[1m            # Set environment's proxies.[0m
[1m            env_proxies = get_environ_proxies(url) or {}[0m
[1m            for (k, v) in env_proxies.items():[0m
[1m                proxies.setdefault(k, v)[0m
[1m    [0m
[1m            # Look for configuration.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('REQUESTS_CA_BUNDLE')[0m
[1m    [0m
[1m            # Curl compatibility.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('CURL_CA_BUNDLE')[0m
[1m    [0m
[1m        # Merge all the kwargs.[0m
[1m        proxies = merge_setting(proxies, self.proxies)[0m
[1m        stream = merge_setting(stream, self.stream)[0m
[1m        verify = merge_setting(verify, self.verify)[0m
[1m        cert = merge_setting(cert, self.cert)[0m
[1m    [0m
[1m        # Send the request.[0m
[1m        send_kwargs = {[0m
[1m            'stream': stream,[0m
[1m            'timeout': timeout,[0m
[1m            'verify': verify,[0m
[1m            'cert': cert,[0m
[1m            'proxies': proxies,[0m
[1m            'allow_redirects': allow_redirects,[0m
[1m        }[0m
[1m>       resp = self.send(prep, **send_kwargs)[0m

requests/sessions.py:357: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x276f450>
request = <PreparedRequest [GET]>
kwargs = {'cert': None, 'proxies': OrderedDict(), 'stream': False, 'timeout': None, ...}
allow_redirects = True, stream = False, timeout = None, verify = True
cert = None, proxies = OrderedDict(), hooks = {'response': []}

[1m    def send(self, request, **kwargs):[0m
[1m        """Send a given PreparedRequest."""[0m
[1m        # Set defaults that the hooks can utilize to ensure they always have[0m
[1m        # the correct parameters to reproduce the previous request.[0m
[1m        kwargs.setdefault('stream', self.stream)[0m
[1m        kwargs.setdefault('verify', self.verify)[0m
[1m        kwargs.setdefault('cert', self.cert)[0m
[1m        kwargs.setdefault('proxies', self.proxies)[0m
[1m    [0m
[1m        # It's possible that users might accidentally send a Request object.[0m
[1m        # Guard against that specific failure case.[0m
[1m        if not isinstance(request, PreparedRequest):[0m
[1m            raise ValueError('You can only send PreparedRequests.')[0m
[1m    [0m
[1m        # Set up variables needed for resolve_redirects and dispatching of[0m
[1m        # hooks[0m
[1m        allow_redirects = kwargs.pop('allow_redirects', True)[0m
[1m        stream = kwargs.get('stream')[0m
[1m        timeout = kwargs.get('timeout')[0m
[1m        verify = kwargs.get('verify')[0m
[1m        cert = kwargs.get('cert')[0m
[1m        proxies = kwargs.get('proxies')[0m
[1m        hooks = request.hooks[0m
[1m    [0m
[1m        # Get the appropriate adapter to use[0m
[1m        adapter = self.get_adapter(url=request.url)[0m
[1m    [0m
[1m        # Start time (approximately) of the request[0m
[1m        start = datetime.utcnow()[0m
[1m        # Send the request[0m
[1m>       r = adapter.send(request, **kwargs)[0m

requests/sessions.py:460: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.adapters.HTTPAdapter object at 0x276f610>
request = <PreparedRequest [GET]>, stream = False, timeout = None, verify = True
cert = None, proxies = OrderedDict()

[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):[0m
[1m        """Sends PreparedRequest object. Returns Response object.[0m
[1m    [0m
[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.[0m
[1m            :param stream: (optional) Whether to stream the request content.[0m
[1m            :param timeout: (optional) The timeout on the request.[0m
[1m            :param verify: (optional) Whether to verify SSL certificates.[0m
[1m            :param vert: (optional) Any user-provided SSL certificate to be trusted.[0m
[1m            :param proxies: (optional) The proxies dictionary to apply to the request.[0m
[1m            """[0m
[1m    [0m
[1m        conn = self.get_connection(request.url, proxies)[0m
[1m    [0m
[1m        self.cert_verify(conn, request.url, verify, cert)[0m
[1m        url = self.request_url(request, proxies)[0m
[1m        self.add_headers(request)[0m
[1m    [0m
[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)[0m
[1m    [0m
[1m        if stream:[0m
[1m            timeout = Timeout(connect=timeout)[0m
[1m        else:[0m
[1m>           timeout = Timeout(connect=timeout, read=timeout)[0m
[1m[31mE           TypeError: Timeout does not take keyword arguments[0m

requests/adapters.py:305: TypeError
___________________ RequestsTestCase.test_time_elapsed_blank ___________________

self = <test_requests.RequestsTestCase testMethod=test_time_elapsed_blank>

[1m    def test_time_elapsed_blank(self):[0m
[1m>       r = requests.get(httpbin('get'))[0m

test_requests.py:526: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

url = 'http://httpbin.org/get', kwargs = {'allow_redirects': True}

[1m    def get(url, **kwargs):[0m
[1m        """Sends a GET request. Returns :class:`Response` object.[0m
[1m    [0m
[1m        :param url: URL for the new :class:`Request` object.[0m
[1m        :param \*\*kwargs: Optional arguments that ``request`` takes.[0m
[1m        """[0m
[1m    [0m
[1m        kwargs.setdefault('allow_redirects', True)[0m
[1m>       return request('get', url, **kwargs)[0m

requests/api.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

method = 'get', url = 'http://httpbin.org/get'
kwargs = {'allow_redirects': True}
session = <requests.sessions.Session object at 0x2794e50>

[1m    def request(method, url, **kwargs):[0m
[1m        """Constructs and sends a :class:`Request <Request>`.[0m
[1m        Returns :class:`Response <Response>` object.[0m
[1m    [0m
[1m        :param method: method for the new :class:`Request` object.[0m
[1m        :param url: URL for the new :class:`Request` object.[0m
[1m        :param params: (optional) Dictionary or bytes to be sent in the query string for the :class:`Request`.[0m
[1m        :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.[0m
[1m        :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.[0m
[1m        :param cookies: (optional) Dict or CookieJar object to send with the :class:`Request`.[0m
[1m        :param files: (optional) Dictionary of 'name': file-like-objects (or {'name': ('filename', fileobj)}) for multipart encoding upload.[0m
[1m        :param auth: (optional) Auth tuple to enable Basic/Digest/Custom HTTP Auth.[0m
[1m        :param timeout: (optional) Float describing the timeout of the request.[0m
[1m        :param allow_redirects: (optional) Boolean. Set to True if POST/PUT/DELETE redirect following is allowed.[0m
[1m        :param proxies: (optional) Dictionary mapping protocol to the URL of the proxy.[0m
[1m        :param verify: (optional) if ``True``, the SSL cert will be verified. A CA_BUNDLE path can also be provided.[0m
[1m        :param stream: (optional) if ``False``, the response content will be immediately downloaded.[0m
[1m        :param cert: (optional) if String, path to ssl client cert file (.pem). If Tuple, ('cert', 'key') pair.[0m
[1m    [0m
[1m        Usage::[0m
[1m    [0m
[1m          >>> import requests[0m
[1m          >>> req = requests.request('GET', 'http://httpbin.org/get')[0m
[1m          <Response [200]>[0m
[1m        """[0m
[1m    [0m
[1m        session = sessions.Session()[0m
[1m>       return session.request(method=method, url=url, **kwargs)[0m

requests/api.py:44: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x2794e50>, method = 'get'
url = 'http://httpbin.org/get', params = None, data = None, headers = None
cookies = None, files = None, auth = None, timeout = None
allow_redirects = True, proxies = OrderedDict(), hooks = None, stream = False
verify = True, cert = None

[1m    def request(self, method, url,[0m
[1m        params=None,[0m
[1m        data=None,[0m
[1m        headers=None,[0m
[1m        cookies=None,[0m
[1m        files=None,[0m
[1m        auth=None,[0m
[1m        timeout=None,[0m
[1m        allow_redirects=True,[0m
[1m        proxies=None,[0m
[1m        hooks=None,[0m
[1m        stream=None,[0m
[1m        verify=None,[0m
[1m        cert=None):[0m
[1m        """Constructs a :class:`Request <Request>`, prepares it and sends it.[0m
[1m            Returns :class:`Response <Response>` object.[0m
[1m    [0m
[1m            :param method: method for the new :class:`Request` object.[0m
[1m            :param url: URL for the new :class:`Request` object.[0m
[1m            :param params: (optional) Dictionary or bytes to be sent in the query[0m
[1m                string for the :class:`Request`.[0m
[1m            :param data: (optional) Dictionary or bytes to send in the body of the[0m
[1m                :class:`Request`.[0m
[1m            :param headers: (optional) Dictionary of HTTP Headers to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param cookies: (optional) Dict or CookieJar object to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param files: (optional) Dictionary of 'filename': file-like-objects[0m
[1m                for multipart encoding upload.[0m
[1m            :param auth: (optional) Auth tuple or callable to enable[0m
[1m                Basic/Digest/Custom HTTP Auth.[0m
[1m            :param timeout: (optional) Float describing the timeout of the[0m
[1m                request.[0m
[1m            :param allow_redirects: (optional) Boolean. Set to True by default.[0m
[1m            :param proxies: (optional) Dictionary mapping protocol to the URL of[0m
[1m                the proxy.[0m
[1m            :param stream: (optional) whether to immediately download the response[0m
[1m                content. Defaults to ``False``.[0m
[1m            :param verify: (optional) if ``True``, the SSL cert will be verified.[0m
[1m                A CA_BUNDLE path can also be provided.[0m
[1m            :param cert: (optional) if String, path to ssl client cert file (.pem).[0m
[1m                If Tuple, ('cert', 'key') pair.[0m
[1m            """[0m
[1m        # Create the Request.[0m
[1m        req = Request([0m
[1m            method = method.upper(),[0m
[1m            url = url,[0m
[1m            headers = headers,[0m
[1m            files = files,[0m
[1m            data = data or {},[0m
[1m            params = params or {},[0m
[1m            auth = auth,[0m
[1m            cookies = cookies,[0m
[1m            hooks = hooks,[0m
[1m        )[0m
[1m        prep = self.prepare_request(req)[0m
[1m    [0m
[1m        proxies = proxies or {}[0m
[1m    [0m
[1m        # Gather clues from the surrounding environment.[0m
[1m        if self.trust_env:[0m
[1m            # Set environment's proxies.[0m
[1m            env_proxies = get_environ_proxies(url) or {}[0m
[1m            for (k, v) in env_proxies.items():[0m
[1m                proxies.setdefault(k, v)[0m
[1m    [0m
[1m            # Look for configuration.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('REQUESTS_CA_BUNDLE')[0m
[1m    [0m
[1m            # Curl compatibility.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('CURL_CA_BUNDLE')[0m
[1m    [0m
[1m        # Merge all the kwargs.[0m
[1m        proxies = merge_setting(proxies, self.proxies)[0m
[1m        stream = merge_setting(stream, self.stream)[0m
[1m        verify = merge_setting(verify, self.verify)[0m
[1m        cert = merge_setting(cert, self.cert)[0m
[1m    [0m
[1m        # Send the request.[0m
[1m        send_kwargs = {[0m
[1m            'stream': stream,[0m
[1m            'timeout': timeout,[0m
[1m            'verify': verify,[0m
[1m            'cert': cert,[0m
[1m            'proxies': proxies,[0m
[1m            'allow_redirects': allow_redirects,[0m
[1m        }[0m
[1m>       resp = self.send(prep, **send_kwargs)[0m

requests/sessions.py:357: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x2794e50>
request = <PreparedRequest [GET]>
kwargs = {'cert': None, 'proxies': OrderedDict(), 'stream': False, 'timeout': None, ...}
allow_redirects = True, stream = False, timeout = None, verify = True
cert = None, proxies = OrderedDict(), hooks = {'response': []}

[1m    def send(self, request, **kwargs):[0m
[1m        """Send a given PreparedRequest."""[0m
[1m        # Set defaults that the hooks can utilize to ensure they always have[0m
[1m        # the correct parameters to reproduce the previous request.[0m
[1m        kwargs.setdefault('stream', self.stream)[0m
[1m        kwargs.setdefault('verify', self.verify)[0m
[1m        kwargs.setdefault('cert', self.cert)[0m
[1m        kwargs.setdefault('proxies', self.proxies)[0m
[1m    [0m
[1m        # It's possible that users might accidentally send a Request object.[0m
[1m        # Guard against that specific failure case.[0m
[1m        if not isinstance(request, PreparedRequest):[0m
[1m            raise ValueError('You can only send PreparedRequests.')[0m
[1m    [0m
[1m        # Set up variables needed for resolve_redirects and dispatching of[0m
[1m        # hooks[0m
[1m        allow_redirects = kwargs.pop('allow_redirects', True)[0m
[1m        stream = kwargs.get('stream')[0m
[1m        timeout = kwargs.get('timeout')[0m
[1m        verify = kwargs.get('verify')[0m
[1m        cert = kwargs.get('cert')[0m
[1m        proxies = kwargs.get('proxies')[0m
[1m        hooks = request.hooks[0m
[1m    [0m
[1m        # Get the appropriate adapter to use[0m
[1m        adapter = self.get_adapter(url=request.url)[0m
[1m    [0m
[1m        # Start time (approximately) of the request[0m
[1m        start = datetime.utcnow()[0m
[1m        # Send the request[0m
[1m>       r = adapter.send(request, **kwargs)[0m

requests/sessions.py:460: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.adapters.HTTPAdapter object at 0x2794c50>
request = <PreparedRequest [GET]>, stream = False, timeout = None, verify = True
cert = None, proxies = OrderedDict()

[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):[0m
[1m        """Sends PreparedRequest object. Returns Response object.[0m
[1m    [0m
[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.[0m
[1m            :param stream: (optional) Whether to stream the request content.[0m
[1m            :param timeout: (optional) The timeout on the request.[0m
[1m            :param verify: (optional) Whether to verify SSL certificates.[0m
[1m            :param vert: (optional) Any user-provided SSL certificate to be trusted.[0m
[1m            :param proxies: (optional) The proxies dictionary to apply to the request.[0m
[1m            """[0m
[1m    [0m
[1m        conn = self.get_connection(request.url, proxies)[0m
[1m    [0m
[1m        self.cert_verify(conn, request.url, verify, cert)[0m
[1m        url = self.request_url(request, proxies)[0m
[1m        self.add_headers(request)[0m
[1m    [0m
[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)[0m
[1m    [0m
[1m        if stream:[0m
[1m            timeout = Timeout(connect=timeout)[0m
[1m        else:[0m
[1m>           timeout = Timeout(connect=timeout, read=timeout)[0m
[1m[31mE           TypeError: Timeout does not take keyword arguments[0m

requests/adapters.py:305: TypeError
______________________ RequestsTestCase.test_unicode_get _______________________

self = <test_requests.RequestsTestCase testMethod=test_unicode_get>

[1m    def test_unicode_get(self):[0m
[1m        url = httpbin('/get')[0m
[1m>       requests.get(url, params={'foo': 'føø'})[0m

test_requests.py:382: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

url = 'http://httpbin.org/get'
kwargs = {'allow_redirects': True, 'params': {'foo': 'f\xc3\xb8\xc3\xb8'}}

[1m    def get(url, **kwargs):[0m
[1m        """Sends a GET request. Returns :class:`Response` object.[0m
[1m    [0m
[1m        :param url: URL for the new :class:`Request` object.[0m
[1m        :param \*\*kwargs: Optional arguments that ``request`` takes.[0m
[1m        """[0m
[1m    [0m
[1m        kwargs.setdefault('allow_redirects', True)[0m
[1m>       return request('get', url, **kwargs)[0m

requests/api.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

method = 'get', url = 'http://httpbin.org/get'
kwargs = {'allow_redirects': True, 'params': {'foo': 'f\xc3\xb8\xc3\xb8'}}
session = <requests.sessions.Session object at 0x26a8850>

[1m    def request(method, url, **kwargs):[0m
[1m        """Constructs and sends a :class:`Request <Request>`.[0m
[1m        Returns :class:`Response <Response>` object.[0m
[1m    [0m
[1m        :param method: method for the new :class:`Request` object.[0m
[1m        :param url: URL for the new :class:`Request` object.[0m
[1m        :param params: (optional) Dictionary or bytes to be sent in the query string for the :class:`Request`.[0m
[1m        :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.[0m
[1m        :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.[0m
[1m        :param cookies: (optional) Dict or CookieJar object to send with the :class:`Request`.[0m
[1m        :param files: (optional) Dictionary of 'name': file-like-objects (or {'name': ('filename', fileobj)}) for multipart encoding upload.[0m
[1m        :param auth: (optional) Auth tuple to enable Basic/Digest/Custom HTTP Auth.[0m
[1m        :param timeout: (optional) Float describing the timeout of the request.[0m
[1m        :param allow_redirects: (optional) Boolean. Set to True if POST/PUT/DELETE redirect following is allowed.[0m
[1m        :param proxies: (optional) Dictionary mapping protocol to the URL of the proxy.[0m
[1m        :param verify: (optional) if ``True``, the SSL cert will be verified. A CA_BUNDLE path can also be provided.[0m
[1m        :param stream: (optional) if ``False``, the response content will be immediately downloaded.[0m
[1m        :param cert: (optional) if String, path to ssl client cert file (.pem). If Tuple, ('cert', 'key') pair.[0m
[1m    [0m
[1m        Usage::[0m
[1m    [0m
[1m          >>> import requests[0m
[1m          >>> req = requests.request('GET', 'http://httpbin.org/get')[0m
[1m          <Response [200]>[0m
[1m        """[0m
[1m    [0m
[1m        session = sessions.Session()[0m
[1m>       return session.request(method=method, url=url, **kwargs)[0m

requests/api.py:44: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x26a8850>, method = 'get'
url = 'http://httpbin.org/get', params = {'foo': 'f\xc3\xb8\xc3\xb8'}
data = None, headers = None, cookies = None, files = None, auth = None
timeout = None, allow_redirects = True, proxies = OrderedDict(), hooks = None
stream = False, verify = True, cert = None

[1m    def request(self, method, url,[0m
[1m        params=None,[0m
[1m        data=None,[0m
[1m        headers=None,[0m
[1m        cookies=None,[0m
[1m        files=None,[0m
[1m        auth=None,[0m
[1m        timeout=None,[0m
[1m        allow_redirects=True,[0m
[1m        proxies=None,[0m
[1m        hooks=None,[0m
[1m        stream=None,[0m
[1m        verify=None,[0m
[1m        cert=None):[0m
[1m        """Constructs a :class:`Request <Request>`, prepares it and sends it.[0m
[1m            Returns :class:`Response <Response>` object.[0m
[1m    [0m
[1m            :param method: method for the new :class:`Request` object.[0m
[1m            :param url: URL for the new :class:`Request` object.[0m
[1m            :param params: (optional) Dictionary or bytes to be sent in the query[0m
[1m                string for the :class:`Request`.[0m
[1m            :param data: (optional) Dictionary or bytes to send in the body of the[0m
[1m                :class:`Request`.[0m
[1m            :param headers: (optional) Dictionary of HTTP Headers to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param cookies: (optional) Dict or CookieJar object to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param files: (optional) Dictionary of 'filename': file-like-objects[0m
[1m                for multipart encoding upload.[0m
[1m            :param auth: (optional) Auth tuple or callable to enable[0m
[1m                Basic/Digest/Custom HTTP Auth.[0m
[1m            :param timeout: (optional) Float describing the timeout of the[0m
[1m                request.[0m
[1m            :param allow_redirects: (optional) Boolean. Set to True by default.[0m
[1m            :param proxies: (optional) Dictionary mapping protocol to the URL of[0m
[1m                the proxy.[0m
[1m            :param stream: (optional) whether to immediately download the response[0m
[1m                content. Defaults to ``False``.[0m
[1m            :param verify: (optional) if ``True``, the SSL cert will be verified.[0m
[1m                A CA_BUNDLE path can also be provided.[0m
[1m            :param cert: (optional) if String, path to ssl client cert file (.pem).[0m
[1m                If Tuple, ('cert', 'key') pair.[0m
[1m            """[0m
[1m        # Create the Request.[0m
[1m        req = Request([0m
[1m            method = method.upper(),[0m
[1m            url = url,[0m
[1m            headers = headers,[0m
[1m            files = files,[0m
[1m            data = data or {},[0m
[1m            params = params or {},[0m
[1m            auth = auth,[0m
[1m            cookies = cookies,[0m
[1m            hooks = hooks,[0m
[1m        )[0m
[1m        prep = self.prepare_request(req)[0m
[1m    [0m
[1m        proxies = proxies or {}[0m
[1m    [0m
[1m        # Gather clues from the surrounding environment.[0m
[1m        if self.trust_env:[0m
[1m            # Set environment's proxies.[0m
[1m            env_proxies = get_environ_proxies(url) or {}[0m
[1m            for (k, v) in env_proxies.items():[0m
[1m                proxies.setdefault(k, v)[0m
[1m    [0m
[1m            # Look for configuration.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('REQUESTS_CA_BUNDLE')[0m
[1m    [0m
[1m            # Curl compatibility.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('CURL_CA_BUNDLE')[0m
[1m    [0m
[1m        # Merge all the kwargs.[0m
[1m        proxies = merge_setting(proxies, self.proxies)[0m
[1m        stream = merge_setting(stream, self.stream)[0m
[1m        verify = merge_setting(verify, self.verify)[0m
[1m        cert = merge_setting(cert, self.cert)[0m
[1m    [0m
[1m        # Send the request.[0m
[1m        send_kwargs = {[0m
[1m            'stream': stream,[0m
[1m            'timeout': timeout,[0m
[1m            'verify': verify,[0m
[1m            'cert': cert,[0m
[1m            'proxies': proxies,[0m
[1m            'allow_redirects': allow_redirects,[0m
[1m        }[0m
[1m>       resp = self.send(prep, **send_kwargs)[0m

requests/sessions.py:357: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x26a8850>
request = <PreparedRequest [GET]>
kwargs = {'cert': None, 'proxies': OrderedDict(), 'stream': False, 'timeout': None, ...}
allow_redirects = True, stream = False, timeout = None, verify = True
cert = None, proxies = OrderedDict(), hooks = {'response': []}

[1m    def send(self, request, **kwargs):[0m
[1m        """Send a given PreparedRequest."""[0m
[1m        # Set defaults that the hooks can utilize to ensure they always have[0m
[1m        # the correct parameters to reproduce the previous request.[0m
[1m        kwargs.setdefault('stream', self.stream)[0m
[1m        kwargs.setdefault('verify', self.verify)[0m
[1m        kwargs.setdefault('cert', self.cert)[0m
[1m        kwargs.setdefault('proxies', self.proxies)[0m
[1m    [0m
[1m        # It's possible that users might accidentally send a Request object.[0m
[1m        # Guard against that specific failure case.[0m
[1m        if not isinstance(request, PreparedRequest):[0m
[1m            raise ValueError('You can only send PreparedRequests.')[0m
[1m    [0m
[1m        # Set up variables needed for resolve_redirects and dispatching of[0m
[1m        # hooks[0m
[1m        allow_redirects = kwargs.pop('allow_redirects', True)[0m
[1m        stream = kwargs.get('stream')[0m
[1m        timeout = kwargs.get('timeout')[0m
[1m        verify = kwargs.get('verify')[0m
[1m        cert = kwargs.get('cert')[0m
[1m        proxies = kwargs.get('proxies')[0m
[1m        hooks = request.hooks[0m
[1m    [0m
[1m        # Get the appropriate adapter to use[0m
[1m        adapter = self.get_adapter(url=request.url)[0m
[1m    [0m
[1m        # Start time (approximately) of the request[0m
[1m        start = datetime.utcnow()[0m
[1m        # Send the request[0m
[1m>       r = adapter.send(request, **kwargs)[0m

requests/sessions.py:460: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.adapters.HTTPAdapter object at 0x26a8890>
request = <PreparedRequest [GET]>, stream = False, timeout = None, verify = True
cert = None, proxies = OrderedDict()

[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):[0m
[1m        """Sends PreparedRequest object. Returns Response object.[0m
[1m    [0m
[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.[0m
[1m            :param stream: (optional) Whether to stream the request content.[0m
[1m            :param timeout: (optional) The timeout on the request.[0m
[1m            :param verify: (optional) Whether to verify SSL certificates.[0m
[1m            :param vert: (optional) Any user-provided SSL certificate to be trusted.[0m
[1m            :param proxies: (optional) The proxies dictionary to apply to the request.[0m
[1m            """[0m
[1m    [0m
[1m        conn = self.get_connection(request.url, proxies)[0m
[1m    [0m
[1m        self.cert_verify(conn, request.url, verify, cert)[0m
[1m        url = self.request_url(request, proxies)[0m
[1m        self.add_headers(request)[0m
[1m    [0m
[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)[0m
[1m    [0m
[1m        if stream:[0m
[1m            timeout = Timeout(connect=timeout)[0m
[1m        else:[0m
[1m>           timeout = Timeout(connect=timeout, read=timeout)[0m
[1m[31mE           TypeError: Timeout does not take keyword arguments[0m

requests/adapters.py:305: TypeError
__________________ RequestsTestCase.test_unicode_header_name ___________________

self = <test_requests.RequestsTestCase testMethod=test_unicode_header_name>

[1m    def test_unicode_header_name(self):[0m
[1m>       requests.put(httpbin('put'), headers={str('Content-Type'): 'application/octet-stream'}, data='\xff') # compat.str is unicode.[0m

test_requests.py:389: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

url = 'http://httpbin.org/put', data = '\xff'
kwargs = {'headers': {u'Content-Type': 'application/octet-stream'}}

[1m    def put(url, data=None, **kwargs):[0m
[1m        """Sends a PUT request. Returns :class:`Response` object.[0m
[1m    [0m
[1m        :param url: URL for the new :class:`Request` object.[0m
[1m        :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.[0m
[1m        :param \*\*kwargs: Optional arguments that ``request`` takes.[0m
[1m        """[0m
[1m    [0m
[1m>       return request('put', url, data=data, **kwargs)[0m

requests/api.py:99: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

method = 'put', url = 'http://httpbin.org/put'
kwargs = {'data': '\xff', 'headers': {u'Content-Type': 'application/octet-stream'}}
session = <requests.sessions.Session object at 0x276b910>

[1m    def request(method, url, **kwargs):[0m
[1m        """Constructs and sends a :class:`Request <Request>`.[0m
[1m        Returns :class:`Response <Response>` object.[0m
[1m    [0m
[1m        :param method: method for the new :class:`Request` object.[0m
[1m        :param url: URL for the new :class:`Request` object.[0m
[1m        :param params: (optional) Dictionary or bytes to be sent in the query string for the :class:`Request`.[0m
[1m        :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.[0m
[1m        :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.[0m
[1m        :param cookies: (optional) Dict or CookieJar object to send with the :class:`Request`.[0m
[1m        :param files: (optional) Dictionary of 'name': file-like-objects (or {'name': ('filename', fileobj)}) for multipart encoding upload.[0m
[1m        :param auth: (optional) Auth tuple to enable Basic/Digest/Custom HTTP Auth.[0m
[1m        :param timeout: (optional) Float describing the timeout of the request.[0m
[1m        :param allow_redirects: (optional) Boolean. Set to True if POST/PUT/DELETE redirect following is allowed.[0m
[1m        :param proxies: (optional) Dictionary mapping protocol to the URL of the proxy.[0m
[1m        :param verify: (optional) if ``True``, the SSL cert will be verified. A CA_BUNDLE path can also be provided.[0m
[1m        :param stream: (optional) if ``False``, the response content will be immediately downloaded.[0m
[1m        :param cert: (optional) if String, path to ssl client cert file (.pem). If Tuple, ('cert', 'key') pair.[0m
[1m    [0m
[1m        Usage::[0m
[1m    [0m
[1m          >>> import requests[0m
[1m          >>> req = requests.request('GET', 'http://httpbin.org/get')[0m
[1m          <Response [200]>[0m
[1m        """[0m
[1m    [0m
[1m        session = sessions.Session()[0m
[1m>       return session.request(method=method, url=url, **kwargs)[0m

requests/api.py:44: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x276b910>, method = 'put'
url = 'http://httpbin.org/put', params = None, data = '\xff'
headers = {u'Content-Type': 'application/octet-stream'}, cookies = None
files = None, auth = None, timeout = None, allow_redirects = True
proxies = OrderedDict(), hooks = None, stream = False, verify = True
cert = None

[1m    def request(self, method, url,[0m
[1m        params=None,[0m
[1m        data=None,[0m
[1m        headers=None,[0m
[1m        cookies=None,[0m
[1m        files=None,[0m
[1m        auth=None,[0m
[1m        timeout=None,[0m
[1m        allow_redirects=True,[0m
[1m        proxies=None,[0m
[1m        hooks=None,[0m
[1m        stream=None,[0m
[1m        verify=None,[0m
[1m        cert=None):[0m
[1m        """Constructs a :class:`Request <Request>`, prepares it and sends it.[0m
[1m            Returns :class:`Response <Response>` object.[0m
[1m    [0m
[1m            :param method: method for the new :class:`Request` object.[0m
[1m            :param url: URL for the new :class:`Request` object.[0m
[1m            :param params: (optional) Dictionary or bytes to be sent in the query[0m
[1m                string for the :class:`Request`.[0m
[1m            :param data: (optional) Dictionary or bytes to send in the body of the[0m
[1m                :class:`Request`.[0m
[1m            :param headers: (optional) Dictionary of HTTP Headers to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param cookies: (optional) Dict or CookieJar object to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param files: (optional) Dictionary of 'filename': file-like-objects[0m
[1m                for multipart encoding upload.[0m
[1m            :param auth: (optional) Auth tuple or callable to enable[0m
[1m                Basic/Digest/Custom HTTP Auth.[0m
[1m            :param timeout: (optional) Float describing the timeout of the[0m
[1m                request.[0m
[1m            :param allow_redirects: (optional) Boolean. Set to True by default.[0m
[1m            :param proxies: (optional) Dictionary mapping protocol to the URL of[0m
[1m                the proxy.[0m
[1m            :param stream: (optional) whether to immediately download the response[0m
[1m                content. Defaults to ``False``.[0m
[1m            :param verify: (optional) if ``True``, the SSL cert will be verified.[0m
[1m                A CA_BUNDLE path can also be provided.[0m
[1m            :param cert: (optional) if String, path to ssl client cert file (.pem).[0m
[1m                If Tuple, ('cert', 'key') pair.[0m
[1m            """[0m
[1m        # Create the Request.[0m
[1m        req = Request([0m
[1m            method = method.upper(),[0m
[1m            url = url,[0m
[1m            headers = headers,[0m
[1m            files = files,[0m
[1m            data = data or {},[0m
[1m            params = params or {},[0m
[1m            auth = auth,[0m
[1m            cookies = cookies,[0m
[1m            hooks = hooks,[0m
[1m        )[0m
[1m        prep = self.prepare_request(req)[0m
[1m    [0m
[1m        proxies = proxies or {}[0m
[1m    [0m
[1m        # Gather clues from the surrounding environment.[0m
[1m        if self.trust_env:[0m
[1m            # Set environment's proxies.[0m
[1m            env_proxies = get_environ_proxies(url) or {}[0m
[1m            for (k, v) in env_proxies.items():[0m
[1m                proxies.setdefault(k, v)[0m
[1m    [0m
[1m            # Look for configuration.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('REQUESTS_CA_BUNDLE')[0m
[1m    [0m
[1m            # Curl compatibility.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('CURL_CA_BUNDLE')[0m
[1m    [0m
[1m        # Merge all the kwargs.[0m
[1m        proxies = merge_setting(proxies, self.proxies)[0m
[1m        stream = merge_setting(stream, self.stream)[0m
[1m        verify = merge_setting(verify, self.verify)[0m
[1m        cert = merge_setting(cert, self.cert)[0m
[1m    [0m
[1m        # Send the request.[0m
[1m        send_kwargs = {[0m
[1m            'stream': stream,[0m
[1m            'timeout': timeout,[0m
[1m            'verify': verify,[0m
[1m            'cert': cert,[0m
[1m            'proxies': proxies,[0m
[1m            'allow_redirects': allow_redirects,[0m
[1m        }[0m
[1m>       resp = self.send(prep, **send_kwargs)[0m

requests/sessions.py:357: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x276b910>
request = <PreparedRequest [PUT]>
kwargs = {'cert': None, 'proxies': OrderedDict(), 'stream': False, 'timeout': None, ...}
allow_redirects = True, stream = False, timeout = None, verify = True
cert = None, proxies = OrderedDict(), hooks = {'response': []}

[1m    def send(self, request, **kwargs):[0m
[1m        """Send a given PreparedRequest."""[0m
[1m        # Set defaults that the hooks can utilize to ensure they always have[0m
[1m        # the correct parameters to reproduce the previous request.[0m
[1m        kwargs.setdefault('stream', self.stream)[0m
[1m        kwargs.setdefault('verify', self.verify)[0m
[1m        kwargs.setdefault('cert', self.cert)[0m
[1m        kwargs.setdefault('proxies', self.proxies)[0m
[1m    [0m
[1m        # It's possible that users might accidentally send a Request object.[0m
[1m        # Guard against that specific failure case.[0m
[1m        if not isinstance(request, PreparedRequest):[0m
[1m            raise ValueError('You can only send PreparedRequests.')[0m
[1m    [0m
[1m        # Set up variables needed for resolve_redirects and dispatching of[0m
[1m        # hooks[0m
[1m        allow_redirects = kwargs.pop('allow_redirects', True)[0m
[1m        stream = kwargs.get('stream')[0m
[1m        timeout = kwargs.get('timeout')[0m
[1m        verify = kwargs.get('verify')[0m
[1m        cert = kwargs.get('cert')[0m
[1m        proxies = kwargs.get('proxies')[0m
[1m        hooks = request.hooks[0m
[1m    [0m
[1m        # Get the appropriate adapter to use[0m
[1m        adapter = self.get_adapter(url=request.url)[0m
[1m    [0m
[1m        # Start time (approximately) of the request[0m
[1m        start = datetime.utcnow()[0m
[1m        # Send the request[0m
[1m>       r = adapter.send(request, **kwargs)[0m

requests/sessions.py:460: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.adapters.HTTPAdapter object at 0x276bf90>
request = <PreparedRequest [PUT]>, stream = False, timeout = None, verify = True
cert = None, proxies = OrderedDict()

[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):[0m
[1m        """Sends PreparedRequest object. Returns Response object.[0m
[1m    [0m
[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.[0m
[1m            :param stream: (optional) Whether to stream the request content.[0m
[1m            :param timeout: (optional) The timeout on the request.[0m
[1m            :param verify: (optional) Whether to verify SSL certificates.[0m
[1m            :param vert: (optional) Any user-provided SSL certificate to be trusted.[0m
[1m            :param proxies: (optional) The proxies dictionary to apply to the request.[0m
[1m            """[0m
[1m    [0m
[1m        conn = self.get_connection(request.url, proxies)[0m
[1m    [0m
[1m        self.cert_verify(conn, request.url, verify, cert)[0m
[1m        url = self.request_url(request, proxies)[0m
[1m        self.add_headers(request)[0m
[1m    [0m
[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)[0m
[1m    [0m
[1m        if stream:[0m
[1m            timeout = Timeout(connect=timeout)[0m
[1m        else:[0m
[1m>           timeout = Timeout(connect=timeout, read=timeout)[0m
[1m[31mE           TypeError: Timeout does not take keyword arguments[0m

requests/adapters.py:305: TypeError
_________________ RequestsTestCase.test_unicode_multipart_post _________________

self = <test_requests.RequestsTestCase testMethod=test_unicode_multipart_post>

[1m    def test_unicode_multipart_post(self):[0m
[1m        r = requests.post(httpbin('post'),[0m
[1m                          data={'stuff': u'ëlïxr'},[0m
[1m>                         files={'file': ('test_requests.py', open(__file__, 'rb'))})[0m

test_requests.py:407: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

url = 'http://httpbin.org/post', data = {'stuff': u'\xebl\xefxr'}
kwargs = {'files': {'file': ('test_requests.py', <open file '/home/travis/build/kennethreitz/requests/test_requests.py', mode 'rb' at 0x29ba300>)}}

[1m    def post(url, data=None, **kwargs):[0m
[1m        """Sends a POST request. Returns :class:`Response` object.[0m
[1m    [0m
[1m        :param url: URL for the new :class:`Request` object.[0m
[1m        :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.[0m
[1m        :param \*\*kwargs: Optional arguments that ``request`` takes.[0m
[1m        """[0m
[1m    [0m
[1m>       return request('post', url, data=data, **kwargs)[0m

requests/api.py:88: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

method = 'post', url = 'http://httpbin.org/post'
kwargs = {'data': {'stuff': u'\xebl\xefxr'}, 'files': {'file': ('test_requests.py', <open file '/home/travis/build/kennethreitz/requests/test_requests.py', mode 'rb' at 0x29ba300>)}}
session = <requests.sessions.Session object at 0x2796090>

[1m    def request(method, url, **kwargs):[0m
[1m        """Constructs and sends a :class:`Request <Request>`.[0m
[1m        Returns :class:`Response <Response>` object.[0m
[1m    [0m
[1m        :param method: method for the new :class:`Request` object.[0m
[1m        :param url: URL for the new :class:`Request` object.[0m
[1m        :param params: (optional) Dictionary or bytes to be sent in the query string for the :class:`Request`.[0m
[1m        :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.[0m
[1m        :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.[0m
[1m        :param cookies: (optional) Dict or CookieJar object to send with the :class:`Request`.[0m
[1m        :param files: (optional) Dictionary of 'name': file-like-objects (or {'name': ('filename', fileobj)}) for multipart encoding upload.[0m
[1m        :param auth: (optional) Auth tuple to enable Basic/Digest/Custom HTTP Auth.[0m
[1m        :param timeout: (optional) Float describing the timeout of the request.[0m
[1m        :param allow_redirects: (optional) Boolean. Set to True if POST/PUT/DELETE redirect following is allowed.[0m
[1m        :param proxies: (optional) Dictionary mapping protocol to the URL of the proxy.[0m
[1m        :param verify: (optional) if ``True``, the SSL cert will be verified. A CA_BUNDLE path can also be provided.[0m
[1m        :param stream: (optional) if ``False``, the response content will be immediately downloaded.[0m
[1m        :param cert: (optional) if String, path to ssl client cert file (.pem). If Tuple, ('cert', 'key') pair.[0m
[1m    [0m
[1m        Usage::[0m
[1m    [0m
[1m          >>> import requests[0m
[1m          >>> req = requests.request('GET', 'http://httpbin.org/get')[0m
[1m          <Response [200]>[0m
[1m        """[0m
[1m    [0m
[1m        session = sessions.Session()[0m
[1m>       return session.request(method=method, url=url, **kwargs)[0m

requests/api.py:44: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x2796090>, method = 'post'
url = 'http://httpbin.org/post', params = None, data = {'stuff': u'\xebl\xefxr'}
headers = None, cookies = None
files = {'file': ('test_requests.py', <open file '/home/travis/build/kennethreitz/requests/test_requests.py', mode 'rb' at 0x29ba300>)}
auth = None, timeout = None, allow_redirects = True, proxies = OrderedDict()
hooks = None, stream = False, verify = True, cert = None

[1m    def request(self, method, url,[0m
[1m        params=None,[0m
[1m        data=None,[0m
[1m        headers=None,[0m
[1m        cookies=None,[0m
[1m        files=None,[0m
[1m        auth=None,[0m
[1m        timeout=None,[0m
[1m        allow_redirects=True,[0m
[1m        proxies=None,[0m
[1m        hooks=None,[0m
[1m        stream=None,[0m
[1m        verify=None,[0m
[1m        cert=None):[0m
[1m        """Constructs a :class:`Request <Request>`, prepares it and sends it.[0m
[1m            Returns :class:`Response <Response>` object.[0m
[1m    [0m
[1m            :param method: method for the new :class:`Request` object.[0m
[1m            :param url: URL for the new :class:`Request` object.[0m
[1m            :param params: (optional) Dictionary or bytes to be sent in the query[0m
[1m                string for the :class:`Request`.[0m
[1m            :param data: (optional) Dictionary or bytes to send in the body of the[0m
[1m                :class:`Request`.[0m
[1m            :param headers: (optional) Dictionary of HTTP Headers to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param cookies: (optional) Dict or CookieJar object to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param files: (optional) Dictionary of 'filename': file-like-objects[0m
[1m                for multipart encoding upload.[0m
[1m            :param auth: (optional) Auth tuple or callable to enable[0m
[1m                Basic/Digest/Custom HTTP Auth.[0m
[1m            :param timeout: (optional) Float describing the timeout of the[0m
[1m                request.[0m
[1m            :param allow_redirects: (optional) Boolean. Set to True by default.[0m
[1m            :param proxies: (optional) Dictionary mapping protocol to the URL of[0m
[1m                the proxy.[0m
[1m            :param stream: (optional) whether to immediately download the response[0m
[1m                content. Defaults to ``False``.[0m
[1m            :param verify: (optional) if ``True``, the SSL cert will be verified.[0m
[1m                A CA_BUNDLE path can also be provided.[0m
[1m            :param cert: (optional) if String, path to ssl client cert file (.pem).[0m
[1m                If Tuple, ('cert', 'key') pair.[0m
[1m            """[0m
[1m        # Create the Request.[0m
[1m        req = Request([0m
[1m            method = method.upper(),[0m
[1m            url = url,[0m
[1m            headers = headers,[0m
[1m            files = files,[0m
[1m            data = data or {},[0m
[1m            params = params or {},[0m
[1m            auth = auth,[0m
[1m            cookies = cookies,[0m
[1m            hooks = hooks,[0m
[1m        )[0m
[1m        prep = self.prepare_request(req)[0m
[1m    [0m
[1m        proxies = proxies or {}[0m
[1m    [0m
[1m        # Gather clues from the surrounding environment.[0m
[1m        if self.trust_env:[0m
[1m            # Set environment's proxies.[0m
[1m            env_proxies = get_environ_proxies(url) or {}[0m
[1m            for (k, v) in env_proxies.items():[0m
[1m                proxies.setdefault(k, v)[0m
[1m    [0m
[1m            # Look for configuration.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('REQUESTS_CA_BUNDLE')[0m
[1m    [0m
[1m            # Curl compatibility.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('CURL_CA_BUNDLE')[0m
[1m    [0m
[1m        # Merge all the kwargs.[0m
[1m        proxies = merge_setting(proxies, self.proxies)[0m
[1m        stream = merge_setting(stream, self.stream)[0m
[1m        verify = merge_setting(verify, self.verify)[0m
[1m        cert = merge_setting(cert, self.cert)[0m
[1m    [0m
[1m        # Send the request.[0m
[1m        send_kwargs = {[0m
[1m            'stream': stream,[0m
[1m            'timeout': timeout,[0m
[1m            'verify': verify,[0m
[1m            'cert': cert,[0m
[1m            'proxies': proxies,[0m
[1m            'allow_redirects': allow_redirects,[0m
[1m        }[0m
[1m>       resp = self.send(prep, **send_kwargs)[0m

requests/sessions.py:357: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x2796090>
request = <PreparedRequest [POST]>
kwargs = {'cert': None, 'proxies': OrderedDict(), 'stream': False, 'timeout': None, ...}
allow_redirects = True, stream = False, timeout = None, verify = True
cert = None, proxies = OrderedDict(), hooks = {'response': []}

[1m    def send(self, request, **kwargs):[0m
[1m        """Send a given PreparedRequest."""[0m
[1m        # Set defaults that the hooks can utilize to ensure they always have[0m
[1m        # the correct parameters to reproduce the previous request.[0m
[1m        kwargs.setdefault('stream', self.stream)[0m
[1m        kwargs.setdefault('verify', self.verify)[0m
[1m        kwargs.setdefault('cert', self.cert)[0m
[1m        kwargs.setdefault('proxies', self.proxies)[0m
[1m    [0m
[1m        # It's possible that users might accidentally send a Request object.[0m
[1m        # Guard against that specific failure case.[0m
[1m        if not isinstance(request, PreparedRequest):[0m
[1m            raise ValueError('You can only send PreparedRequests.')[0m
[1m    [0m
[1m        # Set up variables needed for resolve_redirects and dispatching of[0m
[1m        # hooks[0m
[1m        allow_redirects = kwargs.pop('allow_redirects', True)[0m
[1m        stream = kwargs.get('stream')[0m
[1m        timeout = kwargs.get('timeout')[0m
[1m        verify = kwargs.get('verify')[0m
[1m        cert = kwargs.get('cert')[0m
[1m        proxies = kwargs.get('proxies')[0m
[1m        hooks = request.hooks[0m
[1m    [0m
[1m        # Get the appropriate adapter to use[0m
[1m        adapter = self.get_adapter(url=request.url)[0m
[1m    [0m
[1m        # Start time (approximately) of the request[0m
[1m        start = datetime.utcnow()[0m
[1m        # Send the request[0m
[1m>       r = adapter.send(request, **kwargs)[0m

requests/sessions.py:460: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.adapters.HTTPAdapter object at 0x2796250>
request = <PreparedRequest [POST]>, stream = False, timeout = None
verify = True, cert = None, proxies = OrderedDict()

[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):[0m
[1m        """Sends PreparedRequest object. Returns Response object.[0m
[1m    [0m
[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.[0m
[1m            :param stream: (optional) Whether to stream the request content.[0m
[1m            :param timeout: (optional) The timeout on the request.[0m
[1m            :param verify: (optional) Whether to verify SSL certificates.[0m
[1m            :param vert: (optional) Any user-provided SSL certificate to be trusted.[0m
[1m            :param proxies: (optional) The proxies dictionary to apply to the request.[0m
[1m            """[0m
[1m    [0m
[1m        conn = self.get_connection(request.url, proxies)[0m
[1m    [0m
[1m        self.cert_verify(conn, request.url, verify, cert)[0m
[1m        url = self.request_url(request, proxies)[0m
[1m        self.add_headers(request)[0m
[1m    [0m
[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)[0m
[1m    [0m
[1m        if stream:[0m
[1m            timeout = Timeout(connect=timeout)[0m
[1m        else:[0m
[1m>           timeout = Timeout(connect=timeout, read=timeout)[0m
[1m[31mE           TypeError: Timeout does not take keyword arguments[0m

requests/adapters.py:305: TypeError
_______________ RequestsTestCase.test_uppercase_scheme_redirect ________________

self = <test_requests.RequestsTestCase testMethod=test_uppercase_scheme_redirect>

[1m    def test_uppercase_scheme_redirect(self):[0m
[1m        parts = urlparse(httpbin('html'))[0m
[1m        url = "HTTP://" + parts.netloc + parts.path[0m
[1m>       r = requests.get(httpbin('redirect-to'), params={'url': url})[0m

test_requests.py:598: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

url = 'http://httpbin.org/redirect-to'
kwargs = {'allow_redirects': True, 'params': {'url': 'HTTP://httpbin.org/html'}}

[1m    def get(url, **kwargs):[0m
[1m        """Sends a GET request. Returns :class:`Response` object.[0m
[1m    [0m
[1m        :param url: URL for the new :class:`Request` object.[0m
[1m        :param \*\*kwargs: Optional arguments that ``request`` takes.[0m
[1m        """[0m
[1m    [0m
[1m        kwargs.setdefault('allow_redirects', True)[0m
[1m>       return request('get', url, **kwargs)[0m

requests/api.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

method = 'get', url = 'http://httpbin.org/redirect-to'
kwargs = {'allow_redirects': True, 'params': {'url': 'HTTP://httpbin.org/html'}}
session = <requests.sessions.Session object at 0x2774ad0>

[1m    def request(method, url, **kwargs):[0m
[1m        """Constructs and sends a :class:`Request <Request>`.[0m
[1m        Returns :class:`Response <Response>` object.[0m
[1m    [0m
[1m        :param method: method for the new :class:`Request` object.[0m
[1m        :param url: URL for the new :class:`Request` object.[0m
[1m        :param params: (optional) Dictionary or bytes to be sent in the query string for the :class:`Request`.[0m
[1m        :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.[0m
[1m        :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.[0m
[1m        :param cookies: (optional) Dict or CookieJar object to send with the :class:`Request`.[0m
[1m        :param files: (optional) Dictionary of 'name': file-like-objects (or {'name': ('filename', fileobj)}) for multipart encoding upload.[0m
[1m        :param auth: (optional) Auth tuple to enable Basic/Digest/Custom HTTP Auth.[0m
[1m        :param timeout: (optional) Float describing the timeout of the request.[0m
[1m        :param allow_redirects: (optional) Boolean. Set to True if POST/PUT/DELETE redirect following is allowed.[0m
[1m        :param proxies: (optional) Dictionary mapping protocol to the URL of the proxy.[0m
[1m        :param verify: (optional) if ``True``, the SSL cert will be verified. A CA_BUNDLE path can also be provided.[0m
[1m        :param stream: (optional) if ``False``, the response content will be immediately downloaded.[0m
[1m        :param cert: (optional) if String, path to ssl client cert file (.pem). If Tuple, ('cert', 'key') pair.[0m
[1m    [0m
[1m        Usage::[0m
[1m    [0m
[1m          >>> import requests[0m
[1m          >>> req = requests.request('GET', 'http://httpbin.org/get')[0m
[1m          <Response [200]>[0m
[1m        """[0m
[1m    [0m
[1m        session = sessions.Session()[0m
[1m>       return session.request(method=method, url=url, **kwargs)[0m

requests/api.py:44: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x2774ad0>, method = 'get'
url = 'http://httpbin.org/redirect-to'
params = {'url': 'HTTP://httpbin.org/html'}, data = None, headers = None
cookies = None, files = None, auth = None, timeout = None
allow_redirects = True, proxies = OrderedDict(), hooks = None, stream = False
verify = True, cert = None

[1m    def request(self, method, url,[0m
[1m        params=None,[0m
[1m        data=None,[0m
[1m        headers=None,[0m
[1m        cookies=None,[0m
[1m        files=None,[0m
[1m        auth=None,[0m
[1m        timeout=None,[0m
[1m        allow_redirects=True,[0m
[1m        proxies=None,[0m
[1m        hooks=None,[0m
[1m        stream=None,[0m
[1m        verify=None,[0m
[1m        cert=None):[0m
[1m        """Constructs a :class:`Request <Request>`, prepares it and sends it.[0m
[1m            Returns :class:`Response <Response>` object.[0m
[1m    [0m
[1m            :param method: method for the new :class:`Request` object.[0m
[1m            :param url: URL for the new :class:`Request` object.[0m
[1m            :param params: (optional) Dictionary or bytes to be sent in the query[0m
[1m                string for the :class:`Request`.[0m
[1m            :param data: (optional) Dictionary or bytes to send in the body of the[0m
[1m                :class:`Request`.[0m
[1m            :param headers: (optional) Dictionary of HTTP Headers to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param cookies: (optional) Dict or CookieJar object to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param files: (optional) Dictionary of 'filename': file-like-objects[0m
[1m                for multipart encoding upload.[0m
[1m            :param auth: (optional) Auth tuple or callable to enable[0m
[1m                Basic/Digest/Custom HTTP Auth.[0m
[1m            :param timeout: (optional) Float describing the timeout of the[0m
[1m                request.[0m
[1m            :param allow_redirects: (optional) Boolean. Set to True by default.[0m
[1m            :param proxies: (optional) Dictionary mapping protocol to the URL of[0m
[1m                the proxy.[0m
[1m            :param stream: (optional) whether to immediately download the response[0m
[1m                content. Defaults to ``False``.[0m
[1m            :param verify: (optional) if ``True``, the SSL cert will be verified.[0m
[1m                A CA_BUNDLE path can also be provided.[0m
[1m            :param cert: (optional) if String, path to ssl client cert file (.pem).[0m
[1m                If Tuple, ('cert', 'key') pair.[0m
[1m            """[0m
[1m        # Create the Request.[0m
[1m        req = Request([0m
[1m            method = method.upper(),[0m
[1m            url = url,[0m
[1m            headers = headers,[0m
[1m            files = files,[0m
[1m            data = data or {},[0m
[1m            params = params or {},[0m
[1m            auth = auth,[0m
[1m            cookies = cookies,[0m
[1m            hooks = hooks,[0m
[1m        )[0m
[1m        prep = self.prepare_request(req)[0m
[1m    [0m
[1m        proxies = proxies or {}[0m
[1m    [0m
[1m        # Gather clues from the surrounding environment.[0m
[1m        if self.trust_env:[0m
[1m            # Set environment's proxies.[0m
[1m            env_proxies = get_environ_proxies(url) or {}[0m
[1m            for (k, v) in env_proxies.items():[0m
[1m                proxies.setdefault(k, v)[0m
[1m    [0m
[1m            # Look for configuration.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('REQUESTS_CA_BUNDLE')[0m
[1m    [0m
[1m            # Curl compatibility.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('CURL_CA_BUNDLE')[0m
[1m    [0m
[1m        # Merge all the kwargs.[0m
[1m        proxies = merge_setting(proxies, self.proxies)[0m
[1m        stream = merge_setting(stream, self.stream)[0m
[1m        verify = merge_setting(verify, self.verify)[0m
[1m        cert = merge_setting(cert, self.cert)[0m
[1m    [0m
[1m        # Send the request.[0m
[1m        send_kwargs = {[0m
[1m            'stream': stream,[0m
[1m            'timeout': timeout,[0m
[1m            'verify': verify,[0m
[1m            'cert': cert,[0m
[1m            'proxies': proxies,[0m
[1m            'allow_redirects': allow_redirects,[0m
[1m        }[0m
[1m>       resp = self.send(prep, **send_kwargs)[0m

requests/sessions.py:357: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x2774ad0>
request = <PreparedRequest [GET]>
kwargs = {'cert': None, 'proxies': OrderedDict(), 'stream': False, 'timeout': None, ...}
allow_redirects = True, stream = False, timeout = None, verify = True
cert = None, proxies = OrderedDict(), hooks = {'response': []}

[1m    def send(self, request, **kwargs):[0m
[1m        """Send a given PreparedRequest."""[0m
[1m        # Set defaults that the hooks can utilize to ensure they always have[0m
[1m        # the correct parameters to reproduce the previous request.[0m
[1m        kwargs.setdefault('stream', self.stream)[0m
[1m        kwargs.setdefault('verify', self.verify)[0m
[1m        kwargs.setdefault('cert', self.cert)[0m
[1m        kwargs.setdefault('proxies', self.proxies)[0m
[1m    [0m
[1m        # It's possible that users might accidentally send a Request object.[0m
[1m        # Guard against that specific failure case.[0m
[1m        if not isinstance(request, PreparedRequest):[0m
[1m            raise ValueError('You can only send PreparedRequests.')[0m
[1m    [0m
[1m        # Set up variables needed for resolve_redirects and dispatching of[0m
[1m        # hooks[0m
[1m        allow_redirects = kwargs.pop('allow_redirects', True)[0m
[1m        stream = kwargs.get('stream')[0m
[1m        timeout = kwargs.get('timeout')[0m
[1m        verify = kwargs.get('verify')[0m
[1m        cert = kwargs.get('cert')[0m
[1m        proxies = kwargs.get('proxies')[0m
[1m        hooks = request.hooks[0m
[1m    [0m
[1m        # Get the appropriate adapter to use[0m
[1m        adapter = self.get_adapter(url=request.url)[0m
[1m    [0m
[1m        # Start time (approximately) of the request[0m
[1m        start = datetime.utcnow()[0m
[1m        # Send the request[0m
[1m>       r = adapter.send(request, **kwargs)[0m

requests/sessions.py:460: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.adapters.HTTPAdapter object at 0x27748d0>
request = <PreparedRequest [GET]>, stream = False, timeout = None, verify = True
cert = None, proxies = OrderedDict()

[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):[0m
[1m        """Sends PreparedRequest object. Returns Response object.[0m
[1m    [0m
[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.[0m
[1m            :param stream: (optional) Whether to stream the request content.[0m
[1m            :param timeout: (optional) The timeout on the request.[0m
[1m            :param verify: (optional) Whether to verify SSL certificates.[0m
[1m            :param vert: (optional) Any user-provided SSL certificate to be trusted.[0m
[1m            :param proxies: (optional) The proxies dictionary to apply to the request.[0m
[1m            """[0m
[1m    [0m
[1m        conn = self.get_connection(request.url, proxies)[0m
[1m    [0m
[1m        self.cert_verify(conn, request.url, verify, cert)[0m
[1m        url = self.request_url(request, proxies)[0m
[1m        self.add_headers(request)[0m
[1m    [0m
[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)[0m
[1m    [0m
[1m        if stream:[0m
[1m            timeout = Timeout(connect=timeout)[0m
[1m        else:[0m
[1m>           timeout = Timeout(connect=timeout, read=timeout)[0m
[1m[31mE           TypeError: Timeout does not take keyword arguments[0m

requests/adapters.py:305: TypeError
_________ RequestsTestCase.test_urlencoded_get_query_multivalued_param _________

self = <test_requests.RequestsTestCase testMethod=test_urlencoded_get_query_multivalued_param>

[1m    def test_urlencoded_get_query_multivalued_param(self):[0m
[1m    [0m
[1m>       r = requests.get(httpbin('get'), params=dict(test=['foo', 'baz']))[0m

test_requests.py:393: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

url = 'http://httpbin.org/get'
kwargs = {'allow_redirects': True, 'params': {'test': ['foo', 'baz']}}

[1m    def get(url, **kwargs):[0m
[1m        """Sends a GET request. Returns :class:`Response` object.[0m
[1m    [0m
[1m        :param url: URL for the new :class:`Request` object.[0m
[1m        :param \*\*kwargs: Optional arguments that ``request`` takes.[0m
[1m        """[0m
[1m    [0m
[1m        kwargs.setdefault('allow_redirects', True)[0m
[1m>       return request('get', url, **kwargs)[0m

requests/api.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

method = 'get', url = 'http://httpbin.org/get'
kwargs = {'allow_redirects': True, 'params': {'test': ['foo', 'baz']}}
session = <requests.sessions.Session object at 0x2a29610>

[1m    def request(method, url, **kwargs):[0m
[1m        """Constructs and sends a :class:`Request <Request>`.[0m
[1m        Returns :class:`Response <Response>` object.[0m
[1m    [0m
[1m        :param method: method for the new :class:`Request` object.[0m
[1m        :param url: URL for the new :class:`Request` object.[0m
[1m        :param params: (optional) Dictionary or bytes to be sent in the query string for the :class:`Request`.[0m
[1m        :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.[0m
[1m        :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.[0m
[1m        :param cookies: (optional) Dict or CookieJar object to send with the :class:`Request`.[0m
[1m        :param files: (optional) Dictionary of 'name': file-like-objects (or {'name': ('filename', fileobj)}) for multipart encoding upload.[0m
[1m        :param auth: (optional) Auth tuple to enable Basic/Digest/Custom HTTP Auth.[0m
[1m        :param timeout: (optional) Float describing the timeout of the request.[0m
[1m        :param allow_redirects: (optional) Boolean. Set to True if POST/PUT/DELETE redirect following is allowed.[0m
[1m        :param proxies: (optional) Dictionary mapping protocol to the URL of the proxy.[0m
[1m        :param verify: (optional) if ``True``, the SSL cert will be verified. A CA_BUNDLE path can also be provided.[0m
[1m        :param stream: (optional) if ``False``, the response content will be immediately downloaded.[0m
[1m        :param cert: (optional) if String, path to ssl client cert file (.pem). If Tuple, ('cert', 'key') pair.[0m
[1m    [0m
[1m        Usage::[0m
[1m    [0m
[1m          >>> import requests[0m
[1m          >>> req = requests.request('GET', 'http://httpbin.org/get')[0m
[1m          <Response [200]>[0m
[1m        """[0m
[1m    [0m
[1m        session = sessions.Session()[0m
[1m>       return session.request(method=method, url=url, **kwargs)[0m

requests/api.py:44: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x2a29610>, method = 'get'
url = 'http://httpbin.org/get', params = {'test': ['foo', 'baz']}, data = None
headers = None, cookies = None, files = None, auth = None, timeout = None
allow_redirects = True, proxies = OrderedDict(), hooks = None, stream = False
verify = True, cert = None

[1m    def request(self, method, url,[0m
[1m        params=None,[0m
[1m        data=None,[0m
[1m        headers=None,[0m
[1m        cookies=None,[0m
[1m        files=None,[0m
[1m        auth=None,[0m
[1m        timeout=None,[0m
[1m        allow_redirects=True,[0m
[1m        proxies=None,[0m
[1m        hooks=None,[0m
[1m        stream=None,[0m
[1m        verify=None,[0m
[1m        cert=None):[0m
[1m        """Constructs a :class:`Request <Request>`, prepares it and sends it.[0m
[1m            Returns :class:`Response <Response>` object.[0m
[1m    [0m
[1m            :param method: method for the new :class:`Request` object.[0m
[1m            :param url: URL for the new :class:`Request` object.[0m
[1m            :param params: (optional) Dictionary or bytes to be sent in the query[0m
[1m                string for the :class:`Request`.[0m
[1m            :param data: (optional) Dictionary or bytes to send in the body of the[0m
[1m                :class:`Request`.[0m
[1m            :param headers: (optional) Dictionary of HTTP Headers to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param cookies: (optional) Dict or CookieJar object to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param files: (optional) Dictionary of 'filename': file-like-objects[0m
[1m                for multipart encoding upload.[0m
[1m            :param auth: (optional) Auth tuple or callable to enable[0m
[1m                Basic/Digest/Custom HTTP Auth.[0m
[1m            :param timeout: (optional) Float describing the timeout of the[0m
[1m                request.[0m
[1m            :param allow_redirects: (optional) Boolean. Set to True by default.[0m
[1m            :param proxies: (optional) Dictionary mapping protocol to the URL of[0m
[1m                the proxy.[0m
[1m            :param stream: (optional) whether to immediately download the response[0m
[1m                content. Defaults to ``False``.[0m
[1m            :param verify: (optional) if ``True``, the SSL cert will be verified.[0m
[1m                A CA_BUNDLE path can also be provided.[0m
[1m            :param cert: (optional) if String, path to ssl client cert file (.pem).[0m
[1m                If Tuple, ('cert', 'key') pair.[0m
[1m            """[0m
[1m        # Create the Request.[0m
[1m        req = Request([0m
[1m            method = method.upper(),[0m
[1m            url = url,[0m
[1m            headers = headers,[0m
[1m            files = files,[0m
[1m            data = data or {},[0m
[1m            params = params or {},[0m
[1m            auth = auth,[0m
[1m            cookies = cookies,[0m
[1m            hooks = hooks,[0m
[1m        )[0m
[1m        prep = self.prepare_request(req)[0m
[1m    [0m
[1m        proxies = proxies or {}[0m
[1m    [0m
[1m        # Gather clues from the surrounding environment.[0m
[1m        if self.trust_env:[0m
[1m            # Set environment's proxies.[0m
[1m            env_proxies = get_environ_proxies(url) or {}[0m
[1m            for (k, v) in env_proxies.items():[0m
[1m                proxies.setdefault(k, v)[0m
[1m    [0m
[1m            # Look for configuration.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('REQUESTS_CA_BUNDLE')[0m
[1m    [0m
[1m            # Curl compatibility.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('CURL_CA_BUNDLE')[0m
[1m    [0m
[1m        # Merge all the kwargs.[0m
[1m        proxies = merge_setting(proxies, self.proxies)[0m
[1m        stream = merge_setting(stream, self.stream)[0m
[1m        verify = merge_setting(verify, self.verify)[0m
[1m        cert = merge_setting(cert, self.cert)[0m
[1m    [0m
[1m        # Send the request.[0m
[1m        send_kwargs = {[0m
[1m            'stream': stream,[0m
[1m            'timeout': timeout,[0m
[1m            'verify': verify,[0m
[1m            'cert': cert,[0m
[1m            'proxies': proxies,[0m
[1m            'allow_redirects': allow_redirects,[0m
[1m        }[0m
[1m>       resp = self.send(prep, **send_kwargs)[0m

requests/sessions.py:357: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x2a29610>
request = <PreparedRequest [GET]>
kwargs = {'cert': None, 'proxies': OrderedDict(), 'stream': False, 'timeout': None, ...}
allow_redirects = True, stream = False, timeout = None, verify = True
cert = None, proxies = OrderedDict(), hooks = {'response': []}

[1m    def send(self, request, **kwargs):[0m
[1m        """Send a given PreparedRequest."""[0m
[1m        # Set defaults that the hooks can utilize to ensure they always have[0m
[1m        # the correct parameters to reproduce the previous request.[0m
[1m        kwargs.setdefault('stream', self.stream)[0m
[1m        kwargs.setdefault('verify', self.verify)[0m
[1m        kwargs.setdefault('cert', self.cert)[0m
[1m        kwargs.setdefault('proxies', self.proxies)[0m
[1m    [0m
[1m        # It's possible that users might accidentally send a Request object.[0m
[1m        # Guard against that specific failure case.[0m
[1m        if not isinstance(request, PreparedRequest):[0m
[1m            raise ValueError('You can only send PreparedRequests.')[0m
[1m    [0m
[1m        # Set up variables needed for resolve_redirects and dispatching of[0m
[1m        # hooks[0m
[1m        allow_redirects = kwargs.pop('allow_redirects', True)[0m
[1m        stream = kwargs.get('stream')[0m
[1m        timeout = kwargs.get('timeout')[0m
[1m        verify = kwargs.get('verify')[0m
[1m        cert = kwargs.get('cert')[0m
[1m        proxies = kwargs.get('proxies')[0m
[1m        hooks = request.hooks[0m
[1m    [0m
[1m        # Get the appropriate adapter to use[0m
[1m        adapter = self.get_adapter(url=request.url)[0m
[1m    [0m
[1m        # Start time (approximately) of the request[0m
[1m        start = datetime.utcnow()[0m
[1m        # Send the request[0m
[1m>       r = adapter.send(request, **kwargs)[0m

requests/sessions.py:460: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.adapters.HTTPAdapter object at 0x2a29410>
request = <PreparedRequest [GET]>, stream = False, timeout = None, verify = True
cert = None, proxies = OrderedDict()

[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):[0m
[1m        """Sends PreparedRequest object. Returns Response object.[0m
[1m    [0m
[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.[0m
[1m            :param stream: (optional) Whether to stream the request content.[0m
[1m            :param timeout: (optional) The timeout on the request.[0m
[1m            :param verify: (optional) Whether to verify SSL certificates.[0m
[1m            :param vert: (optional) Any user-provided SSL certificate to be trusted.[0m
[1m            :param proxies: (optional) The proxies dictionary to apply to the request.[0m
[1m            """[0m
[1m    [0m
[1m        conn = self.get_connection(request.url, proxies)[0m
[1m    [0m
[1m        self.cert_verify(conn, request.url, verify, cert)[0m
[1m        url = self.request_url(request, proxies)[0m
[1m        self.add_headers(request)[0m
[1m    [0m
[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)[0m
[1m    [0m
[1m        if stream:[0m
[1m            timeout = Timeout(connect=timeout)[0m
[1m        else:[0m
[1m>           timeout = Timeout(connect=timeout, read=timeout)[0m
[1m[31mE           TypeError: Timeout does not take keyword arguments[0m

requests/adapters.py:305: TypeError
__________________ RequestsTestCase.test_user_agent_transfers __________________

self = <test_requests.RequestsTestCase testMethod=test_user_agent_transfers>

[1m    def test_user_agent_transfers(self):[0m
[1m    [0m
[1m        heads = {[0m
[1m            'User-agent': 'Mozilla/5.0 (github.com/kennethreitz/requests)'[0m
[1m        }[0m
[1m    [0m
[1m>       r = requests.get(httpbin('user-agent'), headers=heads)[0m

test_requests.py:198: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

url = 'http://httpbin.org/user-agent'
kwargs = {'allow_redirects': True, 'headers': {'User-agent': 'Mozilla/5.0 (github.com/kennethreitz/requests)'}}

[1m    def get(url, **kwargs):[0m
[1m        """Sends a GET request. Returns :class:`Response` object.[0m
[1m    [0m
[1m        :param url: URL for the new :class:`Request` object.[0m
[1m        :param \*\*kwargs: Optional arguments that ``request`` takes.[0m
[1m        """[0m
[1m    [0m
[1m        kwargs.setdefault('allow_redirects', True)[0m
[1m>       return request('get', url, **kwargs)[0m

requests/api.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

method = 'get', url = 'http://httpbin.org/user-agent'
kwargs = {'allow_redirects': True, 'headers': {'User-agent': 'Mozilla/5.0 (github.com/kennethreitz/requests)'}}
session = <requests.sessions.Session object at 0x29d3dd0>

[1m    def request(method, url, **kwargs):[0m
[1m        """Constructs and sends a :class:`Request <Request>`.[0m
[1m        Returns :class:`Response <Response>` object.[0m
[1m    [0m
[1m        :param method: method for the new :class:`Request` object.[0m
[1m        :param url: URL for the new :class:`Request` object.[0m
[1m        :param params: (optional) Dictionary or bytes to be sent in the query string for the :class:`Request`.[0m
[1m        :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.[0m
[1m        :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.[0m
[1m        :param cookies: (optional) Dict or CookieJar object to send with the :class:`Request`.[0m
[1m        :param files: (optional) Dictionary of 'name': file-like-objects (or {'name': ('filename', fileobj)}) for multipart encoding upload.[0m
[1m        :param auth: (optional) Auth tuple to enable Basic/Digest/Custom HTTP Auth.[0m
[1m        :param timeout: (optional) Float describing the timeout of the request.[0m
[1m        :param allow_redirects: (optional) Boolean. Set to True if POST/PUT/DELETE redirect following is allowed.[0m
[1m        :param proxies: (optional) Dictionary mapping protocol to the URL of the proxy.[0m
[1m        :param verify: (optional) if ``True``, the SSL cert will be verified. A CA_BUNDLE path can also be provided.[0m
[1m        :param stream: (optional) if ``False``, the response content will be immediately downloaded.[0m
[1m        :param cert: (optional) if String, path to ssl client cert file (.pem). If Tuple, ('cert', 'key') pair.[0m
[1m    [0m
[1m        Usage::[0m
[1m    [0m
[1m          >>> import requests[0m
[1m          >>> req = requests.request('GET', 'http://httpbin.org/get')[0m
[1m          <Response [200]>[0m
[1m        """[0m
[1m    [0m
[1m        session = sessions.Session()[0m
[1m>       return session.request(method=method, url=url, **kwargs)[0m

requests/api.py:44: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x29d3dd0>, method = 'get'
url = 'http://httpbin.org/user-agent', params = None, data = None
headers = {'User-agent': 'Mozilla/5.0 (github.com/kennethreitz/requests)'}
cookies = None, files = None, auth = None, timeout = None
allow_redirects = True, proxies = OrderedDict(), hooks = None, stream = False
verify = True, cert = None

[1m    def request(self, method, url,[0m
[1m        params=None,[0m
[1m        data=None,[0m
[1m        headers=None,[0m
[1m        cookies=None,[0m
[1m        files=None,[0m
[1m        auth=None,[0m
[1m        timeout=None,[0m
[1m        allow_redirects=True,[0m
[1m        proxies=None,[0m
[1m        hooks=None,[0m
[1m        stream=None,[0m
[1m        verify=None,[0m
[1m        cert=None):[0m
[1m        """Constructs a :class:`Request <Request>`, prepares it and sends it.[0m
[1m            Returns :class:`Response <Response>` object.[0m
[1m    [0m
[1m            :param method: method for the new :class:`Request` object.[0m
[1m            :param url: URL for the new :class:`Request` object.[0m
[1m            :param params: (optional) Dictionary or bytes to be sent in the query[0m
[1m                string for the :class:`Request`.[0m
[1m            :param data: (optional) Dictionary or bytes to send in the body of the[0m
[1m                :class:`Request`.[0m
[1m            :param headers: (optional) Dictionary of HTTP Headers to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param cookies: (optional) Dict or CookieJar object to send with the[0m
[1m                :class:`Request`.[0m
[1m            :param files: (optional) Dictionary of 'filename': file-like-objects[0m
[1m                for multipart encoding upload.[0m
[1m            :param auth: (optional) Auth tuple or callable to enable[0m
[1m                Basic/Digest/Custom HTTP Auth.[0m
[1m            :param timeout: (optional) Float describing the timeout of the[0m
[1m                request.[0m
[1m            :param allow_redirects: (optional) Boolean. Set to True by default.[0m
[1m            :param proxies: (optional) Dictionary mapping protocol to the URL of[0m
[1m                the proxy.[0m
[1m            :param stream: (optional) whether to immediately download the response[0m
[1m                content. Defaults to ``False``.[0m
[1m            :param verify: (optional) if ``True``, the SSL cert will be verified.[0m
[1m                A CA_BUNDLE path can also be provided.[0m
[1m            :param cert: (optional) if String, path to ssl client cert file (.pem).[0m
[1m                If Tuple, ('cert', 'key') pair.[0m
[1m            """[0m
[1m        # Create the Request.[0m
[1m        req = Request([0m
[1m            method = method.upper(),[0m
[1m            url = url,[0m
[1m            headers = headers,[0m
[1m            files = files,[0m
[1m            data = data or {},[0m
[1m            params = params or {},[0m
[1m            auth = auth,[0m
[1m            cookies = cookies,[0m
[1m            hooks = hooks,[0m
[1m        )[0m
[1m        prep = self.prepare_request(req)[0m
[1m    [0m
[1m        proxies = proxies or {}[0m
[1m    [0m
[1m        # Gather clues from the surrounding environment.[0m
[1m        if self.trust_env:[0m
[1m            # Set environment's proxies.[0m
[1m            env_proxies = get_environ_proxies(url) or {}[0m
[1m            for (k, v) in env_proxies.items():[0m
[1m                proxies.setdefault(k, v)[0m
[1m    [0m
[1m            # Look for configuration.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('REQUESTS_CA_BUNDLE')[0m
[1m    [0m
[1m            # Curl compatibility.[0m
[1m            if not verify and verify is not False:[0m
[1m                verify = os.environ.get('CURL_CA_BUNDLE')[0m
[1m    [0m
[1m        # Merge all the kwargs.[0m
[1m        proxies = merge_setting(proxies, self.proxies)[0m
[1m        stream = merge_setting(stream, self.stream)[0m
[1m        verify = merge_setting(verify, self.verify)[0m
[1m        cert = merge_setting(cert, self.cert)[0m
[1m    [0m
[1m        # Send the request.[0m
[1m        send_kwargs = {[0m
[1m            'stream': stream,[0m
[1m            'timeout': timeout,[0m
[1m            'verify': verify,[0m
[1m            'cert': cert,[0m
[1m            'proxies': proxies,[0m
[1m            'allow_redirects': allow_redirects,[0m
[1m        }[0m
[1m>       resp = self.send(prep, **send_kwargs)[0m

requests/sessions.py:357: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.sessions.Session object at 0x29d3dd0>
request = <PreparedRequest [GET]>
kwargs = {'cert': None, 'proxies': OrderedDict(), 'stream': False, 'timeout': None, ...}
allow_redirects = True, stream = False, timeout = None, verify = True
cert = None, proxies = OrderedDict(), hooks = {'response': []}

[1m    def send(self, request, **kwargs):[0m
[1m        """Send a given PreparedRequest."""[0m
[1m        # Set defaults that the hooks can utilize to ensure they always have[0m
[1m        # the correct parameters to reproduce the previous request.[0m
[1m        kwargs.setdefault('stream', self.stream)[0m
[1m        kwargs.setdefault('verify', self.verify)[0m
[1m        kwargs.setdefault('cert', self.cert)[0m
[1m        kwargs.setdefault('proxies', self.proxies)[0m
[1m    [0m
[1m        # It's possible that users might accidentally send a Request object.[0m
[1m        # Guard against that specific failure case.[0m
[1m        if not isinstance(request, PreparedRequest):[0m
[1m            raise ValueError('You can only send PreparedRequests.')[0m
[1m    [0m
[1m        # Set up variables needed for resolve_redirects and dispatching of[0m
[1m        # hooks[0m
[1m        allow_redirects = kwargs.pop('allow_redirects', True)[0m
[1m        stream = kwargs.get('stream')[0m
[1m        timeout = kwargs.get('timeout')[0m
[1m        verify = kwargs.get('verify')[0m
[1m        cert = kwargs.get('cert')[0m
[1m        proxies = kwargs.get('proxies')[0m
[1m        hooks = request.hooks[0m
[1m    [0m
[1m        # Get the appropriate adapter to use[0m
[1m        adapter = self.get_adapter(url=request.url)[0m
[1m    [0m
[1m        # Start time (approximately) of the request[0m
[1m        start = datetime.utcnow()[0m
[1m        # Send the request[0m
[1m>       r = adapter.send(request, **kwargs)[0m

requests/sessions.py:460: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <requests.adapters.HTTPAdapter object at 0x29d3350>
request = <PreparedRequest [GET]>, stream = False, timeout = None, verify = True
cert = None, proxies = OrderedDict()

[1m    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):[0m
[1m        """Sends PreparedRequest object. Returns Response object.[0m
[1m    [0m
[1m            :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.[0m
[1m            :param stream: (optional) Whether to stream the request content.[0m
[1m            :param timeout: (optional) The timeout on the request.[0m
[1m            :param verify: (optional) Whether to verify SSL certificates.[0m
[1m            :param vert: (optional) Any user-provided SSL certificate to be trusted.[0m
[1m            :param proxies: (optional) The proxies dictionary to apply to the request.[0m
[1m            """[0m
[1m    [0m
[1m        conn = self.get_connection(request.url, proxies)[0m
[1m    [0m
[1m        self.cert_verify(conn, request.url, verify, cert)[0m
[1m        url = self.request_url(request, proxies)[0m
[1m        self.add_headers(request)[0m
[1m    [0m
[1m        chunked = not (request.body is None or 'Content-Length' in request.headers)[0m
[1m    [0m
[1m        if stream:[0m
[1m            timeout = Timeout(connect=timeout)[0m
[1m        else:[0m
[1m>           timeout = Timeout(connect=timeout, read=timeout)[0m
[1m[31mE           TypeError: Timeout does not take keyword arguments[0m

requests/adapters.py:305: TypeError
[1m===================== 41 failed, 43 passed in 4.20 seconds =====================[0m

The command "invoke test" exited with 1.

Done. Your build exited with 1.
